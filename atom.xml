<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYBO_o&#39;s Blogs</title>
  
  <subtitle>Follow Excellence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zybtree.github.io/"/>
  <updated>2020-04-12T04:08:32.712Z</updated>
  <id>https://zybtree.github.io/</id>
  
  <author>
    <name>ZYBO_o</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构Ⅷ排序</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅷ-排序/</id>
    <published>2020-04-12T03:54:09.000Z</published>
    <updated>2020-04-12T04:08:32.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="排序" scheme="https://zybtree.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅶ查找</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅶ查找/</id>
    <published>2020-04-12T03:53:45.000Z</published>
    <updated>2020-04-12T04:08:16.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="查找" scheme="https://zybtree.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅵ图</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅵ图/</id>
    <published>2020-04-12T03:53:24.000Z</published>
    <updated>2020-04-12T04:07:58.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="图" scheme="https://zybtree.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅴ树</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅴ树/</id>
    <published>2020-04-12T03:53:15.000Z</published>
    <updated>2020-04-12T04:07:47.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="树" scheme="https://zybtree.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅳ串</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅳ串/</id>
    <published>2020-04-12T03:52:59.000Z</published>
    <updated>2020-04-12T04:07:33.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串" scheme="https://zybtree.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅲ栈和队列/</id>
    <published>2020-04-12T03:52:40.000Z</published>
    <updated>2020-04-12T04:07:25.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="栈和队列" scheme="https://zybtree.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/</id>
    <published>2020-04-12T03:52:15.000Z</published>
    <updated>2020-06-03T04:53:21.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p><blockquote><p><strong>性质：</strong></p><ul><li>线性表中的数据元素之间是有顺序的。</li><li>线性表中的数据元素个数是有限的。</li><li>线性表中的数据元素的类型必须相同。</li></ul></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/1.png" style="zoom:50%;"><h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div><h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/2.png" style="zoom:45%;"><p>摘录来自: 程杰. “大话数据结构。” Apple Books. </p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div><h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p><ul><li>创建</li><li>分配内存</li><li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li><li>返回表的地址</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/6.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个新的线性表</span></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建</span></span><br><span class="line">    TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">        ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检验分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;capacity = capacity;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">        ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新建成功的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过数组下标的方式获取元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ret = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  <span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//3.获取元素</span></span><br><span class="line">        ret = List-&gt;node[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>把最后一个元素到插入位置的元素后移一个位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/3.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">char</span> node, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">    <span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">    ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">    ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ret )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">        &#123;</span><br><span class="line">            pos = List-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//4.将新元素插入</span></span><br><span class="line">        List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line">      <span class="comment">//5.线性表长度加1</span></span><br><span class="line">        List-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/4.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  <span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//3.将元素取出</span></span><br><span class="line">      ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//5.线性表长度减1</span></span><br><span class="line">      <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="3-代码具体实现"><a href="#3-代码具体实现" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><p><strong>SeqList.h</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_SEQLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_SEQLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用void做封装，使用void之后在main函数中不会产生误操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIST_SEQLIST_H</span></span></span><br></pre></td></tr></table></figure></div><p><strong>SeqList.c</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> TSeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    TSeqListNode * node;</span><br><span class="line">&#125;TSeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的线性表</span></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建</span></span><br><span class="line">    TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.分配内存</span></span><br><span class="line">        ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检验分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;capacity = capacity;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建完的链表的指针指向第一个节点的结尾处</span></span><br><span class="line">        ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新建成功的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在转换后线性表不为空的情况下，把长度设置为0</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的长度</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性表的长度</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的容量大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的容量大小</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.返回线性表的容量大小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向线性表的指定位置插入值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//2.检查列表不为空</span></span><br><span class="line">    <span class="keyword">int</span> ret = (slist != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检查线性表长度不大于容量。并且需要插入的值合理</span></span><br><span class="line">    ret = ret&amp;&amp;(slist-&gt;length+<span class="number">1</span> &lt;= slist-&gt;capacity);</span><br><span class="line">    ret = ret&amp;&amp;(<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在上述条件都合理的情况下进行操作</span></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果需要插入的位置大于等于线性表的长度，则把修改位置为线性表的最后</span></span><br><span class="line">        <span class="keyword">if</span>( pos &gt;= slist-&gt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = slist-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把需要插入位置后的节点都往后移一个单位</span></span><br><span class="line">        <span class="keyword">for</span> (i = slist-&gt;length; i &gt; pos ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i] = slist-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把节点插入需要的位置</span></span><br><span class="line">        slist-&gt;node[pos] = *((TSeqListNode*)node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线性表的长度加1</span></span><br><span class="line">        slist-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回操作结果(成功为1，失败为0)</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表中删除指定的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.去除删除元素</span></span><br><span class="line">    SeqListNode* ret = SeqList_Get(slist,pos);</span><br><span class="line">    <span class="comment">//因为上面是指针变量，所以删除后，ret指向的指针会改变，对于的值自然也会变，所以要及时转换成数值类型的变量</span></span><br><span class="line">    TSeqListNode date = *(TSeqListNode*)ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("在为SeqList_Delete函数中:%d\n",*(int*)ret);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.把删除后的元素全部向前移动一个单元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; slist-&gt;length ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i<span class="number">-1</span>] = slist-&gt;node[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slist-&gt;length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回删除的值</span></span><br><span class="line">    <span class="keyword">return</span> &amp;date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出线性表对应位置的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    SeqListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = (SeqListNode*)(&amp;slist-&gt;node[pos]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>main.c</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqList* <span class="built_in">list</span> = SeqList_Create(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;i, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;j, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;k, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;x, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;y, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;z, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;SeqList_Length(<span class="built_in">list</span>); index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)SeqList_Get(<span class="built_in">list</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SeqList_Length(<span class="built_in">list</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(<span class="keyword">int</span>*)SeqList_Delete(<span class="built_in">list</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    SeqList_Destroy(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>运行结果：</strong></p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/5.png" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="线性表" scheme="https://zybtree.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/</id>
    <published>2020-04-12T03:50:54.000Z</published>
    <updated>2020-06-02T06:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><blockquote><p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul></blockquote><p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p><blockquote><p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p></blockquote><p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p><blockquote><p>性质相同，是指数据元素具有相同数量和类型的数据项。</p></blockquote><p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/1.png" style="zoom:50%;"><h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote><p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/2.png" style="zoom:50%;"><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p><blockquote><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p></blockquote><p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/3.png" style="zoom:50%;"><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/4.png" style="zoom:40%;"><h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p></blockquote><p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><hr><br><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据结构绪论" scheme="https://zybtree.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅸ-C预处理器和C库/</id>
    <published>2020-04-10T03:25:38.000Z</published>
    <updated>2020-04-12T04:14:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅷ-位操作/</id>
    <published>2020-04-10T03:25:16.000Z</published>
    <updated>2020-04-10T04:09:24.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅶ-结构体和其他数据形式/</id>
    <published>2020-04-10T03:24:48.000Z</published>
    <updated>2020-04-10T04:09:17.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅵ 文件</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅵ-文件/</id>
    <published>2020-04-10T03:24:23.000Z</published>
    <updated>2020-04-10T04:09:09.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅴ 存储类,链接和内存管理</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅴ-存储类-链接和内存管理/</id>
    <published>2020-04-10T03:24:06.000Z</published>
    <updated>2020-04-21T12:40:24.694Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。</p></blockquote><h1 id="一-存储类别"><a href="#一-存储类别" class="headerlink" title="一.存储类别"></a>一.存储类别</h1><p><strong>硬件方面来看：</strong>被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<code>对象(object)</code>。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)。</p><p><strong>软件方面来看：</strong>程序需要一种方法访问对象。这可以通过声明变量来完成。</p><p>以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div><p>该声明创建了一个名为<code>entity</code>的<code>标识符(identifier)</code>。标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符<code>entity</code>即是软件(即C程序)指定<strong>硬件内存中的对象的方式</strong>。该声明还提供了<strong>储存在对象中的值</strong>。</p><p>但是变量名不是指定对象的唯一途径。以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>第1行声明中，<code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与 <code>entity</code>指定的对象相同。一般而言，那些指定对象的表达式被称为<em>左值<em>。所以，<code>entity</code>既是标识符也是左值；`</em>pt<code>既是表达式也是左值。按照这个思路，</code>ranks + 2 * entity<code>既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式</code></em>(ranks + 2 * entity)`是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅳ 字符串和字符串函数</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/</id>
    <published>2020-04-10T03:23:31.000Z</published>
    <updated>2020-04-19T09:54:42.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五-字符串函数"><a href="#五-字符串函数" class="headerlink" title="五.字符串函数"></a>五.字符串函数</h1><h2 id="1-strlen-函数"><a href="#1-strlen-函数" class="headerlink" title="1.strlen()函数"></a>1.strlen()函数</h2><p>strlen()函数用于统计字符串的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_fit.c -- try the string-shrinking function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* contains string function prototypes */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mesg[] = <span class="string">"Things should be as simple as possible,"</span></span><br><span class="line">    <span class="string">" but not simpler."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    fit(mesg,<span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Let's look at some more of the string."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg + <span class="number">39</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size)</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/1.png" style="zoom:50%;"><p><code>fit()</code>函数把第39个元素的逗号替换成<code>&#39;\0&#39;</code>字符。<code>puts()</code>函数在空字符处停止输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把这些字符打印了出来：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(mesg + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></div><p>表达式<code>mesg + 39</code>是<code>mesg[39]</code>的地址，该地址上储存的是空格字符。所以<code>put()</code>显示该字符并继续输出直至遇到原来字符串中的空字符.</p><p>演示过程如下图所示：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/2.png" style="zoom:50%;"><h2 id="2-strcat-和strncat-函数"><a href="#2-strcat-和strncat-函数" class="headerlink" title="2.strcat()和strncat()函数"></a>2.strcat()和strncat()函数</h2><p><code>strcat()</code>（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p><p><code>strcat()</code>函数的类型是<code>char *</code>（即，指向char的指针）。<code>strcat()</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p><p><code>strcat()</code>的用法:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* str_cat.c -- joins two strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  /* declares the strcat() function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/3.png" style="zoom:50%;"><p><code>strcat()</code>函数问题：</p><p><font color="red"><code>strcat()</code>函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。</font></p><p>解决方法：</p><ul><li>用<code>strlen()</code>查看第1个数组的长度。注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。</li></ul><ul><li>用<code>strncat()</code>，该函数的第3 个参数指定了最大添加字符数。</li></ul><p><code>strncat()</code>例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* join_chk.c -- joins two strings, check size first */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">    <span class="keyword">int</span> available;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    s_gets(flower, SIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(addon) + <span class="built_in">strlen</span>(flower) + <span class="number">1</span>) &lt;= SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">    <span class="built_in">puts</span>(flower);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite bug?"</span>);</span><br><span class="line">    s_gets(bug, BUGSIZE);</span><br><span class="line">    available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(bug, addon, available);</span><br><span class="line">    <span class="built_in">puts</span>(bug);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/4.png" style="zoom:50%;"><blockquote><p>strcat()和 gets()类似，也会导致缓冲区溢出。为什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？<strong>这也许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的。</strong>无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的使用安全。</p></blockquote><h2 id="三-strcmp-函数"><a href="#三-strcmp-函数" class="headerlink" title="三.strcmp()函数"></a>三.strcmp()函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅲ 数组与指针</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅲ-数组与指针/</id>
    <published>2020-04-10T03:23:09.000Z</published>
    <updated>2020-04-12T04:13:49.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
      <category term="指针" scheme="https://zybtree.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅱ 函数</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/</id>
    <published>2020-04-10T03:22:47.000Z</published>
    <updated>2020-04-10T09:02:02.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>什么是函数？</strong>函数（function）是完成特定任务的独立程序代码单元。</p><p><strong>为什么要使用函数？</strong>首先，使用函数可以省去编写重复代码，提高效率。其次，让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。如果不是自己编写函数，根本不用关心黑盒的内部行为；以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上</p></blockquote><p>以下面程序为例分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;            /* for strlen() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaces;</span><br><span class="line">    </span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);   <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    show_n_char(SPACE, <span class="number">12</span>);    <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line">    spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* Let the program calculate    */</span></span><br><span class="line">    <span class="comment">/* how many spaces to skip      */</span></span><br><span class="line">    show_n_char(SPACE, spaces);<span class="comment">/* use a variable as argument   */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line">    show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* an expression as argument    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* show_n_char() definition */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序在3处使用了<code>show_n_char()</code>标识符：<strong>函数原型(function prototype)</strong>告诉编译器函数<code>show_n_char()</code>的类型；<strong>函数调用(function call)</strong>表明在此处执行函数；<strong>函数定义(function definition)</strong>明确地指定了函数要做什么。</p><p><strong>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。</strong>因此，在main()函数定义的前面</p><h2 id="1-对于函数声明"><a href="#1-对于函数声明" class="headerlink" title="1.对于函数声明"></a>1.对于函数声明</h2><p>出现了下面的ANSI C风格的函数原型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></div><p>圆括号表明<code>show_n_char()</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。后面的<code>char</code>,<code>int</code>（在圆括号中）表明该函数带有两个参数，一个为<code>char</code>类型，一个为<code>int</code>类型。分号表明这是在声明函数，不是定义函数。<font color="red">函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。</font></p><blockquote><p>程序把 <code>show_n_char()</code>原型置于<code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p></blockquote><h2 id="2-对于函数参数"><a href="#2-对于函数参数" class="headerlink" title="2.对于函数参数"></a>2.对于函数参数</h2><p>还是以这个有ANSI C风格的函数头为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure></div><p>该行告知编译器<code>show_n_char()</code>使用两个参数ch和num，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数（formal argument，但是最近的标准推荐使用formal parameter）</strong>，简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。</p><blockquote><p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：void dibs(int x, y, z)　　　　 /* 无效的函数头 */</p></blockquote><p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，也可以省略变量名：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><p>在函数调用中，<strong>实际参数（actual argument，简称实参）</strong>提供了ch和num的值。考虑上例中第1次调用<code>show_n_char()</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_n_char(SPACE, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></div><p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，<font color="red">形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。</font></p><blockquote><p>1.注意 实际参数和形式参数：<strong>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</strong></p><p>2.<font color="red">为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</font></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div></blockquote><h2 id="3-关于return从函数中返回值"><a href="#3-关于return从函数中返回值" class="headerlink" title="3.关于return从函数中返回值"></a>3.关于return从函数中返回值</h2><p>函数的返回值可以把信息从被调函数传回主调函数。关键字<code>return</code>后面的表达式的值就是函数的返回值。</p><p>问题：如果函数返回值的类型与函数声明的类型不匹配会怎样？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">what_if</span><span class="params">(<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span>　z　=　<span class="number">100.0</span>　/　(<span class="keyword">double</span>)　n;</span><br><span class="line"><span class="keyword">return</span> z; <span class="comment">// 会发生什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = what_if(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div><p>虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。</p><h2 id="4-查找地址：-amp-运算符"><a href="#4-查找地址：-amp-运算符" class="headerlink" title="4.查找地址：&amp;运算符"></a>4.查找地址：&amp;运算符</h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。</p><p>下面例子中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* loccheck.c  -- checks to see where variables are stored  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;                      <span class="comment">/* declare function  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;             <span class="comment">/* local to main()   */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span>                   <span class="comment">/* define function   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">10</span>;                     <span class="comment">/* local to mikado() */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/3.png" style="zoom:50%;"><blockquote><p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值 2 传递给形式参数（mikado()中的bah）。<strong>注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。</strong></p></blockquote><h2 id="5-使用指针在函数间通信"><a href="#5-使用指针在函数间通信" class="headerlink" title="5.使用指针在函数间通信"></a>5.使用指针在函数间通信</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。</p><p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;　　 <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> * pc;　　　　<span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="keyword">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure></div><p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int * pi; 声明的意思是pi是一个指针,`</em>pi<code>是</code>int`类型 </p><p>pc指向的值（<em>pc）是char类型。pc本身是什么类型？我们描述它的类型是*</em>“指向char类型的指针<strong>。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，</strong>但是不能把两个指针相乘**。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。</p><p>下面例子就介绍了指针在函数间通信：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap2.c -- researching swap1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/4.png" style="zoom:50%;"><p>  该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把           地址作为它们的值。因此，应把它们声明为指针。</p><p>在<code>interchange(int *u, int *v)</code>函数中 <code>* u = x, * v = y</code>;即 <code>u = &amp;x, v = &amp;y</code>;</p><p><code>*u = *v</code>;——&gt;把 v 的地址赋值给 u; <code>*v = temp</code>;——&gt;把temp的地址赋值给v。</p><p><code>u</code>和 <code>v</code> 互换了地址。</p><p><strong>猜想：如果直接int * temp;是否也能改变值？</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u , *v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchangeo Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/6.png" style="zoom:50%;"><p>实践证明是不行的，因为定义指针temp后的交换与定义<code>int temp</code>,然后<code>interchange(int  u, int  v)</code>这样交换是一样的，都是同类型的交换。</p><p><strong>对于指针与地址的实验：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;n;</span><br><span class="line"><span class="keyword">int</span> temp = *p;</span><br><span class="line"><span class="keyword">int</span> *v;</span><br><span class="line">v = &amp;temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d,the loacl of n = %p\n"</span>,n,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d,the loacl of p = %p\n"</span>,*p,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"temp = %d,the loacl of temp = %p\n"</span>,temp,&amp;temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*v = %d,the loacl of v = %p\n"</span>,*v,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/7.png" style="zoom:50%;"><blockquote><p>为什么temp的地址与* v的地址不一样呢，因为temp是新定义的变量，编译时给temp新分配了一个地址。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅰ 字符</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅰ-字符/</id>
    <published>2020-04-10T03:22:17.000Z</published>
    <updated>2020-04-10T08:57:35.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-单字符I-O-getchar-和-putchar"><a href="#1-单字符I-O-getchar-和-putchar" class="headerlink" title="1.单字符I/O : getchar() 和 putchar()"></a>1.单字符I/O : getchar() 和 putchar()</h2><blockquote><p>getchar() 和 putchar ()每次只能输入和输出一个字符。</p></blockquote><p>ANSI C 将 <code>stdio.h</code> 头文件与getchar() 和 putchar()相关联，这就是为什么程序中将该文件包含在内的原因。而且，getchar() 和 putchar() 不是真正的函数，而是定义为预处理器宏。</p><h3 id="1-getchar-与-scanf-的区分与混用"><a href="#1-getchar-与-scanf-的区分与混用" class="headerlink" title="1.getchar() 与 scanf() 的区分与混用"></a>1.getchar() 与 scanf() 的区分与混用</h3><p>在缓冲输入时需要按下Enter键，这一动作还传输一个程序必须处理的换行符。而<code>getchar()</code> 读取每个字符，包括空格，制表符和换行符；但是 <code>scanf()</code> 在在<strong>读取数字</strong>时会跳过空格，制表符和换行符。举例说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">int</span> rows,cols;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols);</span><br><span class="line">display(ch,rows,cols);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row,col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line"><span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(cr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅰ-字符/1.png" style="zoom:50%;"><img src style="zoom:50%;"><blockquote><p>程序会在输入之后，没有做出其他输入响应之前就结束了，原因是紧跟在输入3之后的那个换行符。</p></blockquote><p><strong><code>scanf()</code>函数将该换行符留在输入队列中，与<code>scanf()</code>不同，<code>getchar()</code> 并不跳过换行符。</strong>所以在循环的下一周期，再有机会输入任何其他内容之前，这一换行符由<code>getchar()</code>读出，然后将其赋值为ch，而ch为换行符才是结束循环的条件。</p><p>改善程序：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">int</span> rows,cols;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols) != <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">display(ch,rows,cols);</span><br><span class="line">    <span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row,col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line"><span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(cr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅰ-字符/2.png" style="zoom:50%;"><blockquote><p>程序跳过了一个输入周期中输入的最后一个数字与下一行开始处输入的字符之间的所有换行符和空格。</p></blockquote><h3 id="2-输入流和数字"><a href="#2-输入流和数字" class="headerlink" title="2.输入流和数字"></a>2.输入流和数字</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is 28 12.4</span><br></pre></td></tr></table></figure></div><p>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。<font color="red">但是对 C程序而言，这是一个字节流。</font><strong>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等</strong>。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch); <span class="comment">// 处理错误的输入</span></span><br></pre></td></tr></table></figure></div><p>虽然输入流由字符组成，但是也可以设置<code>scanf()</code>函数把它们转换成数值。例如，考虑下面的输入：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure></div><p>如果在<code>scanf()</code>函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，“它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，<code>scanf()</code>同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，<code>scanf()</code>也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。<br><strong>简而言之，输入由字符组成，但是<code>scanf()</code>可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而<code>getchar()</code>和使用%c的<code>scanf()</code>接受所有的字符。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>gdb学习</title>
    <link href="https://zybtree.github.io/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zybtree.github.io/2020/03/26/gdb学习/</id>
    <published>2020-03-26T10:54:52.000Z</published>
    <updated>2020-04-10T00:23:57.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p><p>在终端输入以下命令安装 GDB：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install gdb</span><br></pre></td></tr></table></figure></div><h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2+3+...+%d= %d\n"</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gcc bugging.c -o bugging -g -m64</span><br></pre></td></tr></table></figure></div><p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p><p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install libc6-dev-i386</span><br></pre></td></tr></table></figure></div><p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> gdb bugging</span><br></pre></td></tr></table></figure></div><p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) run</span><br></pre></td></tr></table></figure></div><p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) quit</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/03/26/gdb学习/1.png" style="zoom:50%;"><h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p><blockquote><p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p></blockquote><p>部分 gdb 常用命令一览表：</p><table><thead><tr><th align="center">命令</th><th align="center">简写形式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">list</td><td align="center">l</td><td align="center">查看源码</td></tr><tr><td align="center">backtrace</td><td align="center">bt,where</td><td align="center">打印函数栈信息</td></tr><tr><td align="center">next</td><td align="center">n</td><td align="center">执行下一行</td></tr><tr><td align="center">step</td><td align="center">s</td><td align="center">一次执行一行，遇到函数会进入</td></tr><tr><td align="center">finish</td><td align="center"></td><td align="center">运行到函数结束</td></tr><tr><td align="center">continue</td><td align="center">c</td><td align="center">继续运行</td></tr><tr><td align="center">break</td><td align="center">b</td><td align="center">设置断点</td></tr><tr><td align="center">info breakpoints</td><td align="center"></td><td align="center">显示断点信息</td></tr><tr><td align="center">delete</td><td align="center">d</td><td align="center">删除断点</td></tr><tr><td align="center">print</td><td align="center">p</td><td align="center">打印表达式的值</td></tr><tr><td align="center">run</td><td align="center">r</td><td align="center">启动程序</td></tr><tr><td align="center">until</td><td align="center">u</td><td align="center">执行到指定行</td></tr><tr><td align="center">info</td><td align="center">i</td><td align="center">显示信息</td></tr><tr><td align="center">help</td><td align="center">h</td><td align="center">帮助信息</td></tr></tbody></table><p>查询用法：</p><blockquote><p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p></blockquote><p>执行 Shell 命令：</p><blockquote><p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> $ (gdb)!shell 命令</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>例如查看当前目录的文件：</p><img src="//zybtree.github.io/2020/03/26/gdb学习/2.png" style="zoom:50%;"></blockquote><h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p><ul><li>list 行号，显示某一行附近的代码：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/3.png" style="zoom:50%;"><ul><li>list 函数名，显示某个函数附近的代码：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/4.png" style="zoom:50%;"><ul><li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li></ul><h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p><ul><li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/5.png" style="zoom:50%;"><ul><li>break 文件名 : 行号，适用于有多个源文件的情况。</li></ul><ul><li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/6.png" style="zoom:50%;"><ul><li>break 文件名 : 函数名，适用于有多个源文件的情况。</li></ul><h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p><img src="//zybtree.github.io/2020/03/26/gdb学习/7.png" style="zoom:50%;"><p>其中每一项的信息：</p><blockquote><ul><li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li><li>Type 列代表断点类型，一般为 breakpoint</li><li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li><li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li><li>Address 列代表该断点处虚拟内存的地址</li><li>What 列代表该断点在源文件中的信息</li></ul></blockquote><h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p><ul><li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/8.png" style="zoom:50%;"><ul><li>delete，不带任何参数，默认删除所有断点：</li></ul><h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p><blockquote><p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p><p><em>enable</em> 命令用于启用断点。</p></blockquote><ul><li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/9.png" style="zoom:50%;"><ul><li><p>disable，不带任何参数，默认关闭所有断点。</p></li><li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p></li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/10.png" style="zoom:50%;"><ul><li>enable，不带任何参数，默认启用所有断点。</li></ul><p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p><h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p><ul><li>enable once Num，断点 hit 一次之后关闭该断点</li><li>enable delete Num，断点 hit 一次之后删除该断点</li></ul><img src="//zybtree.github.io/2020/03/26/gdb学习/11.png" style="zoom:50%;"><p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p><h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol><li><strong>打印变量</strong></li></ol><p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p><blockquote><ul><li><p><code>info locals</code></p><p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p></li><li><p><code>print 变量或表达式</code></p><p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p><p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p></li></ul></blockquote><ol><li><strong>启动程序</strong></li></ol><p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p><blockquote><ul><li><p><code>run</code></p><p>不带任何参数，启动待调试程序，不传递参数。</p></li><li><p><code>run 参数</code></p><p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p></li></ul></blockquote><ol><li><strong>单步命令</strong></li></ol><p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p><blockquote><ul><li><p><code>next</code></p><blockquote><p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p><p>next N，表示单步执行N次</p></blockquote></li><li><p><code>step</code></p><blockquote><p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p><p>step N，表示单步执行N次</p></blockquote></li><li><p><code>finish</code></p><p>执行程序到当前函数结束</p></li><li><p><code>continue</code></p><p>执行程序到下个断点</p></li><li><p><code>until</code></p><p>until N，执行程序到源代码的某一行</p></li></ul></blockquote><h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p><blockquote><ul><li><code>list</code></li><li><code>info breakpoints</code></li><li><code>break</code></li><li><code>delete</code></li><li><code>disable</code> 和 <code>enable</code></li><li><code>enable once</code> 和 <code>enable delete</code></li><li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li><li><code>info locals</code> 和 <code>print</code></li></ul></blockquote><p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
      <category term="gdb" scheme="https://zybtree.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习</title>
    <link href="https://zybtree.github.io/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zybtree.github.io/2020/03/15/Makefile学习/</id>
    <published>2020-03-15T02:09:41.000Z</published>
    <updated>2020-04-10T00:24:04.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
      <category term="Makefile" scheme="https://zybtree.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>算法研究生课程学习笔记</title>
    <link href="https://zybtree.github.io/2020/03/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zybtree.github.io/2020/03/14/算法学习/</id>
    <published>2020-03-14T02:30:21.000Z</published>
    <updated>2020-04-12T07:35:33.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-算法相关概念"><a href="#一-算法相关概念" class="headerlink" title="一.算法相关概念"></a>一.算法相关概念</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>算法(algorithm)是一个（由人或机器进行）关于某种运算规则的集合。是对特定问题求解步骤的一种描述，是指令的有限序列。</p><center><font color="red" size="6">输入——> {规则}——>输出</font></center><p><font color="red">确定性：</font>清晰，无歧义</p><p><font color="red">有限性：</font>指令执行次数、时间</p><p><strong>特点：</strong></p><ul><li>执行时，不能包含任何主观的决定；</li><li>不能有类似直觉/创造力等因素。</li></ul><p><strong>具有下列5个特性：</strong></p><ul><li>有穷性：算法有限步结束，指令有限时间完成</li><li>确定性：每条指令都是明确的、无二义的</li><li>可行性：每条指令都能够被执行</li><li>输入：有0个或多个输入量</li><li>输出：有1个或多个输出量</li></ul><h2 id="2-算法的衡量尺度"><a href="#2-算法的衡量尺度" class="headerlink" title="2.算法的衡量尺度"></a>2.算法的衡量尺度</h2><blockquote><p>最初，用所需计算时间来衡量算法的好坏,但是，不同的机器相互之间无法比较。所以需要独立于具体计算机的客观衡量标准。如：问题的规模，基本运算，算法的计算量函数。也可以通过时间复杂度(基本运算执行次数)和空间复杂度(需要的存储空间大小)。</p></blockquote><h3 id="1-问题的规模"><a href="#1-问题的规模" class="headerlink" title="1.问题的规模"></a>1.问题的规模</h3><ul><li><p>一个或多个整数，作为输入数据量的测度</p></li><li><p>数组的长度(数据项的个数)</p></li><li><p>矩阵的最大维数(阶数)</p></li></ul><h3 id="2-输入规模通常用n来表示"><a href="#2-输入规模通常用n来表示" class="headerlink" title="2.输入规模通常用n来表示"></a>2.输入规模通常用n来表示</h3><ul><li>也可有两个以上的参数，如图中的顶点数和边数 (图论中的问题)</li></ul><h3 id="3-基本运算"><a href="#3-基本运算" class="headerlink" title="3.基本运算"></a>3.基本运算</h3><blockquote><ul><li>解决给定问题时占支配地位的运算。</li><li>在一个表中寻找数据元素x</li><li>两个实矩阵的乘法</li><li>将一个数组进行排序</li></ul></blockquote><p>通常情况下，讨论一个算法的优劣时，我们只讨论基本运算的执行次数。因为他是占支配地位的，而其他的运算可以忽略不计。</p><h3 id="4-算法的计算量函数"><a href="#4-算法的计算量函数" class="headerlink" title="4.算法的计算量函数"></a>4.算法的计算量函数</h3><p>用输入规模的某个函数来表示算法的基本运算量，该函数称为算法的时间复杂性(度)，一般用T(n)或T(n,m)等表示。如：T(n) = 5n,  T(n) = 3n*logn,  T(n) = 4n3,  T(n) = 2n,  T(n,m) = 2(n+m).</p><p><strong>最坏情况时间复杂性</strong></p><p>规模为n的所有输入中，基本运算执行次数最多的时间复杂性。</p><blockquote><p>如：在一个顺序表中寻找数据元素x。顺序查找：最坏情况为O(n);  二分查找：最坏情况为O(logn)。</p></blockquote><p><strong>平均情况时间复杂性</strong></p><p>规模为n的所有输入的算法时间复杂度的平均值(一般均假设每种输入情况以等概率出现).</p><blockquote><p>如：在一个顺序表中寻找数据元素x。顺序查找：评价情况仍为O(n);  二分查找：平均情况仍为O(logn)。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="算法" scheme="https://zybtree.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
