<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYBO_o&#39;s Blogs</title>
  
  <subtitle>Follow Excellence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zybo_o.github.io/"/>
  <updated>2020-11-10T01:59:40.488Z</updated>
  <id>https://zybo_o.github.io/</id>
  
  <author>
    <name>ZYBO_o</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈工大学习—设备驱动与文件系统</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-10T01:56:13.000Z</published>
    <updated>2020-11-10T01:59:40.488Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="设备驱动与文件系统" scheme="https://ZYBO_o.github.io/tags/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—内存管理</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-10T01:55:59.000Z</published>
    <updated>2020-11-10T01:59:24.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://ZYBO_o.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—进程与线程</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-11-10T01:55:51.000Z</published>
    <updated>2020-11-10T01:59:05.352Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程与线程" scheme="https://ZYBO_o.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—操作系统基础</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-10T01:55:44.000Z</published>
    <updated>2020-11-10T02:27:09.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-从通用图灵机到计算机"><a href="#一-从通用图灵机到计算机" class="headerlink" title="一.从通用图灵机到计算机"></a>一.从通用图灵机到计算机</h1><p>1946年，冯诺依曼提出<strong><font color="red">存储程序思想</font></strong>。存储程序的主要思想是<strong>将程序和数据存放到计算机内部的存储器中，计算机在程序的控制下一步一步进行处理</strong>。</p><p>计算机由五大部件组成：输入设备、输出设备、存储器、运算器、控制器。</p><center class="half">     <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/1.png" style="zoom:50%;">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图1：简单的例子</div></center><p>基本流程：</p><ul><li>程序载入到存储器中</li><li>用指令指针IP来指向当前需要处理的指令</li><li>载入指令，形成控制逻辑，进行解释执行：把地址[100]的值赋给ax。</li><li>接着IP指向下一条指令</li></ul><p>总结就是四个字：<strong><font color="red">取址执行。</font></strong></p><h1 id="二-操作系统的开启流程"><a href="#二-操作系统的开启流程" class="headerlink" title="二.操作系统的开启流程"></a>二.操作系统的开启流程</h1><blockquote><p>从打开电源开始，这神秘的黑色背后发生着什么?</p><p>即打开电源后计算机要开始工作了计算机怎么工作<strong>?</strong> 这是最最基本， 也最最重要的常识。</p></blockquote><h2 id="1-最开始的执行"><a href="#1-最开始的执行" class="headerlink" title="1.最开始的执行"></a>1.最开始的执行</h2><p>以X86结构为例子：</p><p><strong>(1) x86 PC</strong>刚开机时<strong>CPU</strong>处于实模式</p><p><strong>(2)</strong>开机时，<strong>CS=0xFFFF; IP=0x0000</strong></p><blockquote><p>CS为段寄存器，IP为偏移</p><p>和保护模式对应，实模式的寻址<strong>CS:IP(CS</strong>左移<strong>4</strong>位<strong>+IP)</strong>， 和保护模式不一样<strong>!</strong></p><p>所以是先左移四位，然后加上IP，结果为0xFFFF0</p></blockquote><p><strong>(3)</strong>寻址<strong>0xFFFF0(ROM BIOS</strong>映射区<strong>)</strong>[Basic input output system] </p><blockquote><p> 这段程序固化在内存中 </p></blockquote><p><strong>(4)</strong> 检查<strong>RAM</strong>，键盘，显示器，软硬磁盘 </p><blockquote><p>先检查硬件设备</p></blockquote><p><strong>(5)</strong> 将磁盘<strong>0</strong>磁道<strong>0</strong>扇区读入<strong>0x7c00</strong>处</p><blockquote><p>读入一个扇区，即512字节，读到<strong>0x7c00</strong>处</p><p><strong>0</strong>磁道<strong>0</strong>扇区是操作系统中的<strong>引导扇区。</strong></p></blockquote><p><strong>(6)</strong> 设置<strong>cs=0x07c0</strong>，<strong>ip=0x0000</strong></p><h2 id="2-0x7c00处存放的代码"><a href="#2-0x7c00处存放的代码" class="headerlink" title="2. 0x7c00处存放的代码"></a>2. <strong>0x7c00</strong>处存放的代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOTSEG = 0x07c0</span><br><span class="line">INITSEG = 0x9000</span><br><span class="line">SETUPSEG = 0x9020</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.globl</span> begtext,begdata,begbss,endtext,enddata,endbss</span><br><span class="line"><span class="selector-class">.text</span> <span class="comment">//文本段</span></span><br><span class="line">begtext:</span><br><span class="line">.data //数据段</span><br><span class="line">begdata:</span><br><span class="line">.bss //未初始化数据段</span><br><span class="line">begbss:</span><br><span class="line">entry start //关键字entry告诉链接器“程序入口”</span><br><span class="line">start:</span><br><span class="line">mov ax, <span class="number">#B</span>OOTSEGmov ds, ax //ds = <span class="number">#B</span>OOTSEG[<span class="number">0</span>x07c0]</span><br><span class="line">  mov ax, #INITSEGmov es, ax //es = <span class="number">0</span>x9000</span><br><span class="line">  mov cx, <span class="number">#256</span></span><br><span class="line"></span><br><span class="line">  sub si, sisub di, di //形成段内偏移：si-si = <span class="number">0</span> , di-di = <span class="number">0</span></span><br><span class="line">//ds 和 es 是段寄存器，加上上面的段内偏移形成地址</span><br><span class="line">//ds 与 si 接成地址：左移四位加上<span class="number">0</span>为：<span class="number">0</span>x7c000</span><br><span class="line">//es 与 di 接成地址：左移四位加上<span class="number">0</span>为：<span class="number">0</span>x90000</span><br><span class="line"></span><br><span class="line">  rep   movw//重复移动<span class="number">256</span>个字,即<span class="number">512</span>个字节</span><br><span class="line">//将<span class="number">0</span>x07c0:<span class="number">0</span>x0000处的<span class="number">256</span>个字移动到<span class="number">0</span>x9000:<span class="number">0</span>x0000处，腾出空间来操作</span><br><span class="line"></span><br><span class="line">  jmpi  go, INITSEG//jmp直接跳转，jmpi间接跳转</span><br><span class="line">//go赋给ip,INITSEG赋给cs</span><br><span class="line">//此时INITSEG = <span class="number">90000</span>,go就是偏移的位置，距离为<span class="number">300</span></span><br><span class="line">//跳转到<span class="number">90300</span>,也就是下面的go:</span><br><span class="line"></span><br><span class="line">go: mov ax,cs //cs=<span class="number">0</span>x9000</span><br><span class="line">mov ds,ax mov es,ax mov ss,ax mov sp,<span class="number">#0</span>xff00</span><br><span class="line">load_setup: //载入setup模块</span><br><span class="line">mov dx,<span class="number">#0</span>x0000 mov cx,<span class="number">#0</span>x0002 mov bx,<span class="number">#0</span>x0200</span><br><span class="line">mov ax,<span class="number">#0</span>x0200+SETUPLEN int <span class="number">0</span>x13 //BIOS中断</span><br><span class="line">//<span class="number">0</span>x13是BIOS读磁盘扇区的中断:</span><br><span class="line">//ah=<span class="number">0</span>x02-读磁盘，al= 扇区数量(SETUPLEN=<span class="number">4</span>)， ch=柱面号，cl=开始扇区， dh=磁头号，dl=驱动器号， es:bx=内存地址</span><br><span class="line">//cl开始扇区，为cx的开始八位：<span class="number">02</span>，所以从第二个扇区开始读</span><br><span class="line">//al= 扇区数量(SETUPLEN=<span class="number">4</span>),读入扇区的个数，低八位，也就是<span class="number">4</span>个扇区</span><br><span class="line">jnc ok_load_setup</span><br><span class="line">mov dx,<span class="number">#0</span>x0000</span><br><span class="line">mov ax,<span class="number">#0</span>x0000 //复位</span><br><span class="line">int <span class="number">0</span>x13</span><br><span class="line">j load_setup //重读</span><br></pre></td></tr></table></figure></div><center class="half">     <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/2.png" style="zoom:50%;">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图2：启动盘读入的扇区</div></center><h2 id="3-读入setup模块之后的操作"><a href="#3-读入setup模块之后的操作" class="headerlink" title="3.读入setup模块之后的操作"></a>3.读入setup模块之后的操作</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Ok_load_setup: //载入setup模块</span><br><span class="line">mov dl,<span class="number">#0</span>x00  mov ax,<span class="number">#0</span>x0800//ah=<span class="number">8</span>获得磁盘参数</span><br><span class="line">int <span class="number">0</span>x13      mov ch,<span class="number">#0</span>x00    mov sectors,cx</span><br><span class="line">mov ah,<span class="number">#0</span>x03  xor bh,bh       int <span class="number">0</span>x10 //读光标</span><br><span class="line">mov cx,<span class="number">#24</span>    mov bx,<span class="number">#0</span>x0007</span><br><span class="line">//<span class="number">24</span>是需要输出的字符个数</span><br><span class="line"></span><br><span class="line">mov bp,#msg1mov ax,<span class="number">#1301</span>    int <span class="number">0</span>x10 //BIOS中断：显示字符</span><br><span class="line">//bp需要显示的字符所在的地址</span><br><span class="line"></span><br><span class="line">mov ax,#SYSSEG //SYSSEG=<span class="number">0</span>x1000</span><br><span class="line">mov es,ax</span><br><span class="line">call read_it //读入system模块</span><br><span class="line">jmpi <span class="number">0</span>,SETUPSEG</span><br><span class="line"></span><br><span class="line">//##############<span class="number">#b</span>ootsect.s中的数据//在文件末尾###############//</span><br><span class="line">sectors: .word <span class="number">0</span> //磁道扇区数</span><br><span class="line">msg1:.byte <span class="number">13</span>,<span class="number">10</span></span><br><span class="line">.ascii “Loading system...”</span><br><span class="line">.byte <span class="number">13</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></div><h2 id="4-读入read-it"><a href="#4-读入read-it" class="headerlink" title="4.读入read_it"></a>4.读入read_it</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_it调用13号中断，把操作系统后面的内容读入，读入之后bootset就结束了。</span></span><br><span class="line">read_it: mov ax,es cmp ax,<span class="number">#E</span>NDSEG jb ok1_read</span><br><span class="line">ret</span><br><span class="line">ok1_read:</span><br><span class="line">mov ax,sectors</span><br><span class="line">sub ax,sread //sread是当前磁道已读扇区数,ax未读扇区数</span><br><span class="line">call read_track //读磁道...</span><br></pre></td></tr></table></figure></div><p>bootsect操作内容就是读入操作系统然后打出开机logo。</p><p>bootset退出后，需要把控制权交给下一个程序——setup</p><p>交接控制权的方式就是跳转。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.org</span> 510</span><br><span class="line"><span class="selector-class">.word</span> 0xAA55 <span class="comment">//扇区的最后两个字节</span></span><br></pre></td></tr></table></figure></div><p>可以转入<strong>setup</strong>执行了，<strong>jmpi 0, SETUPSEG</strong></p><blockquote><p> ip = 0, cs = <strong>SETUPSEG</strong></p><p> 地址为cs左移四位加上ip，然后取值执行。</p><p> SETUPSEG = 9020，ip=0，所以地址为90200</p></blockquote><h2 id="5-setup模块"><a href="#5-setup模块" class="headerlink" title="5.setup模块"></a>5.setup模块</h2><blockquote><p>setup将完成OS启动前的设置</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">start: mov ax,#INITSEG mov ds,ax mov ah,<span class="number">#0</span>x03</span><br><span class="line">xor bh,bh int <span class="number">0</span>x10//取光标位置dx mov [<span class="number">0</span>],dx</span><br><span class="line"></span><br><span class="line">//<span class="number">15</span>号中断来获取内存的大小，获取的值在ax中，然后赋给<span class="number">2</span>的间接寻址，<span class="number">9000</span>+<span class="number">2</span>——&gt;<span class="number">9002</span>存扩展内存大小</span><br><span class="line">//知道内存大小后才能更好的管理内存 </span><br><span class="line">mov ah,<span class="number">#0</span>x88 int <span class="number">0</span>x15 mov [<span class="number">2</span>],ax ...</span><br><span class="line"></span><br><span class="line">cli ///不允许中断</span><br><span class="line">mov ax,<span class="number">#0</span>x0000 cld</span><br><span class="line">do_move: mov es,ax add ax,<span class="number">#0</span>x1000</span><br><span class="line">cmp ax,<span class="number">#0</span>x9000 jz end_move</span><br><span class="line">mov ds,ax sub di,di</span><br><span class="line">sub si,si</span><br><span class="line">mov cx,<span class="number">#0</span>x8000</span><br><span class="line">rep</span><br><span class="line">movsw</span><br><span class="line">jmp do_move</span><br></pre></td></tr></table></figure></div><p>将操作系统的代码移动到0地址处，然后应用程序的地址就一直处于操作系统往上的地址处。</p><h2 id="6-保护模式下的地址翻译与中断处理"><a href="#6-保护模式下的地址翻译与中断处理" class="headerlink" title="6.保护模式下的地址翻译与中断处理"></a>6.保护模式下的地址翻译与中断处理</h2><h3 id="1-保护模式下的地址翻译"><a href="#1-保护模式下的地址翻译" class="headerlink" title="(1).保护模式下的地址翻译"></a>(1).保护模式下的地址翻译</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/4.png" style="zoom:50%;"></p><p>cs是选择子，而不是之前的左移操作，用来作为查表索引，选择表中的表项产生基址，再和IP偏移，加上一起产生32位地址。而这个表就是gdt表。</p><h3 id="2-保护模式下中断处理函数入口"><a href="#2-保护模式下中断处理函数入口" class="headerlink" title="(2).保护模式下中断处理函数入口"></a>(2).保护模式下中断处理函数入口</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/5.png" style="zoom:50%;"></p><p>在保护模式下，中断也是通过寻找表项来进入中断函数的入口。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">end_move: mov ax,#SETUPSEG mov ds,ax</span><br><span class="line">lidt idt_48 lgdt gdt_48//设置保护模式下的中断和寻址</span><br><span class="line">idt_48:.word <span class="number">0</span> .word <span class="number">0</span>,<span class="number">0</span> //保护模式中断函数表</span><br><span class="line">gdt_48:.word <span class="number">0</span>x800 .word <span class="number">512</span>+gdt,<span class="number">0</span>x9</span><br><span class="line"></span><br><span class="line">//初始化gdt表</span><br><span class="line">gdt: .word <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">.word <span class="number">0</span>x07FF, <span class="number">0</span>x0000, <span class="number">0</span>x9A00, <span class="number">0</span>x00C0</span><br><span class="line">.word <span class="number">0</span>x07FF, <span class="number">0</span>x0000, <span class="number">0</span>x9200, <span class="number">0</span>x00C0</span><br><span class="line">//有了这个表再配合 lgdt gdt_48 这个指令就启动了三十二位模式。</span><br></pre></td></tr></table></figure></div><center class="half">     <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/3.png" style="zoom:40%;">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图3：cr0寄存器</div></center><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call empty_8042 mov al,<span class="selector-id">#0xD1</span> out <span class="selector-id">#0x64</span>,al<span class="comment">//8042是键盘控制器，其输出端口P2用来控制A20地址线</span></span><br><span class="line">call empty_8042 mov al,<span class="selector-id">#0xDF</span> out <span class="selector-id">#0x60</span>,al<span class="comment">//选通A20地址线 </span></span><br><span class="line">call empty_8042 <span class="comment">//初始化8259(中断控制) 一段非常机械化的程序</span></span><br><span class="line">mov ax,<span class="selector-id">#0x0001</span> mov cr0,ax</span><br><span class="line"><span class="comment">//把1赋给ax,然后把ax赋给cr0，进入保护模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个指令就不是之前的左移相加操作，而是32位操作。</span></span><br><span class="line">jmpi 0,8</span><br></pre></td></tr></table></figure></div><center class="half">     <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/6.png" style="zoom:40%;">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图5：gdt计算</div></center><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.word</span> 0x07FF, 0x0000, 0x9A00, 0x00C0</span><br></pre></td></tr></table></figure></div><p>从左往右分别放入段限长，段基址15，段基址23，段基址31，结果是0x0000，加上ip也等于0，所以加上为0地址,然后跳到0地址处去执行，也就是移动后的操作系统地址去执行。</p><p>而system中的第一个被执行的文件就是head.s。</p><h2 id="7-head-s"><a href="#7-head-s" class="headerlink" title="7.head.s"></a>7.head.s</h2><blockquote><p> <strong>setup</strong>是进入保护模式，<strong>head</strong>是进入之后的初始化</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入保护模式，就是32位汇编</span></span><br><span class="line">stratup_32: movl $<span class="number">0</span>x10,%eax mov %ax,%ds mov %ax,%es</span><br><span class="line">mov %as,%fs mov %as,%gs //指向gdt的<span class="number">0</span>x10项(数据段)</span><br><span class="line">lss _stack_start,%esp //设置栈(系统栈)</span><br><span class="line"></span><br><span class="line">call setup_idt//初试化idt表</span><br><span class="line">call setup_gdt//初始化gdt表</span><br><span class="line">xorl %eax,%eax</span><br><span class="line"><span class="number">1</span>:incl %eax</span><br><span class="line">movl %eax,<span class="number">0</span>x000000 cmpl %eax,<span class="number">0</span>x100000</span><br><span class="line">je <span class="number">1</span>b //<span class="number">0</span>地址处和<span class="number">1</span>M地址处相同(A20没开启)，就死循环 jmp after_page_tables //页表，什么东东?</span><br><span class="line">setup_idt: lea ignore_int,%edx</span><br><span class="line">  movl $<span class="number">0</span>x00080000,%eax  movw %dx,%ax</span><br><span class="line">lea _idt,%edi movl %eax,(%edi)</span><br></pre></td></tr></table></figure></div><h2 id="8-设置页表之后"><a href="#8-设置页表之后" class="headerlink" title="8.设置页表之后"></a>8.设置页表之后</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">pushl $<span class="number">0</span>  pushl $<span class="number">0</span>  pushl $<span class="number">0</span>   pushl <span class="variable">$L6</span> </span><br><span class="line">pushl $_main jmp set_paging</span><br><span class="line">L6: jmp L6</span><br><span class="line">setup_paging: 设置页表 ret</span><br></pre></td></tr></table></figure></div><p>流程：</p><ul><li><strong>setup_paging</strong>执行<strong>ret</strong>后<strong>?</strong> 会执行函数<strong>main()</strong></li><li>进入<strong>main()</strong>后的栈为<strong>0</strong>，<strong>0</strong>，<strong>0</strong>，<strong>L6</strong></li><li><strong>main()</strong>函数的三个参数是<strong>0</strong>，<strong>0</strong>，<strong>0</strong></li><li><strong>main()</strong>函数返回时进入<strong>L6</strong>，死循环</li><li>但是main()函数在操作系统开启后是永远执行下去，不会返回进入L6的，不然就会进入死循环——死机。</li></ul><h2 id="9-进入main函数"><a href="#9-进入main函数" class="headerlink" title="9.进入main函数"></a>9.进入main函数</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在init/main.c中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  mem_init();</span><br><span class="line">trap_init(); </span><br><span class="line">  blk_dev_init(); </span><br><span class="line">  chr_dev_init(); </span><br><span class="line">  tty_init(); </span><br><span class="line">  time_init(); </span><br><span class="line">  sched_init(); </span><br><span class="line">  buffer_init(); </span><br><span class="line">  hd_init(); </span><br><span class="line">  floppy_init(); </span><br><span class="line">  sti(); </span><br><span class="line">  move_to_user_mode(); </span><br><span class="line">  <span class="keyword">if</span>(!fork())&#123;init();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>main</strong>的工作就是<strong>xx_init:</strong> 内存、中断、设备、 时钟、<strong>CPU</strong>等内容的初始化<strong>…</strong></p><p>看一看<strong>mem_init…</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/mm/memory.c中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem,<span class="keyword">long</span> end_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;PAGING_PAGES; i++) </span><br><span class="line">    mem_map[i] = USED;</span><br><span class="line">i = MAP_NR(start_mem); </span><br><span class="line">  end_mem -= start_mem; </span><br><span class="line">  end_mem &gt;&gt;= <span class="number">12</span>; </span><br><span class="line">  <span class="keyword">while</span>(end_mem -- &gt; <span class="number">0</span>)</span><br><span class="line">mem_map[i++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>就是初始化了一个称为 <strong>mem_map</strong>的数组<strong>…</strong></p><p><strong>总结开机流程就是：</strong></p><ul><li><p><strong>bootsect读入操作系统</strong></p><ul><li><p>将操作系统从磁盘上读入内存</p></li><li><p>固化取值读入</p></li><li>把set up模块读入内存</li><li>打印出开机logo</li><li>调用13号中断，把操作系统后面的部分读入执行</li></ul></li><li><p><strong>进入setup模块</strong></p><ul><li>完成OS启动前的设置</li><li>进入保护模式，进行32位汇编</li></ul></li><li><strong>进入head.s汇编</strong><ul><li>传参进入main.c</li></ul></li><li><strong>进入main函数</strong><ul><li><strong>main</strong>的工作就是<strong>xx_init:</strong> 内存、中断、设备、 时钟、<strong>CPU</strong>等内容的初始化<strong>…</strong></li></ul></li></ul><h1 id="三-操作系统的接口"><a href="#三-操作系统的接口" class="headerlink" title="三.操作系统的接口"></a>三.操作系统的接口</h1><p>接口：连接上层应用与操作系统，完成信号转换和屏蔽细节的功能。</p><p>用户使用计算机的方式：命令行，图形按钮，应用程序。</p><h2 id="分析命令行"><a href="#分析命令行" class="headerlink" title="分析命令行"></a>分析命令行</h2><p>命令是什么：只是一段程序。</p><p>具体工作流程，以一个c语言文件编译运行为例。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(“ECHO:%s\n”, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后编译运行，以下就是一段shell程序：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc –o output output.c</span><br><span class="line"> ./output “hello”</span><br></pre></td></tr></table></figure></div><p>具体工作原理：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">//不断的等待用户敲入命令</span></span><br><span class="line">    <span class="built_in">scanf</span>(“%s”, cmd);<span class="comment">//敲入之后</span></span><br><span class="line"><span class="keyword">if</span>(!fork()) &#123;<span class="comment">//——&gt;进程管理的内容</span></span><br><span class="line">    exec(cmd);<span class="comment">//执行敲入的命令</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    wait();<span class="comment">//等待</span></span><br><span class="line">  &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>然后申请CPU，让CPU去执行<code>printf(“ECHO:%s\n”, argv[1]);</code>这一段代码，在终端中打印出最后的结果。</p><p><strong>所以可以看出，命令行就是程序，只是在程序执行的过程中增加了一些函数，通过这些函数来对计算机硬件进行使用。</strong></p><h2 id="分析图形按钮"><a href="#分析图形按钮" class="headerlink" title="分析图形按钮"></a>分析图形按钮</h2><p>图形按钮是基于<strong>消息处理机制。</strong></p><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/12.png" style="zoom:30%;"></p><ul><li>点击鼠标时，通过中断进入系统内部的消息队列</li><li>应用程序完成系统调用，进行GetMessage，从内核中把消息提取出来</li><li>根据拿出来的是什么消息，就执行对应的函数，来完成对应的功能</li><li>应用程序就是一个不断从消息队列中取消息的一个循环</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以上层应用使用硬件就是普通的c语言数加上一些关键性的重要函数。而这些<strong>重要的函数就是操作系统接口</strong>， <font color="red">接口表现为函数调用，又由系统􏰀供，所以称为系统调用。</font></p><h1 id="四-系统调用的实现"><a href="#四-系统调用的实现" class="headerlink" title="四.系统调用的实现"></a>四.系统调用的实现</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>为了保护用户隐私与操作系统的安全，把程序进行了隔离，分为内核程序与用户程序。进而又分了用户态/内核态，内核/用户段这些概念。</p><p>区分内核态和用户态是通过一种处理器“硬件设计”完成的。其中设计了内核寄存器和用户寄存器CS，DS。CPL用来描述当前的内存段的特权级 ，DPL用来描述目标内存段的特权级。其中，0是内存态，3是用户态。</p><p>当用户程序需要进入内核态执行时，硬件也提供了主动进入内核的方法。对于Intel x86，就是终端指令int。</p><p><strong>系统调用的核心：</strong></p><ul><li>用户程序中包含一段包含<strong>int</strong>指令的代码</li><li>操作系统写中断处理，获取想调程序的编号</li><li>操作系统根据编号执行相应代码</li></ul><h2 id="2-系统调用的实现"><a href="#2-系统调用的实现" class="headerlink" title="2.系统调用的实现"></a>2.系统调用的实现</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/7.png" style="zoom:30%;"></p><p><strong>以<code>printf</code>为例讲解系统调用的实现：</strong></p><ul><li><p>首先应用程序中的<code>printf</code>先调用库函数中的<code>printf</code> </p></li><li><p>然后库函数中的<code>printf</code>调用<code>wirte</code></p><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/8.png" style="zoom:30%;"></p></li><li><p>然后变成一段包含<code>int 0x80</code>的中断代码</p><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/9.png" style="zoom:30%;"></p></li><li><p>然后中断代码通过系统调用进入 操作系统</p></li></ul><h2 id="3-Linux系统调用的实现细节"><a href="#3-Linux系统调用的实现细节" class="headerlink" title="3.Linux系统调用的实现细节"></a>3.Linux系统调用的实现细节</h2><p>对于上面的库函数<code>write</code>函数而言，它的实现方式是通过宏来展开成汇编代码。所以系统调用的细节就可以从宏开始说起。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/include/unistd.h中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3的含义是具有3个参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//展开内容为int write(int fd, const char *buf, off_t count)</span></span><br><span class="line"><span class="function">type <span class="title">name</span><span class="params">(atype a, btype b, ctype c)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> __res;</span><br><span class="line">  <span class="comment">//汇编指令，核心代码只有一句：“int 0x80”</span></span><br><span class="line">  <span class="comment">//其中：  ”=a”(__res)为输出  “”(__NR_##name)为输入 ，即把_NR_write赋给eax</span></span><br><span class="line">__asm__ volatile(“int 0x80”:”=a”(__res):””(__NR_##name), ”b”((long)(a)),”c”((long)(b)),“d”((long)(c)))); </span><br><span class="line">  <span class="keyword">if</span>(__res&gt;=<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> (type)__res; </span><br><span class="line">  errno=-__res; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure></div><p>显然，<strong>__NR_write</strong>是系统调用号，放在<strong>eax</strong>中</p><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/10.png" style="zoom:30%;"></p><p>通过<strong>eax</strong>的值来说明进行中断调用<code>int 0x80</code>的原因。</p><h3 id="int-0x80中断的处理"><a href="#int-0x80中断的处理" class="headerlink" title="int 0x80中断的处理"></a><strong>int 0x80</strong>中断的处理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//设置中断处理门——每一个表项，初始化gdt表，之后遇到0x80中断，就从表中取出相应的中断处理函数。</span></span><br><span class="line">  set_system_gate(<span class="number">0x80</span>, &amp;system_call);</span><br><span class="line">  <span class="comment">//system_call为中断处理函数的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/include/asm/system.h中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//n：中断号,addr：中断地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n, addr) _set_gate(&amp;idt[n],15,3,addr); <span class="comment">//idt是全局变量，中断向量表基址 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的三赋给dpl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr, type, dpl, addr) __asm__(“movw %%dx,%%ax\n\t” “movw %0,%%dx\n\t”\ “movl %%eax,%1\n\t” “movl %%edx,%2”:\ :”i”((short)(0x8000+(dpl&lt;&lt;13)+type&lt;&lt;8))),“o”(*(( \ char*)(gate_addr))),”o”(*(4+(char*)(gate_addr))),\ “d”((char*)(addr),”a”(0x00080000))</span></span><br></pre></td></tr></table></figure></div><p>通过int 0x80中断将80号中断的dpl设置为3，让cpl等于3的程序能进入内核，然后通过int 0x80中断设置cpl成0，这样才能进行内核处理。</p><h3 id="中断处理程序：system-call"><a href="#中断处理程序：system-call" class="headerlink" title="中断处理程序：system_call"></a>中断处理程序：system_call</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nr_system_calls=72</span><br><span class="line"><span class="selector-class">.globl</span> _system_call</span><br><span class="line">_system_call: cmpl <span class="variable">$nr_system_calls-1</span>,%eax</span><br><span class="line">ja bad_sys_call</span><br><span class="line">push %ds push %es push %fs</span><br><span class="line">pushl %edx pushl %ecx pushl %ebx //调用的参数</span><br><span class="line">movl $<span class="number">0</span>x10,%edx mov %dx,%ds mov %dx,%es //内核数据 </span><br><span class="line">movl $<span class="number">0</span>x17,%edx mov %dx,%fs //fs可以找到用户数据 </span><br><span class="line">call _sys_call_table(,%eax,<span class="number">4</span>) //a(,%eax,<span class="number">4</span>)=a+<span class="number">4</span>*eax </span><br><span class="line">pushl %eax //返回值压栈，留着ret_from_sys_call时用</span><br><span class="line">... //其他代码</span><br><span class="line">ret_from_sys_call: popl %eax, 其他pop, iret</span><br></pre></td></tr></table></figure></div><h3 id="sys-call-table"><a href="#sys-call-table" class="headerlink" title="_sys_call_table"></a>_sys_call_table</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在include/linux/sys.h中</span></span><br><span class="line">fn_ptr sys_call_table[] = &#123;sys_setup, sys_exit, sys_fork, sys_read, sys_write,...&#125;;</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在include&#x2F;linux&#x2F;sched.h中</span><br><span class="line">typedef int(fn_ptr*) ();</span><br></pre></td></tr></table></figure></div><p><strong>整个过程：</strong></p><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/11.png" style="zoom:50%;"></p><ul><li>用户调用printf函数，首先通过库函数变成一段int 0x80代码</li><li>调用int 0x80代码时，cpl和dpl都是3，这样才能从用户态转变为内核态</li><li>int 0x80代码在初始化时做成了system_cal</li><li>进入中断处理之后cpl变成0</li><li>system_cal调用system_cal_table进行查表</li><li>根据传入的系统调用号_NR_write，即ax值</li><li>根据ax的值与system_call_table表确定调用内容</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统基础" scheme="https://ZYBO_o.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-I/O和文件</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-I-O%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-I-O%E5%92%8C%E6%96%87%E4%BB%B6/</id>
    <published>2020-11-10T01:54:56.000Z</published>
    <updated>2020-11-10T01:58:18.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O和文件" scheme="https://ZYBO_o.github.io/tags/I-O%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-调度</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%B0%83%E5%BA%A6/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%B0%83%E5%BA%A6/</id>
    <published>2020-11-10T01:54:40.000Z</published>
    <updated>2020-11-10T01:57:16.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="调度" scheme="https://ZYBO_o.github.io/tags/%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-内存</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E5%86%85%E5%AD%98/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E5%86%85%E5%AD%98/</id>
    <published>2020-11-10T01:54:30.000Z</published>
    <updated>2020-11-10T01:57:58.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存" scheme="https://ZYBO_o.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-进程</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-11-10T01:54:25.000Z</published>
    <updated>2020-11-10T02:07:56.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-进程描述和控制"><a href="#一-进程描述和控制" class="headerlink" title="一.进程描述和控制"></a>一.进程描述和控制</h1><h2 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="(一).什么是进程"></a>(一).什么是进程</h2><ul><li><strong>1.为什么操作系统需要提出进程的概念</strong><ul><li>有了应用程序，系统软件和资源的概念，就可以讨论操作系统怎样以一个有序的方式管理程序的执行，而执行中的程序就是进程。所以提出进程的概念来更好的管理。</li></ul></li></ul><p><br></p><ul><li><strong>2.什么是进程(概念)</strong><ul><li>一组指令序列的执行+ 一个当前状态+相关的系统资源集</li><li>进程由 程序代码+相关数据+进程控制块 组成</li></ul></li></ul><p><br></p><ul><li><strong>3.进程的表征元素有哪些</strong><ul><li>标识符</li><li>状态</li><li>优先级</li><li>程序计数器：下一条即将被执行的指令的地址</li><li>内存指针</li><li>I/O状态信息</li><li>记账信息：处理器时间的总和, 使用的时钟数总和,时间限制,记账号</li></ul></li></ul><p><br></p><ul><li><strong>4.什么是进程控制块</strong><ul><li>包含上述表征元素的数据结构，该控制块由操作系统创建和管理。</li></ul></li></ul><p><br></p><h2 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2.进程状态"></a>2.进程状态</h2><ul><li><p><strong>1.为什么需要提出进程状态模型，以及进程状态模型发展历程</strong></p><ul><li><p>操作系统的基本职责是控制进程的执行，这包括交替执行的方式和给进程分配资源。而在设计控制进程的程序时吗，第一步就是描述进程所展现出的行为。<strong>所以就是为了更高的管理进程。</strong></p></li><li><p><strong>两状态进程模型</strong></p><ul><li><strong>进程的创建：</strong>1.操作系统建立用于管理该进程的数据结构。2.在内存中给它分配地址空间。通常有4个事件(新的批处理作业，交互登录，给操作系统提供一项服务，现有进程派生)导致创建一个进程。</li><li><strong>进程终止：</strong>批作业中应该包含一个<strong><code>Halt</code>指令</strong>(产生中断警告操作系统进程已完成) 或 <strong>用于终止操作系统显式服务调用来终止</strong>。导致进程终止的原因很多。</li><li><strong>局限性：</strong>存在这一些处于非运行状态但已经就绪等待执行的进程，而同时存在一些处于阻塞状态等待I/O操作结束的进程。所以对于使用单个排队队列，调度器不能只考虑队列中最老的进程，需要扫描整个列表，查找那些未被阻塞且在队列中时间最长的进程。</li><li><strong>解决方法：</strong> 五状态进程</li></ul></li><li><p><strong>五状态进程模型</strong></p><ul><li>将两状态模型中的未运行态分成：就绪和阻塞这两个状态。增加 新建态 和 退出态。</li><li>操作系统分两步定义新建态：<ul><li>OS执行一些必须的辅助工作，将标识符关联到进程，分配和创建管理进程所需要的所有表，这些信息存在内存中。</li><li>进程本身还未进入内存，即即将需要执行的代码还不在内存，也没有给这个程序相关的数据分配空间，通常在外存磁盘中。</li></ul></li><li>进程退出系统也分为两步：<ul><li>进程终止，切换为退出态，与作业相关的表与其他信息保存在内存中。</li><li>一旦其他实用程序提取了内存中关于这个进程的信息，操作系统就不再保存，该进程将从系统中删除。</li></ul></li><li><strong>局限性：</strong>处理器处理速度比I/O要快得多，以至于内存中所有进程都在等待I/O的情况很常见，因此即使是多道程序设计，大多数时候处理器仍可能处于空闲状态。</li><li><strong>解决方案：</strong>把内存中某个进程的一部分或者全部移到磁盘中。当内存中没有处于就绪态的进程时，操作系统就把被阻塞的进程换出到磁盘中的“挂起队列”，然后取出挂起队列中的另一个进程或者接受一个新进程的请求，将其纳入内存运行。</li></ul></li><li><p><strong>引入挂起状态的进程模型</strong></p></li></ul></li></ul><p><br></p><ul><li><strong>2.描述进程各个状态</strong><ul><li>创建</li><li>终止</li><li>就绪</li><li>阻塞</li><li>运行</li><li>挂起(就绪/挂起，阻塞挂起)</li></ul></li></ul><p><br></p><h2 id="5-操作系统的执行"><a href="#5-操作系统的执行" class="headerlink" title="5.操作系统的执行"></a>5.操作系统的执行</h2><ul><li><strong>1.操作系统是一个进程吗？如果是，如何控制它？</strong> <ul><li><strong>无进程的内核</strong><ul><li>在所有进程之外执行操作系统内核。操作系统代码是作为一个在特权模式下工作的独立实体被执行。</li></ul></li><li><strong>在用户进程中执行</strong><ul><li>在用户程序的上下文中执行所有操作系统软件。在任何时刻，操作系统管理着进程映像，每个进程映像不仅包括用户进程控制块的内容，还包括内核程序的程序，数据和栈区域。</li></ul></li><li><strong>基于进程的操作系统</strong><ul><li>把操作系统作为一组系统进程来实现。</li></ul></li></ul></li></ul><hr><h1 id="二-线程，对称多处理和微内核"><a href="#二-线程，对称多处理和微内核" class="headerlink" title="二.线程，对称多处理和微内核"></a>二.线程，对称多处理和微内核</h1><h2 id="一-进程和线程"><a href="#一-进程和线程" class="headerlink" title="(一).进程和线程"></a>(一).进程和线程</h2><ul><li><strong>1.线程有哪些功能特性？</strong><ul><li><strong>线程状态</strong><ul><li>无挂起态。</li></ul></li><li><strong>线程同步</strong><ul><li>一个进程中的所有线程共享同一个地址空间和资源。所以一个线程对资源的任意修改都会影响同一个进程中其他线程的环境。所以需要同步各种线程中的活动，以便它们互不干涉且不破坏数据结构。</li></ul></li></ul></li></ul><p><br></p><ul><li><strong>2.用户级线程和内核级线程的描述</strong><ul><li><strong>用户级线程：</strong><ul><li>在一个纯粹的用户线程软件中，有关线程管理的所有工作都是由应用程序完成的，内核意识不到线程的存在。任何程序都可以通过使用线程库[用于用户级线程管理的一个例程包]被设计成多线程程序。</li><li><strong>使用用户级线程而不是内核级线程的优点：</strong><ul><li>线程切换不需要内核态特权，因此进程不需要为了线程管理而切换到内核态吗，节约了状态转换的开销。</li><li>调度可以是应用程序相关的，可以做到为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序。</li><li>用户级线程可以在任何操作系统执行，不需要为对底层内核进行修改以支持用户级线程。</li></ul></li><li><strong>用户级线程对于内核级线程的缺点：</strong><ul><li>当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中所有线程都会被阻塞。</li><li>在纯粹的用户级线程策略中，一个多线程应用程序不能利用多处理技术。因为内核一次只把一个进程分配给处理器，因此一个进程中只有一个线程可以执行。</li></ul></li></ul></li><li><strong>内核级线程：</strong><ul><li>在一个纯粹的内核级线程软件中，有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口(API)。</li><li><strong>内核线程的优点：</strong><ul><li>内核可以同时把同一个进程中的多个线程调度到多个处理器中。</li><li>如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程。</li><li>内核例程自身也是可以使用多线程的。</li></ul></li><li><strong>内核线程的缺点：</strong><ul><li>在把控制从一个线程传送到同一个进程中的另一个线程时，需要到内核的状态切换。</li></ul></li></ul></li><li><strong>可以按照特定的应用程序需求来组合用户级线程和内核级线程。</strong></li></ul></li></ul><p><br></p><h2 id="二-对称多处理"><a href="#二-对称多处理" class="headerlink" title="(二).对称多处理"></a>(二).对称多处理</h2><ul><li><strong>1.最基本的对于并行处理器系统的分类</strong><ul><li><strong>单指令单数据流</strong></li><li><strong>单指令多数据流</strong></li><li><strong>多指令单数据流</strong></li><li><strong>多指令多数据流</strong><ul><li>每个处理器都有自己的专用内存——<strong>集群</strong></li><li>处理器共用一个内存，通过该内存相互通信——<strong>共享内存多处理器</strong><ul><li><strong>主/从</strong><ul><li>内核只在指定的处理器上执行，其他处理用户程序。缺点明确：1.主处理器失效会导致整个系统失效。2.主处理器会成为性能瓶颈</li></ul></li><li><strong>对称多处理系统</strong><ul><li>内核可以在任何处理器上执行，并且通常是每个处理器从可用的进程或线程池中进行资金的调度工作。å</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://ZYBO_o.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-操作系统概述</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-10T01:53:41.000Z</published>
    <updated>2020-11-10T02:27:28.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统概述" scheme="https://ZYBO_o.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅷ排序</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T03:54:09.000Z</published>
    <updated>2020-09-22T12:10:53.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="排序" scheme="https://ZYBO_o.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅶ查找</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-12T03:53:45.000Z</published>
    <updated>2020-04-12T04:08:16.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="查找" scheme="https://ZYBO_o.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅵ图</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</id>
    <published>2020-04-12T03:53:24.000Z</published>
    <updated>2020-04-12T04:07:58.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="图" scheme="https://ZYBO_o.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅴ树</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</id>
    <published>2020-04-12T03:53:15.000Z</published>
    <updated>2020-10-26T12:53:23.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h2><h3 id="1-需要掌握的定义："><a href="#1-需要掌握的定义：" class="headerlink" title="1.需要掌握的定义："></a>1.需要掌握的定义：</h3><ul><li>结点(根结点，双亲结点，子节点，兄弟结点)</li><li>子树和空树</li><li>结点的深度和高</li><li>有序树和无序树</li><li>森林</li><li>树的表示方法</li></ul><blockquote><p>对于结点ni，ni的深度是指<strong>从根到ni</strong>的唯一路径的长；ni的高是指<strong>从ni到一片树叶</strong>的最长路径的长。</p></blockquote><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/1.png" style="zoom:25%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图1：线性结构与树结构对比</div></center><p><br></p><h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二.二叉树"></a>二.二叉树</h2><h3 id="1-二叉树需要掌握的概念"><a href="#1-二叉树需要掌握的概念" class="headerlink" title="1.二叉树需要掌握的概念"></a>1.二叉树需要掌握的概念</h3><h4 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="(1).二叉树的定义"></a>(1).二叉树的定义</h4><ul><li>有序树</li><li>节点的度只能为0，1，2</li></ul><h4 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="(2).二叉树的性质"></a>(2).二叉树的性质</h4><ul><li>第$i$层最多有 $2^{i-1}$ 个结点。</li><li>若深度为$K$，则最多有$2^K-1$个结点。</li><li>终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$=$n_2$+1。</li></ul><blockquote><p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点(设为$n_1$)，那么总结点$n=n_0+n_1+n_2$。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数$n=B+1$。而分枝数是可以通过$n_1$和$n_2$表示的，即$B$=$n_1$+2<em>$n_2$。所以，n用另外一种方式表示为n=$n_1$+2</em>$n_2$+1。两种方式得到的n值组成一个方程组，就可以得出$n_0$=$n_2$+1。</p></blockquote><h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="(3).满二叉树"></a>(3).满二叉树</h4><ul><li><p>概念定义</p><ul><li>除了叶子结点外其余结点的度都为2，则为满二叉树。</li></ul></li><li><p>性质</p><ul><li>满二叉树中第i层的节点数为$2^n-1$个。</li><li>深度为k的满二叉树必有$2^k-1$个节点，叶子数为$2^k-1$。</li><li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有n个节点的满二叉树的深度为 $log_2(n+1)$。</li></ul></li></ul><h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="(4).完全二叉树"></a>(4).完全二叉树</h4><ul><li>概念定义<ul><li>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，且<font color="red"><strong>最后一层的结点依次从左到右分布</strong></font>，则此二叉树被称为完全二叉树。</li></ul></li></ul><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/2.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图2：完全二叉树与非完全二叉树</div></center><ul><li>性质<ul><li>n 个结点的完全二叉树的深度为$⌊log_2n⌋+1$。</li><li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号,对于任意一个结点 i,完全二叉树还有以下几个结论成立:<ul><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果2*i&gt;n(总结点的个数)，则结点i肯定没有左孩子(为叶子结点)；否则其左孩子是结点2*i 。</li><li>如果2*i+1&gt;n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1。</li></ul></li></ul></li></ul><p><br></p><h3 id="2-二叉树的存储结构"><a href="#2-二叉树的存储结构" class="headerlink" title="2.二叉树的存储结构"></a>2.二叉树的存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="(1).顺序存储结构"></a>(1).顺序存储结构</h4><p>二叉树的顺序存储，指的是使用顺序表(数组)存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，<font color="red">如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树，然后从根节点开始，按照层次依次将树中节点存储到数组即可。</font></p><p>如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/3.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图3：普通二叉树的转换</div></center><p> <br></p><p>普通二叉树的数组存储状态如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/4.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图4：普通二叉树的存储状态</div></center><p><br></p><h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="(2).链式存储结构"></a>(2).链式存储结构</h4><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/5.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图5：普通二叉树示意图</div></center><p>如图5所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图5对应的链式存储结构如图6所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/6.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图6：二叉树链式存储结构示意图</div></center><p>由图可知采用链式存储二叉树时，其节点结构由 3 部分构成：</p><ul><li>指向左孩子节点的指针（Left）；</li><li>节点存储的数据（Element）；</li><li>指向右孩子节点的指针（Right）；</li></ul><p>表示该节点结构的 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><br></p><h3 id="3-二叉树遍历介绍"><a href="#3-二叉树遍历介绍" class="headerlink" title="3.二叉树遍历介绍"></a>3.二叉树遍历介绍</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="(1).层序遍历"></a>(1).层序遍历</h4><p>通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/7.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图7：层次遍历二叉树示意图</div></center><h4 id="2-普通遍历"><a href="#2-普通遍历" class="headerlink" title="(2).普通遍历"></a>(2).普通遍历</h4><p>按照 “从上到下，从左到右” 的顺序遍历整棵二叉树，此种方式称为普通遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/8.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图8：普通遍历二叉树示意图</div></center><p>在层次遍历中，整个遍历过程只经过各个节点一次，因此在层次遍历过程，每经过一个节点，都必须立刻访问该节点，否则错失良机，后续无法再对其访问。</p><p>而普通遍历方式则不同，通过观察图 7 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 7 中的节点 2 为例，如图 8 所示，它被经过了 3 次。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/9.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图9：遍历节点2的过程示意图</div></center><p>因此，在编程实现时可以设定真正访问各个节点的时机，换句话说，既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。这也就引出了以下 3 种遍历二叉树的算法：</p><ol><li><strong><font color="red">先序遍历</font>：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 9 中的 ①）；</strong></li><li><strong><font color="red">中序遍历</font>：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 9 中的 ②）；</strong></li><li><strong><font color="red">后序遍历</font>：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 9 中的 ③）；</strong></li></ol><h2 id="三-遍历二叉树代码实现"><a href="#三-遍历二叉树代码实现" class="headerlink" title="三.遍历二叉树代码实现"></a>三.遍历二叉树代码实现</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>二叉树先序遍历的实现思想是：</p><ol><li>访问根节点；</li><li>访问当前节点的左子树；</li><li>若当前节点无左子树，则访问当前节点的右子树；</li></ol><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/10.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图10：二叉树</div></center><p>因此，图 10 中二叉树采用先序遍历得到的序列为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></div><h4 id="1-递归先序遍历"><a href="#1-递归先序遍历" class="headerlink" title="(1).递归先序遍历"></a>(1).递归先序遍历</h4><p>前序的规则就是<code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>.在调用递归前进行节点操作。对于先序，就是先访问(输出)该节点。而递归左，递归右侧，会优先递归左侧。<code>直到没有左节点</code>。才会停止。访问次序大致为：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/11.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图11：递归先序遍历过程</div></center><h4 id="2-非递归优先遍历"><a href="#2-非递归优先遍历" class="headerlink" title="(2).非递归优先遍历"></a>(2).非递归优先遍历</h4><p>非递归的先序利用栈的性质替代递归，因为<code>递归有时候在效率</code>方面不是令人满意的。<br>因为栈的顺序为后进先出。递归是左递归，右递归。<strong>所以利用栈要相反。</strong>利用递归的思路，需要先把右节点进栈，再遍历(输出)左节点。然后循环一直到最后，达到和递归顺序相仿效果。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/12.jpg" style="zoom:70%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图12：非递归先序遍历过程</div></center><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h4><p><strong>递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionPreOrderTraverse</span><span class="params">( Tree T )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DisplayElement( T );<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Left );<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Right );<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>非递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span> = CreateStack( <span class="number">20</span> );<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    Tree p;<span class="comment">//临时指针</span></span><br><span class="line">    Push( T ,<span class="built_in">stack</span> );<span class="comment">//根结点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">stack</span>-&gt;TopOfStack != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Top( <span class="built_in">stack</span> );<span class="comment">//取栈顶元素</span></span><br><span class="line">        Pop( <span class="built_in">stack</span> );<span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            DisplayElement( p );<span class="comment">//调用结点的操作函数</span></span><br><span class="line">            <span class="comment">//如果该结点有右孩子，右孩子进栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;Right) &#123;</span><br><span class="line">                Push(  p-&gt;Right ,<span class="built_in">stack</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;Left;<span class="comment">//一直指向根结点最后一个左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><h2 id="四-二叉树查找树"><a href="#四-二叉树查找树" class="headerlink" title="四.二叉树查找树"></a>四.二叉树查找树</h2><h2 id="五-平衡树-AVL"><a href="#五-平衡树-AVL" class="headerlink" title="五.平衡树(AVL)"></a>五.平衡树(AVL)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>AVL树本质上是<strong>一棵二叉查找树</strong>，但是它又具有以下特点：<strong><font color="red">它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font></strong>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树。</p><p>平衡二叉树和非平衡二叉树对比的例图：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/13.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图13：左边为一般二叉树，右边为二叉查找树</div></center><p><strong>平衡因子(bf)：</strong>结点的左子树的深度减去右子树的深度，那么显然-1&lt;=bf&lt;=1;</p><h3 id="2-AVL的作用"><a href="#2-AVL的作用" class="headerlink" title="2.AVL的作用"></a>2.AVL的作用</h3><p>对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度 $ O(log_2n)$ 同时也由此而决定。<strong>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 $O(n)$  </strong>。</p><p>所以可以通过随机化建立二叉搜索树来尽量的避免这种情况，<strong><font color="red">但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</font></strong></p><p>例如：按顺序将一组数据1,2,3,4,5,6分别插入到一棵空二叉查找树和AVL树中，插入的结果如下图：</p><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/14.png" style="zoom:30%"><br>  <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/15.png" style="zoom:40%"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图14：左边为二叉搜索树，右边为二叉平衡树</div></center></p><p>由上图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<strong>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是 $O(N)$ ，而AVL树就不会出现这种情况，树的高度始终是 $O(lgN)$ .高度越小，对树的一些基本操作的时间复杂度就会越小。这也就是引入AVL树的原因。</strong></p><h3 id="3-AVL的操作"><a href="#3-AVL的操作" class="headerlink" title="3.AVL的操作"></a>3.AVL的操作</h3><p>AVL树的操作基本和二叉查找树一样，这里关注的是两个变化很大的操作：<strong>插入</strong>和<strong>删除！</strong></p><p>AVL树不仅是一颗二叉查找树，它还有其他的性质。<strong>如果按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以要做一些特殊的处理，包括：单旋转和双旋转！</strong></p><h4 id="1-单选转"><a href="#1-单选转" class="headerlink" title="(1).单选转"></a>(1).单选转</h4><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/16.png" style="zoom:90%"><br> <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/17.png" style="zoom:100%;"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图15：单选转</div></center></p><p>显示单选转</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="树" scheme="https://ZYBO_o.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅳ串</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</id>
    <published>2020-04-12T03:52:59.000Z</published>
    <updated>2020-04-12T04:07:33.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串" scheme="https://ZYBO_o.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-12T03:52:40.000Z</published>
    <updated>2020-04-12T04:07:25.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="栈和队列" scheme="https://ZYBO_o.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2020-04-12T03:52:15.000Z</published>
    <updated>2020-09-25T02:21:22.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p><blockquote><p><strong>性质：</strong></p><ul><li>线性表中的数据元素之间是有顺序的。</li><li>线性表中的数据元素个数是有限的。</li><li>线性表中的数据元素的类型必须相同。</li></ul></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div><hr><p>&lt;/br&gt;</p><h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png" style="zoom:45%;">. </p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p><ul><li>创建</li><li>分配内存</li><li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li><li>返回表的地址</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/6.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过数组下标的方式获取元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>把最后一个元素到插入位置的元素后移一个位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/3.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/4.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.将元素取出</span></span><br><span class="line">ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line"><span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.线性表长度减1</span></span><br><span class="line"><span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-顺序存储的优缺点"><a href="#3-顺序存储的优缺点" class="headerlink" title="(3).顺序存储的优缺点"></a>(3).顺序存储的优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/7.png" style="zoom:40%;"></p><hr><p>&lt;/br&gt;</p><h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/8.png" style="zoom:50%;"></p><p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/9.png" style="zoom:30%;"></p><p><strong>链表的基本概念:</strong></p><ul><li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li><li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li><li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/10.png" style="zoom:40%;"></p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/11.png" style="zoom:60%;"></p><p><strong>C语言用结构体来定义链表中的结点：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/13.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/12.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line"><span class="comment">//3.获取第pos个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line">current-&gt;next = ret-&gt;next;</span><br><span class="line"><span class="comment">//5.线性表长度减1</span></span><br><span class="line">sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-单链表结构与顺序存储结构优缺点"><a href="#3-单链表结构与顺序存储结构优缺点" class="headerlink" title="(3).单链表结构与顺序存储结构优缺点"></a>(3).单链表结构与顺序存储结构优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/15.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。</p><ul><li>顺序表数组中的元素由两个数据域组成:data和cur</li><li>data域用于存储数据</li><li>cur域用于存储下一个元素在数组中的下标</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/17.png" style="zoom:60%;"></p><p>把未被使用的数组元素称为<strong>备用链表。</strong>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；</p><p><strong>数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。</p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">    <span class="comment">//Cursor,为0时表示无指向 </span></span><br><span class="line"><span class="keyword">int</span> Cur; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p><strong>操作步骤：</strong></p><ul><li>申请MAXSIZE大小的空间</li><li>给游标赋值，最后一个游标赋为0</li><li>返回链表指针</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List <span class="built_in">list</span> = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*MAXSIZE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>[i].Cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="built_in">list</span>[MAXSIZE - <span class="number">1</span>].Cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></div><h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li><font color="red">在数组中查找空闲位置index</font></li><li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-静态链表优缺点"><a href="#3-静态链表优缺点" class="headerlink" title="(3).静态链表优缺点"></a>(3).静态链表优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/18.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/19.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p><ul><li>创建链表</li><li>销毁链表</li><li>获取链表长度</li><li>清空链表</li><li>获取第pos个元素操作</li><li>插入元素到位置pos</li><li>删除位置pos处的元素</li></ul><p>&lt;/br&gt;</p><h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2><h3 id="1-结构分析-4"><a href="#1-结构分析-4" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="线性表" scheme="https://ZYBO_o.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-04-12T03:50:54.000Z</published>
    <updated>2020-06-02T06:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><blockquote><p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul></blockquote><p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p><blockquote><p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p></blockquote><p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p><blockquote><p>性质相同，是指数据元素具有相同数量和类型的数据项。</p></blockquote><p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/1.png" style="zoom:50%;"></p><h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote><p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/2.png" style="zoom:50%;"></p><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p><blockquote><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p></blockquote><p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/3.png" style="zoom:50%;"></p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/4.png" style="zoom:40%;"></p><h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p></blockquote><p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><hr><p>&lt;/br&gt;</p><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据结构绪论" scheme="https://ZYBO_o.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/</id>
    <published>2020-04-10T03:25:38.000Z</published>
    <updated>2020-04-12T04:14:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-10T03:25:16.000Z</published>
    <updated>2020-04-10T04:09:24.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/</id>
    <published>2020-04-10T03:24:48.000Z</published>
    <updated>2020-04-10T04:09:17.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
</feed>
