<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYBO_o&#39;s Blogs</title>
  
  <subtitle>Follow Excellence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zybtree.github.io/"/>
  <updated>2020-08-11T00:55:42.263Z</updated>
  <id>https://zybtree.github.io/</id>
  
  <author>
    <name>ZYBO_o</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程&amp;线程模型</title>
    <link href="https://zybtree.github.io/2020/08/10/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zybtree.github.io/2020/08/10/进程-线程模型/</id>
    <published>2020-08-10T10:34:19.000Z</published>
    <updated>2020-08-11T00:55:42.263Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-进程基本概念"><a href="#一-进程基本概念" class="headerlink" title="一.进程基本概念"></a>一.进程基本概念</h1><blockquote><p>以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许<font color="red">多个程序同时进入内存</font>并运行。主要是<strong>为了提高 CPU的利用率,进而提高整个系统的效率。</strong></p></blockquote><img src="//zybtree.github.io/2020/08/10/进程-线程模型/1.png" style="zoom:40%;"><p>来看一个例子：</p><p>​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。</p><p>​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流，占用一个逻辑的程序计数器。这也是<strong>操作系统虚拟性的一个体现</strong>，<font color="red">把一个物理的程序计数器，给它变换成多个逻辑的程序计数器</font>，实际上每个程序都有自己的程序计数器，由于物理上只有一个程序计数器，所以每个程序真正的上 CPU 就把逻辑程序计数器的内容，推送到物理程序计数器里头。通过这种变换，达到了在内存中同时有多个程序，达到并发执行的效果。</p><p>​        C图表示出在一个时间间隔内，每一个程序 A B C D 都执行过了。由于只有一个物理 CPU ，所以这些程序是轮流在 CPU 上执行。但是从宏观上讲它们都在并发执行。</p><p><strong>同时又产生了一个问题：在这样一个计算环境下，多个程序并发执行，如何管理在并发环境下同时执行的这些程序？</strong>首先来看下并发环境与并发程序。</p><h2 id="1-并发环境与并发程序"><a href="#1-并发环境与并发程序" class="headerlink" title="1.并发环境与并发程序"></a>1.并发环境与并发程序</h2><p><strong>并发环境：</strong>一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态， 并且次序不是事先确定的。</p><p><strong>并发程序：</strong>在并发环境中执行的程序。</p><blockquote><p>在一个并发环境下执行的并发程序，怎么样来刻画这样的程序呢？于是进程的定义就应运而生了。</p></blockquote><h2 id="2-进程的定义"><a href="#2-进程的定义" class="headerlink" title="2.进程的定义"></a>2.进程的定义</h2><p><strong>定义：</strong>进程是具有独立功能的程序，关于某个数据集合上的一次运行活动，是资源分配的单位，也是CPU调度的单位。又称任务。</p><p><strong>特点：</strong></p><ul><li><p><strong>进程是程序的一次执行过程。</strong>（一个程序执行了两次,三次， 那就是不同的进程） </p></li><li><p><strong>进程是运行程序的一个抽象。</strong>（它代表了所运行的那个环境，代表了一个 CPU，因此有时候说进程是对 CPU 的一个抽象）</p></li><li><p><strong>将一个 CPU 把它变换成多个虚拟的 CPU 。</strong>(虚拟化技术)</p></li><li><p><strong>操作系统的资源是以进程为单位来分配的。比如说内存，文件等等。 最重要的一个资源就是地址空间。</strong>(操作系统为每一个进程分配了一个独立的地址空间)</p></li><li><p><strong>操作系统把CPU的控制权，交给了某一个进程，让这个进程上去运行，这称之为一个调度。</strong></p></li></ul><blockquote><p>在操作系统执行过程中，会有很多的程序向操作系统提出申请来运行，那么操作系统怎么知道这些进程是存在，还是不存在呢？ 这里就介绍操作系统为了管理进程所设计的一个非常重要的数据结构，进程控制块 PCB 。</p></blockquote><h2 id="3-进程控制块PCB"><a href="#3-进程控制块PCB" class="headerlink" title="3.进程控制块PCB"></a>3.进程控制块PCB</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1).定义"></a>(1).定义</h3><p><strong>PCB：Process Control Block.</strong>又称进程描述符、进程属性。</p><p>​        操作系统为了管理进程而，设计的一个非常重要的<strong>数据结构</strong>，这就是进程控制块PCB。这个数据结构是专门用于<strong>控制和管理进程的，它保存控制和管理进程所需要的所有的信息。</strong>主要是记录了进程的<strong>各种属性</strong>，并且描述出进程的<strong>运动变化过程</strong>，进程的<strong>发展程度</strong>。<strong>进程控制块PCB这个数据结构是操作系统感知进程存在的一个标志。它们是一一对应的。</strong></p><p><strong>进程表：</strong>由于操作系统管理了很多的进程，为了便于管理，就把所有进程的每个进程的PCB集中在一起，放在了内存的固定区域，这就形成了进程表。</p><blockquote><p>进程表是所有进程的 PCB 的一个集合。而且就是进程表的大小往往是固定的，确定了在一个操作系统中最多支持多少个进程 。</p></blockquote><h3 id="2-PCB包含的信息内容"><a href="#2-PCB包含的信息内容" class="headerlink" title="(2).PCB包含的信息内容"></a>(2).PCB包含的信息内容</h3><h4 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h4><ul><li><strong>进程标识符(process ID)</strong>，唯一的，通常是一个整数。</li><li><strong>进程名</strong>，通常基于可执行文件名，不唯一。</li><li><strong>用户标识符(user ID)</strong></li><li><strong>进程组关系</strong></li></ul><h4 id="进程控制信息"><a href="#进程控制信息" class="headerlink" title="进程控制信息"></a>进程控制信息</h4><ul><li><strong>当前状态</strong></li><li><strong>优先级(priority)</strong></li><li><strong>代码执行入口地址</strong></li><li><strong>程序的磁盘地址</strong></li><li><strong>运行统计信息</strong>(执行时间、页面调度) </li><li>进程间同步和通信</li><li>进程的队列指针</li><li>进程的消息队列指针</li></ul><h4 id="所拥有的资源和使用情况"><a href="#所拥有的资源和使用情况" class="headerlink" title="所拥有的资源和使用情况"></a>所拥有的资源和使用情况</h4><ul><li>虚拟地址空间的状况 </li><li>打开文件列表</li></ul><h4 id="CPU现场信息"><a href="#CPU现场信息" class="headerlink" title="CPU现场信息"></a>CPU现场信息</h4><blockquote><p><strong>CPU的现场信息</strong>是指当进程不运行的时候，操作系统要把一些重要的信息，硬件执行的状态信息，保存在PCB 里。</p></blockquote><ul><li><p>寄存器值(通用寄存器、程序计数 器PC、程序状态字PSW、栈指针)</p></li><li><p>指向该进程页表的指针</p></li></ul><h3 id="3-SOLARIS的进程控制块与进程表"><a href="#3-SOLARIS的进程控制块与进程表" class="headerlink" title="(3)SOLARIS的进程控制块与进程表"></a>(3)SOLARIS的进程控制块与进程表</h3><img src="//zybtree.github.io/2020/08/10/进程-线程模型/2.png" style="zoom:33%;"><p>SOLARIS是基于 Unix 操作系统，它的进程控制块的名字一般叫Proc结构。每一个Proc结构代表一个PCB。把所有的Proc结构组织成一个链，那么这就是一个进程表。</p><p><strong>Proc 结构保存的信息：</strong>（重点介绍三个）</p><p>第一个是可执行文件 p_exec，通过这样一个记录信息，可以找到这个进程所对应的可执行文件在磁盘上的位置。</p><p>第二个是进程的地址空间 p_as，进程地址空间放了很多内容，每一项内容都放在一段里头，通过段来把进程地址空间描述清楚，把这些段按照地址大小的顺序，把它建立成一个 AVL 树，便于以后的查找。 </p><p>第三个是文件表，通过这张表可以把所有打开的文件都能找到。</p><hr><h1 id="二-进程状态及状态转换"><a href="#二-进程状态及状态转换" class="headerlink" title="二.进程状态及状态转换"></a>二.进程状态及状态转换</h1><h3 id="1-进程的三种状态及状态的转换"><a href="#1-进程的三种状态及状态的转换" class="headerlink" title="1.进程的三种状态及状态的转换"></a>1.进程的三种状态及状态的转换</h3><h4 id="1-进程的三种基本状态"><a href="#1-进程的三种基本状态" class="headerlink" title="(1).进程的三种基本状态"></a>(1).进程的三种基本状态</h4><p><strong>运行态(Running)</strong> </p><p>进程占有CPU，并在CPU上运行。</p><p><strong>就绪态(Ready)</strong> </p><p>进程已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。</p><p><strong>等待态(Waiting/Blocked)</strong></p><blockquote><p>也称阻塞态、封锁态、睡眠态 </p></blockquote><p>进程因等待某一事件而暂时不能运行。</p><h4 id="2-三状态模型及状态转换"><a href="#2-三状态模型及状态转换" class="headerlink" title="(2).三状态模型及状态转换"></a>(2).三状态模型及状态转换</h4><img src="//zybtree.github.io/2020/08/10/进程-线程模型/3.png" style="zoom:25%;"><h2 id="2-进程的其他状态"><a href="#2-进程的其他状态" class="headerlink" title="2.进程的其他状态"></a>2.进程的其他状态</h2><p>###(1).创建态</p><p>已完成创建一进程所必要的工作，比如分配了PID、填写了PCB。但由于某些原因，操作系统尚未同意执行该进程。</p><h3 id="2-终止态"><a href="#2-终止态" class="headerlink" title="(2).终止态"></a>(2).终止态</h3><p>终止执行后，进程进入该状态。</p><ul><li><p>可完成一些数据统计工作</p></li><li><p><strong>资源回收</strong></p></li></ul><h3 id="3-挂起态"><a href="#3-挂起态" class="headerlink" title="(3).挂起态"></a>(3).挂起态</h3><p>在操作系统当中，如果想进行一些负载调节时，可能会把进程送入这个状态。</p><p>比如如果现在系统中进程太多，CPU也忙不过来了，此时操作系统会把一部分进程，让它暂时不能运行，但是它又不是等待某个事件发生，所以就把它弄成一个特殊的状态，叫挂起态。</p><p>一旦进程进入了挂起态，操作系统会把它的内存空间呢收回来。把这些进程的相关的内容送到磁盘上保存起来，一旦继续让它运行，我们通常称之为激活。进程的内容再从磁盘上读入内存就可以了。</p><h2 id="3-五状态模型"><a href="#3-五状态模型" class="headerlink" title="3.五状态模型"></a>3.五状态模型</h2><img src="//zybtree.github.io/2020/08/10/进程-线程模型/4.png" style="zoom:30%;"><h2 id="4-七状态模型"><a href="#4-七状态模型" class="headerlink" title="4.七状态模型"></a>4.七状态模型</h2><img src="//zybtree.github.io/2020/08/10/进程-线程模型/5.png" style="zoom:32%;"><h2 id="5-进程队列"><a href="#5-进程队列" class="headerlink" title="5.进程队列"></a>5.进程队列</h2><blockquote><p>操作系统在设计进程模型的时候要确定有什么样的状态，确定状态之间的转换，在什么条件下转换 ，通过什么样的操作来促成这种转换。 而且操作系统当中有很多的进程，它们都处于不同的状态。所以需要按不同的状态把它们管理起来，因此，操作系统设计了一个若干个进程队列。</p></blockquote><p>操作系统设计了一个若干个进程队列，为<strong>每一个类进程建立一个或者多个队列也是可以的。</strong> 每个队列的元素，实际上就是PCB 状态的改变，其实就是某个进程的PCB从一个队列出队，然后在另一个队列里头入队的过程。也就是伴随着状态的改变，进程的PCB从一个队列进入到另外一个队列。 </p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/6.png" style="zoom:35%;"><p><strong>五状态进程模型的队列模型：</strong></p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/7.png" style="zoom:38%;"><hr><h1 id="三-进程控制"><a href="#三-进程控制" class="headerlink" title="三.进程控制"></a>三.进程控制</h1><p>进程控制操作主要是完成进程之间的各状态之间的转换，<strong>进程控制操作实际上就是具有特定功能的程序。</strong> <font color="red">这个程序执行的时候，由于不允许被中断</font>，所以把它称之为原语。</p><p><strong>原语：</strong> <strong>所谓原语(有时候又称之为原子操作) 是完成某种特定功能的一段程序</strong>，比如说完成创建，或者是完成阻塞，它是一段程序，完成了某种特定功能，<font color="red">但是这个程序在执行过程中，是具有不可分割性，或者是不可中断的，它必须持续地执行，不允许被打断</font>，这就是原语。</p><blockquote><p>实现原语需要操作系统通过屏蔽中断的一些措施来达到这样一个结果。进程控制操作最重要的一个就是进程的创建。</p></blockquote><h2 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h2><p><strong>主要完成以下几个工作：</strong> </p><ol><li><p><strong>首先给每一个新的进程分配一个标识ID，再给它找一个空的、 没有用过的进程控制块</strong></p></li><li><p><strong>然后要给这个进程分配它所需要的地址空间。</strong> (如果这个地址空间在虚拟存储机制之下，就假设给了它，只是给了一个虚拟地址空间）。</p></li><li><p><strong>再初始化这个进程控制块，填写相应的内容</strong>。</p><ul><li>通常都是设定一些默认值，比如说状态，进程的状态设定为New 等等 </li></ul></li><li><p>创建进程控制块之后，要把它插入到相应的队列当中， <strong>所以要设置相应的队列指针</strong>。</p></li></ol><h2 id="2-进程撤销"><a href="#2-进程撤销" class="headerlink" title="2.进程撤销"></a>2.进程撤销</h2><p><strong>进程的撤销实际上就是结束进程。</strong></p><p>结束进程其实主要做两件事情：</p><ol><li><p><strong>把进程所占有的资源回收</strong> </p><ul><li>关闭它打开的文件；如果有网络连接就断开；如果分配了一些内存，就把它回收了</li></ul></li><li><p><strong><font color="red">资源回收之后最重要的，是要把分配给它的 PCB 收回。</font></strong></p></li></ol><h2 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3.进程阻塞"></a>3.进程阻塞</h2><p><strong>处于运行状态的进程，在其运行过程中期待某一事件发生</strong>，如等待键盘输入、等待 磁盘数据传输完成、等待其它进程发送消息， <font color="red">当被等待的事件未发生时，由<strong>进程自己执行阻塞原语，使自己由运行态变为阻塞态</strong>。</font></p><h3 id="4-UNIX的几个进程控制操作"><a href="#4-UNIX的几个进程控制操作" class="headerlink" title="4.UNIX的几个进程控制操作"></a>4.UNIX的几个进程控制操作</h3><ul><li><p><strong>fork( )：</strong>通过<font color="red">复制调用进程来</font>建立新的进程，是 最基本的进程建立过程</p></li><li><p><strong>exec( )：</strong>包括一系列系统调用，它们都是通过用 一段新的程序代码覆盖原来的地址空间，<font color="red">实现进程执行代码的转换</font></p></li><li><p><strong>wait( )：</strong>提供初级进程同步操作，能使一个进程等待另外一个进程的结束</p></li><li><p><strong>exit( )</strong>：用来终止一个进程的运行</p></li></ul><blockquote><p>他们都是以系统调用的形式，作为一个接头呈现给用户，由用户程序来调用 。</p></blockquote><h2 id="4-UNIX的FORK-实现"><a href="#4-UNIX的FORK-实现" class="headerlink" title="4.UNIX的FORK()实现"></a>4.UNIX的FORK()实现</h2><ol><li><p><strong>首先会为子进程分配一个空闲的进程描述符，也就是 PCB。</strong></p><blockquote><p> PCB在 UNIX 一般叫 proc 结构 </p></blockquote></li><li><p><strong>给子进程分配了一个唯一的标识pid</strong> </p></li><li><p><strong>给子进程分配地址空间</strong> </p><blockquote><p>在 UNIX 里 fork 以一次一页的方式把父进程的地址空间内容完全地拷贝给子进程</p></blockquote></li><li><p><strong>从父进程那里继承各种共享资源</strong></p><blockquote><p>比如打开的文件，当前工作目录等等 </p></blockquote></li><li><p><strong>子进程的状态 设置为就绪态，并且把它插入到了就绪队列</strong> </p></li><li><p><strong>做完这项工作之后，fork 就为子进程返回一个值 0</strong> </p></li><li><p><strong>为父进程返回一个值，是子进程的 pid</strong> </p></li></ol><blockquote><p>那么也就是说，fork 执行完后，原来一个进程，父进程就一分为二，变成了两个进程，一个父进程，一个子进程。</p><p>在父进程得到的返回值是 pid，在子进程里得到的返回值是 0。</p></blockquote><p><strong>问题：以一次一页的方式来复制父进程的地址空间有什么弊端？</strong></p><p>​        父进程把它所有的内容都拷贝给子进程 ，但是子进程不一定需要，而且通常情况下，父进程创建子进程是让子进程做与父进程所不同的工作。所以把发父进程所有内容拷贝给子进程，实际上，子进程也不需要。因此，子进程会接着执行 exec这样一个函数来把父进程拷贝过来的这些地址空间给覆盖掉。因此之前的这种复制工作，实际上就是无用功了。</p><p><strong>Linux 使用了写时复制技术 Copy-On-Write，</strong><font color="red">Linux中父进程把地址空间的指针传递给子进程，再把地址空间设置为只读。那么当子进程要往地址空间里写东西的时候，操作系统会为子进程单独再开辟一块空间，把相应的内容放进去 那么这样的话呢，节省了之前复制父进程地址空间的时间，加快了 fork 的实现速度。</font></p><p><strong>代码例子：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">pid = fork();<span class="comment">/* 创建一个子进程 */</span></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;<span class="comment">/* 出错 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “fork failed”);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span> </span><br><span class="line">    execlp(“/bin/ls”, “ls”, <span class="literal">NULL</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待子进程结束 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(“child complete”);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>流程：</strong></p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/8.png" style="zoom:50%;"><hr><h1 id="四-进程相关概念"><a href="#四-进程相关概念" class="headerlink" title="四.进程相关概念"></a>四.进程相关概念</h1><h2 id="1-进程的讨论"><a href="#1-进程的讨论" class="headerlink" title="1.进程的讨论"></a>1.进程的讨论</h2><h3 id="1-进程的分类"><a href="#1-进程的分类" class="headerlink" title="(1).进程的分类"></a>(1).进程的分类</h3><h4 id="第一种分类"><a href="#第一种分类" class="headerlink" title="第一种分类"></a>第一种分类</h4><ul><li><strong>系统进程</strong></li><li><strong>用户进程</strong> </li></ul><blockquote><p> 系统进程是操作系统为了管理一些资源而设计的进程,它的主要特点是优先级比较高。相对于用户进程而言，系统进程会优先被调度上CPU 去执行，因为它完成了一些关键的工作。</p></blockquote><h4 id="第二中分类"><a href="#第二中分类" class="headerlink" title="第二中分类"></a>第二中分类</h4><ul><li>前台进程</li><li>后台进程 </li></ul><blockquote><p> 前台进程实际上就是和用户直接交互的这样一些进程：用户敲键盘、 动鼠标。</p><p>后台进程往往是操作系统在启动了以后创建的一些进程，这些进程为用户来进行服务，比如说打印进程。</p><p>有一些应用进程也在系统启动的时候被创建了， 比如说防火墙，还有一些电子邮件的接收。这样的一些进程它们在后台工作，然后发生了一些事件，它们来接收这些事件。对于用户来讲，他所打交道的是前台进程。</p></blockquote><p>####第三种分类</p><ul><li>CPU 密集型进程</li><li>I/O 密集型程序</li></ul><blockquote><p> 有一些进程需要用到很多的 CPU 时间。比如说，画面渲染需要大量的计算，因此把它称之为 CPU 密集型进程 </p><p>有些经常需要输入、 输出、 读盘这样一些操作，这些进程被称之为 I/O 密集型 </p><p>那么这两类进程的区分也是为了以后调度程序的选择做一些准备 。</p></blockquote><h3 id="3-进程层次结构"><a href="#3-进程层次结构" class="headerlink" title="(3).进程层次结构"></a>(3).进程层次结构</h3><h4 id="UNIX进程家族树-init为根"><a href="#UNIX进程家族树-init为根" class="headerlink" title="UNIX进程家族树:init为根"></a>UNIX进程家族树:init为根</h4><p>UNIX 进程都是在一个家族里，这个家族树有一个根，这个根是一个 init 进程，是个 1 号进程，是所有进程的一个祖宗。在某些情况下，某一个进程它结束了，那么它的子孙进程，其实也必须全部的结束。</p><h4 id="Windows-地位相同"><a href="#Windows-地位相同" class="headerlink" title="Windows:地位相同"></a>Windows:地位相同</h4><p> 那在 Windows 中也是一个进程创建另一个进程，但是创建完之后，这两个进程的关系比较疏远，也就是它们的地位是相同的。 </p><h2 id="2-进程与程序的区别"><a href="#2-进程与程序的区别" class="headerlink" title="2.进程与程序的区别"></a>2.进程与程序的区别</h2><ul><li><strong>进程更能准确刻画并发，而程序不能</strong></li><li><strong>程序是静态的，进程是动态的</strong></li><li><strong>进程有生命周期的，有诞生有消亡，是 短暂的 ; 而程序是相对长久的</strong></li><li><strong>一个程序可对应多个进程</strong></li><li><strong>进程具有创建其他进程的功能</strong>(程序没有)</li></ul><h2 id="3-进程地址空间"><a href="#3-进程地址空间" class="headerlink" title="3.进程地址空间"></a>3.进程地址空间</h2><blockquote><p>操作系统会给每一个进程都分配了一个地址空间。怎么理解这句话？怎么理解这样一个场景？</p></blockquote><p><strong>以代码为例：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myval;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  myval = atoi(argv[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(“myval is %d, loc <span class="number">0</span>x%lx\n”, myval, (<span class="keyword">long</span>) &amp;myval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这个程序实际上是从命令行接收了参数，把这个参数赋给一个变量 myval 然后就是循环，来打印这个变量的值，同时把这个变量的位置 打印出来。 </p><p>现在同时执行两个 myval 程序。 也就是这两个进程在执行，因为用了一个循环，所以这个进程会一直在那运行下去。如果运行这两个进程，分别用参数 7，8 来调用这个程序，输出的结果如下：</p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/9.png" style="zoom:35%;"><blockquote><p>当执行 myval 7 的时候，myval 的这个变量值是 7 ，地址是 60104C 。同时 myval 8 也在执行。 发现 myval 的值是 8 ，而myval 的地址呢 也是 60104C。 <strong>为何变量 myval 的值是不一样的，地址却是相同的呢？</strong></p></blockquote><p>实际上每个进程有自己相对独立地址空间。 <font color="red"><strong>两个进程实际上是两个地址空间。而且它们的地址空间是隔离的。不同的地址空间，它的地址不是实际的物理内存地址。 实际上是一个相对地址，如果支持虚存的系统当中，那么这个地址就是虚拟地址，也可以说是一个相对地址，或者是逻辑地址。</strong></font></p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/10.png" style="zoom:35%;"><p>上图是一个进程地址空间的表示图。在这个空间里，操作系统会占一部分内容：</p><ul><li><p>上半部分是<strong>操作系统内核的地址空间</strong> </p></li><li><p>下面是<strong>用户地址空间</strong></p><blockquote><p>用户地址空间包括了用户执行的过程中所需要的一些代码数据，一些临时变量。 还有在运行过程中如果进行了过程调用函数调用，需要用栈来传递参数，那么主体有这样一些内容。在进程运行过程中还可能调一些共享库， 因此还有一些共享库放在这个位置；如果打开了文件以文件内存映射文件的方式来使用这个文件的话，那么也用到这些空间。这就是进程用户地址空间的内容。</p></blockquote></li></ul><p>myvalue 7 和 myvalue 8 这两个进程每个都有这么一个地址空间 ， <font color="red"><strong>因此myvalue这个变量实际上是在不同的地址空间里的相同的位置。因此，我们看到了虚拟地址虽然是相同的 那么这个相同指的是对于这个地址空间的位置，而不是指的在物理内存的位置。</strong></font></p><h2 id="4-进程映像-IMAGE"><a href="#4-进程映像-IMAGE" class="headerlink" title="4.进程映像(IMAGE)"></a>4.进程映像(IMAGE)</h2><p><strong>进程映像指的是进程执行过程中它的全过程的一个静态描述，可以把它看成是在某一瞬间的进程的快照。</strong> </p><p><strong>包括的内容：</strong>地址空间的内容，硬件寄存器的内容，以及与该进程相关的一些内核数据结构和内核栈。 </p><ul><li><p>用户相关:进程地址空间(包括代码段、数据段、 堆和栈、共享库……)</p></li><li><p>寄存器相关:程序计数器、指令寄存器、程序状态 寄存器、栈指针、通用寄存器等的值</p></li><li><p>内核相关:</p><ul><li>静态部分:PCB及各种资源数据结构</li><li>动态部分:内核栈(不同进程在进入内核后使用不同的内核栈)</li></ul></li></ul><h2 id="5-上下文-CONTEXT-切换"><a href="#5-上下文-CONTEXT-切换" class="headerlink" title="5.上下文(CONTEXT)切换"></a>5.上下文(CONTEXT)切换</h2><p><strong>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。</strong></p><ul><li><p>进程运行时，其硬件状态保存在<strong>CPU上的寄存器</strong>中。</p><blockquote><p>寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值。</p></blockquote></li><li><p>进程不运行时，这些寄存器的值保存在<strong>进程控制块 PCB中</strong>；<font color="red">当操作系统要运行一个新的进程时，将 PCB中的相关值送到对应的寄存器中。</font>这个就完成了上下文切换的一个过程。</p></li></ul><hr><h1 id="五-线程的引入"><a href="#五-线程的引入" class="headerlink" title="五.线程的引入"></a>五.线程的引入</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://zybtree.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://zybtree.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>研究生学习历程</title>
    <link href="https://zybtree.github.io/2020/08/05/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <id>https://zybtree.github.io/2020/08/05/研究生学习历程/</id>
    <published>2020-08-05T11:30:18.000Z</published>
    <updated>2020-08-10T00:14:59.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2020年8月学习计划"><a href="#2020年8月学习计划" class="headerlink" title="2020年8月学习计划"></a>2020年8月学习计划</h1><h2 id="2020年8月5日"><a href="#2020年8月5日" class="headerlink" title="2020年8月5日"></a>2020年8月5日</h2><ul><li><input checked disabled type="checkbox"> Makefile实验楼结束(博客写好)【但是还是感觉深度不够，继续看陈皓的《跟我一起写Makefile》】</li><li><input checked disabled type="checkbox"> 有关物理层认证的论文搜集好</li><li><input checked disabled type="checkbox"> 《跟我一起写Makefile》20页完成</li><li><input checked disabled type="checkbox"> 职业素质教育第二篇结束</li><li><input checked disabled type="checkbox"> 操作系统第二章一半(操作系统运行环境与运行机制)并完成博客</li><li><input checked disabled type="checkbox"> 跑步5公里</li></ul><p>学习和看书时尝试不再听歌，不再看手机，培养专注的习惯。</p><h2 id="2020年8月6日"><a href="#2020年8月6日" class="headerlink" title="2020年8月6日"></a>2020年8月6日</h2><ul><li><input checked disabled type="checkbox"> 《跟我一起写Makefile》只剩一章，知识点比较偏，不打算看了。</li><li><input checked disabled type="checkbox"> 英文综述看完一半。</li><li><input checked disabled type="checkbox"> 职业素质教育第三篇结束</li></ul><p>Deadline是第一生产力，这周把实验楼的Makefile和《跟我一起写Makefile》学了一遍，还是觉得《跟我一起写Makefile》更好一点。希望明天能把Makefile的Debug成功实现吧。</p><h2 id="2020年8月7日"><a href="#2020年8月7日" class="headerlink" title="2020年8月7日"></a>2020年8月7日</h2><ul><li><input checked disabled type="checkbox"> 复变函数公开课一讲</li><li><input disabled type="checkbox"> Eclipse 进行Makefile 的 Debug操作(没有成功，不知道是平台的原因还是代码的原因。。很可能是自己太菜了。。明天移植到VS或者VScode上试一下)</li><li><input checked disabled type="checkbox"> 英文综述看完</li><li><input checked disabled type="checkbox"> 职业素质教育第四篇结束</li><li><input disabled type="checkbox"> 操作系统第二章结束(没有结束。。打了两小时球。。)</li><li><input checked disabled type="checkbox"> 跑步5km</li></ul><h2 id="2020年8月8日"><a href="#2020年8月8日" class="headerlink" title="2020年8月8日"></a>2020年8月8日</h2><ul><li><input checked disabled type="checkbox"> 复变函数公开课</li><li><input checked disabled type="checkbox"> 职业素质教育第五篇结束</li><li><input checked disabled type="checkbox"> 论文三分之一</li></ul><p>去金鹰和朋友吃饭了。。晚上没看东西。。</p><h2 id="2020年8月9日"><a href="#2020年8月9日" class="headerlink" title="2020年8月9日"></a>2020年8月9日</h2><ul><li><input checked disabled type="checkbox"> 复变函数公开课</li><li><input checked disabled type="checkbox"> 无线通信公开课一讲</li><li><input checked disabled type="checkbox"> 职业素质教育整理结束(终于没有其他的东西了)</li><li><input checked disabled type="checkbox"> 论文三分之二</li><li><input checked disabled type="checkbox"> 操作系统第二章结束</li></ul><p>晚上看半泽直树2，什么都不能阻止自己！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="研究生学习" scheme="https://zybtree.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="规划" scheme="https://zybtree.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>操作系统运行环境与运行机制</title>
    <link href="https://zybtree.github.io/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/</id>
    <published>2020-07-21T07:50:23.000Z</published>
    <updated>2020-08-10T00:15:03.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-操作系统的主要工作"><a href="#一-操作系统的主要工作" class="headerlink" title="一.操作系统的主要工作"></a>一.操作系统的主要工作</h2><ul><li><p>程序的执行</p><blockquote><p>启动程序，执行程序以及程序的结束工作</p></blockquote></li><li><p><strong>完成体系结构相关的工作</strong>(操作系统与其他软件所不同的地方，与硬件打交道)</p></li><li><p><strong>完成应用程序所需的共性任务</strong>(读盘，申请内存，打印文件)</p><blockquote><p>提供各种基本服务</p></blockquote></li><li><p>性能，安全，健壮等问题</p></li></ul><p>用下图来明确操作系统的的地位：</p><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/1.png" style="zoom:30%;"><blockquote><p>从图中我们可以看出操作系统是在硬件基础上的第一层扩展。 </p><p>它底下是硬件， 这个硬件都做了什么工作呢？ 怎么样去了解底下的硬件呢？<strong>这就是本讲的一个内容之一：操作系统运行环境。</strong> 和硬件相关的很多的工作实际上是和操作系统的各个功能相结合的，<strong>这里介绍最基本的 CPU 状态： 中断与异常机制。</strong> 其他的像虚拟页式存储管理的机制， 设备等等的，会在后面跟操作系统功能结合起来讲。 </p><p>操作系统完成应用程序当中的一些共性的工作， 向应用程序提供一些基本服务，这是本讲另外一方面的内容：操作系统运行机制,这里重点介绍系统调用机制。</p></blockquote><hr><h2 id="二-处理机的状态"><a href="#二-处理机的状态" class="headerlink" title="二.处理机的状态"></a>二.处理机的状态</h2><p>处理器由<strong>运算器</strong>、<strong>控制器</strong>、一系列的<strong>寄存器</strong>以及<strong>高速缓存</strong>构成。<br>寄存器主要分为两类：</p><ul><li><strong>用户可见寄存器</strong>：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数。</li><li><strong>控制和状态寄存器</strong>：用于控制处理器的操作通常由操作系统代码使用。</li></ul><blockquote><p>对于用户可见寄存器，高级语言编译器通过优化算法分配这些寄存器，并且使用这些寄存器的主要的目的是为了减少访问内存的次数， 来提高程序的运行效率。 </p><p>操作系统设计者更加关注的是控制和状态寄存器。 而控制处理器的操作，那么通常只能由操作系统代码来使用。</p></blockquote><h3 id="1-控制和状态寄存器"><a href="#1-控制和状态寄存器" class="headerlink" title="1.控制和状态寄存器"></a>1.控制和状态寄存器</h3><p>控制和状态寄存器用于控制处理器的操作，只能在某种特权级别下可以访问、修改。</p><p>常见的控制和状态寄存器：</p><ul><li>程序计数器(PC:ProgramCounter)，记录将要取出的指令的地址。</li><li>指令寄存器(IR:InstructionRegister)，记录最近取出的指令。</li><li>程序状态字(PSW:Program Status Word)，记录 处理器的运行状态如条件码、模式、控制位等信息。</li></ul><h3 id="2-操作系统的需求——保护"><a href="#2-操作系统的需求——保护" class="headerlink" title="2.操作系统的需求——保护"></a>2.操作系统的需求——保护</h3><blockquote><p> 下面来探讨一下操作系统对硬件的需求，其中一个非常重要的需求就是保护。</p></blockquote><p>因为操作系统运行在一个多进程的这样一个环境下，为了支持这些进程的运行。 因此得从操作系统的特征来考虑：<strong>并发、 共享</strong>。 </p><p>操作系统为多个程序的执行提供了这样一个并发的环境，而多个进程之间又共享操作系统所管理的各种资源。 那么这样一个并发、 共享的计算环境就要求保护 。</p><p>其中保护是的：</p><ul><li>用户程序与用户程序之间互不干扰</li><li>用户程序不对操作系统干扰</li></ul><p>这就从操作系统的角度给硬件提出了实现保护、 实现保护控制这个需求。 </p><p>通常，希望硬件提供一个基本运行机制：<strong>CPU 具有一个特权级别，在不同的特权级下可以运行不同的指令集合。</strong> 这样把指令分成不同的集合，供操作系统和用户程序分别使用。 通过保护又使得操作系统与用户能够相隔离。 比如说当要访问操作系统空间的时候，那么用户程序是不能够访问的，但是操作系统可以访问用户程序空间， 因此通过一个保护机制达到操作系统与用户的隔离。 </p><p>有了这样一个需求之后，<strong>现代处理器通常把CPU 的状态设计为两种、 三种、 或者是四种。</strong> 但是这样在CPU 上时而运行操作系统、时而运行用户程序，CPU 如何知道是运行哪一种状态呢？ 这样就有赖于一些寄存器的某些位的设置：通常是在<font color="red">程序状态字寄存器 PSW</font>中专门设置一位或是两位，根据运行程序对资源和指令的权限不同，设置不同的 CPU 状态。 </p><p>这样不同的程序对资源和指令的使用要求是不同的。</p><p>以X86 处理器当中的典型的一个标志寄存器 EFLAGS，EFLAGS 寄存器为例：</p><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/2.png" style="zoom:50%;"> <p>其中就有一位<code>IOPL</code> 是 IO 的权限级别。 这个级别用两位来表示四个状态。 除了这个寄存器以外，还有一些 描述符设置了权限级别。 这是硬件提供的各种不同的CPU状态 。</p><h3 id="3-特权指令和非特权指令"><a href="#3-特权指令和非特权指令" class="headerlink" title="3.特权指令和非特权指令"></a>3.特权指令和非特权指令</h3><p>操作系统需要两种 CPU状态：</p><ul><li><strong>内核态(Kernel Mode)</strong>：运行操作系统程序。</li><li><strong>用户态(User Mode)</strong>：运行用户程序。</li></ul><p>因为操作系统只需要两个状态，而这两个状态可以指向不同的指令集合。因此把指令的集合也划分成两类：</p><ul><li><strong>特权(privilege)指令</strong>：只能由操作系统使用、用 户程序不能使用的指令。</li><li><strong>非特权指令</strong>：用户程序可以使用的指令。</li></ul><blockquote><p>其实整个指令系统操作系统是都可以使用的，它既可以使用特权指令，也可以使用非特权指令。而用户只能使用这个指令系统当中的一个子集，那么这个子集就是非特权指令。</p></blockquote><h3 id="4-实例：X86系列处理器"><a href="#4-实例：X86系列处理器" class="headerlink" title="4.实例：X86系列处理器"></a>4.实例：X86系列处理器</h3><p>X86支持4个处理器特权级别。特权环：R0、R1、R2和R3。</p><ul><li>从R0到R3，特权能力由高到低。</li><li>R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间。</li><li>不同级别能够运行的指令集合不同。</li></ul><h3 id="5-CPU状态之间的转换"><a href="#5-CPU状态之间的转换" class="headerlink" title="5.CPU状态之间的转换"></a>5.CPU状态之间的转换</h3><blockquote><p>有了不同的特权级别，那么就需要让<strong>用户程序</strong>和<strong>操作系统</strong>之间能有转换。</p></blockquote><p><strong>用户态——&gt; 内核态</strong>：<font color="red">中断/异常/陷入机制</font></p><p><strong>内核态 ——&gt; 用户态</strong>：设置程序状态字PSW</p><p>实际上<font color="red">用户程序在执行的过程中如果需要操作系统的服务，它就要从用户态能够陷入，进入内核态。而从用户态进入内核态的一个唯一的途径就是中断/异常/陷入机制 。</font>这也是下一个非常重要的主题。</p><p>而从内核态返回到用户态则比较简单啊，只是通过设置程序状态字寄存器就可以了。</p><blockquote><p>上面所提到的特殊的指令：陷入指令(访管指令)。它的作用是提供给用户程序的一个接口，用这个接口使用户程序可以向操作系统提出各种服务请求。</p><p>之所以叫访管指令， 是因为有的时候内核态也被称为一个supervisor mode管理态。 所以在这种情况下，从用户态进入了管理态，相当于访问管理态，所以叫访管指令。 </p><p>而这条特殊的指令在不同的计算机系统当中实际上是用不同的指令的。 比如 int 指令，trap 指令，syscall，sysenter/sysexit。 这些指令都是不同的计算机体系结构提供的这种特殊的指令，用于陷入(用于访管)。所以这是关于CPU状态之间的转换需要的不同的条件。</p></blockquote><hr><h2 id="三-中断与异常机制"><a href="#三-中断与异常机制" class="headerlink" title="三.中断与异常机制"></a>三.中断与异常机制</h2><blockquote><p>操作系统当中的中断和异常机制就好比是汽车中的发动机，或者是飞机引擎。靠它来驱动操作系统的运行。 有的时候是可以这么说，操作系统是由中断驱动/事件驱动的。有了这个机制，操作系统就可以做很多的事情。</p></blockquote><p><strong>主要作用：</strong></p><ul><li>及时处理设备发来的中断请求</li><li>可使OS捕获用户程序提出的服务请求  </li><li>防止用户程序执行过程中的破坏性活动 </li><li>……</li></ul><h3 id="1-中断与异常的概念"><a href="#1-中断与异常的概念" class="headerlink" title="1.中断与异常的概念"></a>1.中断与异常的概念</h3><p>所谓中断与异常，实际上是 CPU 对系统发生的某个事件的一种反应。当这个事件发生的时候，通过对这个事件的处理实际上是改变了一个控制流。我们通常说事件的发生改变了 CPU 的一个控制流。</p><p><strong>过程：</strong></p><ul><li>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序</li><li>处理完成后返回断点， 继续执行被打断的程序</li></ul><p><strong>特点：</strong></p><ul><li>是随机发生的</li><li>是自动处理的</li><li>是可恢复的</li></ul><h3 id="2-引入中断与异常的原因"><a href="#2-引入中断与异常的原因" class="headerlink" title="2.引入中断与异常的原因"></a>2.引入中断与异常的原因</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><strong>原因：中断的引入实际上是为了支持CPU与<font color="red">外部设备</font>的一个并行操作</strong></p><p>早期的计算机系统，如果没有中断机制的话 那么 CPU 要负责对设备的所有工作的管理。但是有了中断机制之后就可以这样来工作了。 </p><blockquote><p>比如：CPU 会去启动 输入输出设备的工作。 启动做完了之后设备本身就可以独立自己进行工作了 。而 CPU 这个时候呢可以转去处理一些和这次输入输出没有关系的事情。当设备完成了它的任务之后，它通过通过了中断向 CPU 报告这次输入输出的结果。让 CPU 来决策下面该做什么事情。 </p></blockquote><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>原因：表示CPU执行指令时<font color="red">本身</font>出现的问题</strong></p><blockquote><p>如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用。</p></blockquote><h3 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h3><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/3.png" style="zoom:30%;"><blockquote><p>中断是外部事件在CPU 之外产生的事件打断了 CPU 。这些事件是正在运行的程序所不期望的。</p><p>异常是由正在执行的指令而引发的 。</p></blockquote><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/4.png" style="zoom:50%;"><h2 id="四-中断与异常机制的工作原理"><a href="#四-中断与异常机制的工作原理" class="headerlink" title="四.中断与异常机制的工作原理"></a>四.中断与异常机制的工作原理</h2><p>中断/异常机制实际上是现代计算机系统中的核心机制之一。它的主要工作是硬件和软件相互配合来完成的通过软硬件的配合，来使计算机的能力得到充分地发挥。中断/异常机制的工作原理主要是从硬件与软件两个方面分析。</p><p><strong>硬件：</strong>捕获中断源发出的各种中断/异常的请求 ，以某一种方式来响应，通过把控制权转交给特定的处理程序来完成这个过程，而这个过程就是中断 。异常的响应，响应中断，响应异常这是硬件完成的工作。</p><p><strong>软件：</strong>识别中断， 异常类型完成对应的处理，<strong>实际上就是处理程序</strong>，把它称之为中断/异常处理程序。</p><h3 id="1-中断响应"><a href="#1-中断响应" class="headerlink" title="1.中断响应"></a>1.中断响应</h3><p>中断响应是发现中断、接收中断的过程，这部分由中断硬件部件完成。处理器控制部件中设有<strong>中断寄存器</strong>，其中保存了各种中断信号。</p><p><strong>CPU响应中断过程示意：</strong></p><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/5.png" style="zoom:50%;"><blockquote><p>中断向量表是个非常重要的软硬件结合的这么一个数据结构。 每一行呢实际上是一个中断向量 。中断向量表是由若干中断向量组成。</p><p>每一个中断向量其实就是一个<strong>内存单元</strong>。它是存放了中断处理程序的这个入口地址，以及这个程序，在运行的时候所需要的一个处理机的状态字。</p></blockquote><p><strong>中断响应示意：</strong></p><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/6.png" style="zoom:50%;"><h3 id="2-中断处理程序"><a href="#2-中断处理程序" class="headerlink" title="2.中断处理程序"></a>2.中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相 应的处理程序，并设置好中断向量表。系统运行时若响应中断，中断硬件部件将CPU控 制权转给中断处理程序。</p><p><strong>中断处理程序主要做的工作：</strong></p><ul><li>保存相关寄存器信息(硬件部件会保存关键寄存器的信息。其他的一些寄存器的信息还要再做进一步地保存)</li><li>分析中断/异常的具体原因</li><li>执行对应的处理功能</li><li>恢复现场，返回被事件打断的程序</li></ul><h3 id="3-中断异常机制小节"><a href="#3-中断异常机制小节" class="headerlink" title="3.中断异常机制小节"></a>3.中断异常机制小节</h3><p>以设备输入输出中断为例:</p><ul><li>打印机给CPU发中断信号 </li><li>CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号</li><li>CPU开始为软件处理中断做准备：<ul><li>处理器状态被切换到内核态</li><li>在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程 序状态字PSW</li></ul></li><li>CPU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序</li><li>中断处理程序开始工作：<font color="red">(软件工作)</font><ul><li>在系统栈中保存现场信息</li><li>检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等</li></ul></li><li>中断处理结束时，CPU检测到中断返回指令，从系统 栈中恢复被中断程序的上下文环境 ，CPU状态恢复成 原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期。</li></ul><h2 id="五-系统调用机制"><a href="#五-系统调用机制" class="headerlink" title="五.系统调用机制"></a>五.系统调用机制</h2><h3 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1.系统调用"></a>1.系统调用</h3><h4 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h4><p>系统调用是用户在编程时可以调用的操作系统功能。系统调用全称应该是操作系统功能调用，简称系统调用 。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>系统调用是操作系统给编程人员提供的唯一接口。 通过系统调用使得 CPU 的状态从用户态陷入了内核态。</p><h3 id="2-系统调用，库函数，API，内核函数之间的关系"><a href="#2-系统调用，库函数，API，内核函数之间的关系" class="headerlink" title="2.系统调用，库函数，API，内核函数之间的关系"></a>2.系统调用，库函数，API，内核函数之间的关系</h3><img src="//zybtree.github.io/2020/07/21/操作系统运行环境与运行机制/7.png" style="zoom:40%;"><blockquote><ul><li>应用程序可以直接调系统调用。但是通常情况下，应用程序都是通过了 C 函数库或者是 API 的接口来间接地调用系统调用。</li><li>在操作系统内核当中，提供了很多的内核函数。这些内核函数经过了封装把它提供到了 C 函数库，或者是 API 接口 。所以系统调用对于内核而言，内核函数就是这个系统调用的处理程序，而这些处理程序通过封装在 C 函数库或者 API 接口呢提供给用户来使用。</li><li>但是 C 函数库里头或者是 API 接口里头还有一些函数不是系统调用，它们就是一些普通的函数在完成一些功能。</li><li>有一些函数通过系统调用对应到了多个内核函数，也可能是某一个函数通过系统调用对应内核的一个函数。都是不太一样的。 </li><li>内核函数当中 也有一些函数呢是不开放给用户使用的 </li></ul></blockquote><p>应用程序大部分情况下是通过调用函数。 函数执行过程中再去变成系统调用来进入内核来完成。</p><h3 id="3-系统调用机制的设计"><a href="#3-系统调用机制的设计" class="headerlink" title="3.系统调用机制的设计"></a>3.系统调用机制的设计</h3><ol><li><p>首先利用硬件给我们提供的支持(就是中断异常机制)。通过这个机制实现系统调用服务。 </p></li><li><p>然后选择一条特殊的指令即<strong>陷入指令，也称之为访管指令</strong> 通过这条指令的执行引发一个异常完成从用户态到内核态的切换工作。看到只有一条指令。也就是说所有的系统调用，都是通过这条指令来进入内核的。</p><blockquote><p>在中断向量表或中断描述符表当中有一行专门用于系统调用。</p></blockquote></li><li><p>然后操作系统呢要为每一个系统调用事先确定一个编号(系统调用号)，因为要确定是哪一个系统调用。所以要通过编号来区分。而且每个系统调用其实还有不同的参数 ，所以呢我们还要设计相应的参数。这些工作除了操作系统的设计之外，还需要编译器来帮忙，编译器会把这个封装的系统调用把它展开 ，在过程中生成这条特殊的陷入指令，以及这些参数的推送寄存器的这些指令。</p></li><li><p>每一个系统调用其实都有一段内核函数，或者是一段代码来对应。 找到对应的内核函数就需要设计一张系统调用表，这张表就把系统调用的各项服务的入口地址填在这张表里头，那这张表也是在这个初始化的时候设置好了。</p></li></ol><h3 id="4-参数传递过程问题"><a href="#4-参数传递过程问题" class="headerlink" title="4.参数传递过程问题"></a>4.参数传递过程问题</h3><p>实现用户程序的参数传递给内核常用以下3种实现方法:</p><ul><li><font color="red">由陷入指令自带参数</font> : 陷入指令的长度有限，且 还要携带系统调用功能号，只能自带有限的参数</li><li><font color="red">通过通用寄存器传递参数</font> : 这些寄存器是操作系 统和用户程序都能访问的，但寄存器的个数会限制传递参数的数量</li><li><font color="red">在内存中开辟专用堆栈区</font>来传递参数</li></ul><h3 id="5-系统调用的执行过程"><a href="#5-系统调用的执行过程" class="headerlink" title="5.系统调用的执行过程"></a>5.系统调用的执行过程</h3><p>当CPU执行到特殊的陷入指令时:</p><ul><li><font color="red">中断/异常机制 </font>:硬件保护现场;通过查中断向量表把控制权转给系统调用总入口程序</li><li><font color="red">系统调用总入口程序 </font>:保存现场;将参数保存在内核堆 栈里;通过查系统调用表把控制权转给相应的系统调用 处理例程或内核函数</li><li><font color="red">执行系统调用例程</font></li><li><font color="red">恢复现场，返回用户程序</font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://zybtree.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统运行机制" scheme="https://zybtree.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概述</title>
    <link href="https://zybtree.github.io/2020/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://zybtree.github.io/2020/07/15/操作系统概述/</id>
    <published>2020-07-15T09:04:15.000Z</published>
    <updated>2020-07-21T06:49:46.414Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><p><strong>Question:</strong></p><ul><li>操作系统做了什么？</li><li>操作系统的定义与作用</li><li>操作系统的主要特征</li><li>操作系统的架构</li><li>操作系统的分类</li></ul><h2 id="一-操作系统做了什么"><a href="#一-操作系统做了什么" class="headerlink" title="一.操作系统做了什么"></a>一.操作系统做了什么</h2><p>通过下面程序的执行过程来分析操作系统对此程序的执行有哪些支持。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"hello world"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li><p>用户告诉操作系统执行 <code>helloworld</code>程序.</p></li><li><p>操作系统: 找到 <code>helloworld</code> 程序的相关信息，检查其类型是否是可执行文件; 并通过程序首部信息, 确定代码和数据在可执行文件中的位置并计算出对 应的磁盘块地址.</p></li><li><p>操作系统: 创建一个<strong>新的进程</strong>，并将 <code>helloworld</code> 可 执行文件映射到该进程结构，表示由该进程执行 <code>helloworld</code> 程序.</p></li><li><p>操作系统:为 <code>helloworld</code> 程序设置<strong>CPU上下文环境</strong>, 并跳到程序开始处,准备执行程序 (假设调度程序选中hello程序)</p></li><li><p>执行helloworld程序的第一条指令，<strong>发生缺页异常</strong>（代码和数据还没有读入内存，硬件机制会捕获缺页异常，把控制权交给操作系统）</p></li><li><p>操作系统: 分配一页<strong>物理内存</strong>，并将代码从磁盘读入内存，然后继续执行 <code>helloworld</code> 程序.</p></li><li><p><code>helloworld</code> 程序执行 <code>puts</code> 函数[<strong>系统调用</strong>(<strong>操作系统完成这个功能</strong>)]，在显示器上写一字符串.</p></li><li><p>操作系统: 找到要将字符串送往的显示设备，通常设备是由一个<strong>进程控制</strong>的，所以，操作系统将要写的字符串送给该进程.</p></li><li><p>操作系统: 控制设备的进程告诉设备的窗口系统 它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的<strong>存储映像区</strong>.</p></li><li><p>视频硬件将像素转换成显示器可接收的一组 <strong>控制/数据信号</strong>.</p></li><li><p>显示器解释信号，激发液晶屏.</p></li><li><p>OK!!!我们在屏幕上看到了 “hello world” .</p></li></ul><p><strong>从用户程序在执行过程中，不断请求操作系统服务的角度来看程序执行的过程：</strong></p><img src="//zybtree.github.io/2020/07/15/操作系统概述/1.png" style="zoom:25%;"><p>在CPU上执行一个用户程序，这个用户程序会不时地去请求操作系统的服务，因此在CPU上，时而运行的是用户程序。时而运行操作系统程序。</p><blockquote><p>以helloworld程序为例：</p><p>在执行的时候，需要操作系统来创建进程，因此转到操作系统创建进程</p><p>进程创建完了以后会从操作系统返回 ，接着执行这个helloworld程序，在出现了缺页异常以后，控制权又转回了操作系统</p><p>操作系统分配物理内存给这个用户程序 ，然后又转向用户程序接着执行，然后helloworld程序又要去执行puts函数</p><p>此时又转向了操作系统去进行系统调用。 </p></blockquote><p><strong>换一个角度看用户程序的执行：</strong></p><img src="//zybtree.github.io/2020/07/15/操作系统概述/2.png" style="zoom:25%;"><blockquote><p> 实际上，是操作系统在执行过程中呢，如果选中了一个程序，那么就去<strong>通过调度</strong>选中这个程序，去执行这个程序</p><p>程序执行过程中，会不断地去陷入操作系统,  由操作系统完成一些服务.然后再通过调度再选中程序，接着执行.</p></blockquote><p>从上面的介绍过程，看到在一个程序的执行过程中，<strong>操作系统负责了这个程序的启动过程, 负责了这个程序执行的过程, 同时在执行的 过程中，不断地去为用户程序的执行 提供各种各样的支持.</strong></p><hr><h2 id="二-操作系统的定义与作用"><a href="#二-操作系统的定义与作用" class="headerlink" title="二.操作系统的定义与作用"></a>二.操作系统的定义与作用</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><p>操作系统是计算机系统中的一个系统软件，是一 些程序模块的集合，这些模块相互协作，相互配合，来完成以下这些功能：</p><ul><li><p>它们能以尽量<font color="red">有效、合理</font>的方式组织和管理计算机的软硬件资源。</p></li><li><p>合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能。</p></li><li><p>使得用户能够灵活、<font color="red">方便</font>地使用计算机，使整个计算机系统高效率运行。</p></li></ul><blockquote><p><strong>有效</strong>：让系统效率，资源利用率得以提高。</p><p><strong>合理</strong>：各种软硬件资源的管理是否公平合理。</p><p><strong>方便使用</strong>：两种角度:<strong>用户界面</strong>与<strong>编程接口</strong>。</p></blockquote><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h3><ul><li><p>资源的管理者：<font color="red">有效</font></p></li><li><p>向用户提供的各种服务：<font color="red">方便使用</font></p></li><li><p>对硬件机器的扩展：<font color="red">扩展能力</font></p></li></ul><h4 id="1-对于OS是资源的管理者"><a href="#1-对于OS是资源的管理者" class="headerlink" title="(1)对于OS是资源的管理者"></a>(1)对于OS是资源的管理者</h4><p>自底向上看，OS是资源的管理者。</p><p><strong>硬件资源：</strong>CPU，内存，设备(I/O设备、磁盘、时钟、网 络卡等)。</p><p><strong>软件资源：</strong>磁盘上的文件、各类管理信息等。</p><h4 id="2-怎么管理资源"><a href="#2-怎么管理资源" class="headerlink" title="(2)怎么管理资源"></a>(2)怎么管理资源</h4><ul><li><p>跟踪记录资源的使用状况(通过数据结构与算法)</p><blockquote><p>如:哪些资源空闲，分配给谁使用，允许使用多长时间等</p></blockquote></li><li><p>确定<font color="blue">资源分配策略——算法</font></p><ul><li>静态分配策略(会导致资源的浪费)</li><li>动态分配策略(根据数据结构与资源使用情况来分配，资源的利用率得到了显著的提高)</li></ul></li><li><p>实施资源的分配(根据资源分配策略去决定)和回收</p></li><li><p>提高资源利用率</p></li><li><p>保护资源的使用(一个进程使用资源时，不能被另外的所干扰)</p></li><li><p>协调多个进程对资源请求的冲突</p></li></ul><h4 id="3-从资源管理的角度—五大基本功能"><a href="#3-从资源管理的角度—五大基本功能" class="headerlink" title="(3)从资源管理的角度—五大基本功能"></a>(3)从资源管理的角度—五大基本功能</h4><ul><li><p>进程/线程管理(CPU管理)</p><blockquote><p>进程线程状态、控制、同步互斥、通信、调度、……</p></blockquote></li><li><p>存储管理</p><blockquote><p>分配/回收、地址转换、存储保护、内存扩充、……</p></blockquote></li><li><p>文件管理</p><blockquote><p>文件目录、文件操作、磁盘空间、文件存取控制、……</p></blockquote></li><li><p>设备管理</p><blockquote><p>设备驱动、分配回收、缓冲技术、……</p></blockquote></li><li><p>用户接口</p><blockquote><p>系统命令、编程接口</p></blockquote></li></ul><h4 id="4-操作系统是各种服务的提供者"><a href="#4-操作系统是各种服务的提供者" class="headerlink" title="(4)操作系统是各种服务的提供者"></a>(4)操作系统是各种服务的提供者</h4><ul><li><p><strong>在操作系统之上，从用户角度来看:</strong></p><blockquote><p>操作系统为用户提供了一组功能强大、方便易用的<font color="red">命令</font>或<font color="red">系统调用</font></p></blockquote></li><li><p><strong>典型的服务：</strong></p><blockquote><p>进程的创建、执行;文件和目录的操作;I/O设备 的使用;各类统计信息; ……</p></blockquote></li></ul><h4 id="5-操作系统是硬件之上的第一层软件"><a href="#5-操作系统是硬件之上的第一层软件" class="headerlink" title="(5).操作系统是硬件之上的第一层软件"></a>(5).操作系统是硬件之上的第一层软件</h4><img src="/Users/zhangyongbin/Blog/zybTree/source/_posts/操作系统概述/3.png" style="zoom:30%;"><h4 id="6-操作系统在硬件机器的扩展"><a href="#6-操作系统在硬件机器的扩展" class="headerlink" title="(6).操作系统在硬件机器的扩展"></a>(6).操作系统在硬件机器的扩展</h4><p>操作系统在应用程序与硬件之间建立了一个等价的扩展机器(虚拟机)，对硬件抽象，提高可移植性;比底层硬件更容易 编程。</p><img src="//zybtree.github.io/2020/07/15/操作系统概述/4.png" style="zoom:30%;"><hr><h2 id="三-操作系统的特征"><a href="#三-操作系统的特征" class="headerlink" title="三.操作系统的特征"></a>三.操作系统的特征</h2><img src="//zybtree.github.io/2020/07/15/操作系统概述/5.png" style="zoom:25%;"><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><p><strong>并发(concurrency):</strong> 指处理多个同时性活动的能力。</p><blockquote><p>由于并发将会引发很多的问题:  活动切换、保护、相互依赖的活动间的同步.</p></blockquote><p>在计算机系统中同时存在多个程序运行，单CPU上 </p><p>​    <strong>宏观上：</strong>这些程序同时在执行。</p><p>​    <strong>微观上：</strong>任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的。</p><p><strong>并行(parallel)：</strong>与并发相似，但多指不同程序同时在多 个硬件部件上执行</p><blockquote><p><strong>有趣的例子记忆：</strong></p><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p></blockquote><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><p><strong>共享：</strong>操作系统与多个用户的程序共同使用计算机系统中的资源(共享有限的系统资源)。</p><p>操作系统要对系统资源进行合理分配和使用，使得这些资源在一个时间段内交替被多个进程所用。</p><p>共享分为：</p><ul><li><p><strong>互斥共享</strong>(如打印机)</p></li><li><p><strong>同时共享</strong>(如可重入代码、磁盘文件)</p></li></ul><p>正是这些功能，所以又有了复杂的问题:  <strong>资源分配难以达到最优化，如何保护资源？</strong></p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p><strong>虚拟(Virtual) : **一个物理实体映射为若干个对应的逻辑实体——</strong>分时<strong>或</strong>分空间**。虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。</p><blockquote><p><strong>典型的例子：</strong></p><ul><li>CPU——每个进程的”虚处理机”</li><li>存储器——每个进程都有独立的虚拟地址空间(代码+数据+堆栈)</li><li>显示设备——多窗口或虚拟终端</li></ul></blockquote><h3 id="4-随机"><a href="#4-随机" class="headerlink" title="4.随机"></a>4.随机</h3><p>随机：操作系统必须随时对<font color="blue">以不可预测的次序</font>发生的事件进行响应并处理。</p><blockquote><p><strong>因为随机性带来的例子：</strong></p><p>进程的运行速度不可预知：多个进程并发执行，“走走停停”，无法预知每个进程的运行推进的快慢。</p></blockquote><p><strong>带来的问题：</strong>难以重现系统在某个时刻的状态(包括重现运行中的错误)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://zybtree.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统概述" scheme="https://zybtree.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅷ排序</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅷ-排序/</id>
    <published>2020-04-12T03:54:09.000Z</published>
    <updated>2020-04-12T04:08:32.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="排序" scheme="https://zybtree.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅶ查找</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅶ查找/</id>
    <published>2020-04-12T03:53:45.000Z</published>
    <updated>2020-04-12T04:08:16.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="查找" scheme="https://zybtree.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅵ图</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅵ图/</id>
    <published>2020-04-12T03:53:24.000Z</published>
    <updated>2020-04-12T04:07:58.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="图" scheme="https://zybtree.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅴ树</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅴ树/</id>
    <published>2020-04-12T03:53:15.000Z</published>
    <updated>2020-04-12T04:07:47.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="树" scheme="https://zybtree.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅳ串</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅳ串/</id>
    <published>2020-04-12T03:52:59.000Z</published>
    <updated>2020-04-12T04:07:33.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串" scheme="https://zybtree.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅲ栈和队列/</id>
    <published>2020-04-12T03:52:40.000Z</published>
    <updated>2020-04-12T04:07:25.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="栈和队列" scheme="https://zybtree.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/</id>
    <published>2020-04-12T03:52:15.000Z</published>
    <updated>2020-08-03T09:21:44.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p><blockquote><p><strong>性质：</strong></p><ul><li>线性表中的数据元素之间是有顺序的。</li><li>线性表中的数据元素个数是有限的。</li><li>线性表中的数据元素的类型必须相同。</li></ul></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/1.png" style="zoom:50%;"><br><h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div><hr><br><h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p><p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/2.png" style="zoom:45%;">. </p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div><br><h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p><ul><li>创建</li><li>分配内存</li><li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li><li>返回表的地址</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/6.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><br><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过数组下标的方式获取元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>把最后一个元素到插入位置的元素后移一个位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/3.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/4.png" style="zoom:50%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.将元素取出</span></span><br><span class="line">ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line"><span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.线性表长度减1</span></span><br><span class="line"><span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h3 id="3-代码具体实现"><a href="#3-代码具体实现" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_SEQLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_SEQLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用void做封装，使用void之后在main函数中不会产生误操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIST_SEQLIST_H</span></span></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> TSeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    TSeqListNode * node;</span><br><span class="line">&#125;TSeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的线性表</span></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建</span></span><br><span class="line">    TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.分配内存</span></span><br><span class="line">        ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检验分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;capacity = capacity;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建完的链表的指针指向第一个节点的结尾处</span></span><br><span class="line">        ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新建成功的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在转换后线性表不为空的情况下，把长度设置为0</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的长度</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性表的长度</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的容量大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的容量大小</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.返回线性表的容量大小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向线性表的指定位置插入值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//2.检查列表不为空</span></span><br><span class="line">    <span class="keyword">int</span> ret = (slist != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检查线性表长度不大于容量。并且需要插入的值合理</span></span><br><span class="line">    ret = ret&amp;&amp;(slist-&gt;length+<span class="number">1</span> &lt;= slist-&gt;capacity);</span><br><span class="line">    ret = ret&amp;&amp;(<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在上述条件都合理的情况下进行操作</span></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果需要插入的位置大于等于线性表的长度，则把修改位置为线性表的最后</span></span><br><span class="line">        <span class="keyword">if</span>( pos &gt;= slist-&gt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = slist-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把需要插入位置后的节点都往后移一个单位</span></span><br><span class="line">        <span class="keyword">for</span> (i = slist-&gt;length; i &gt; pos ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i] = slist-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把节点插入需要的位置</span></span><br><span class="line">        slist-&gt;node[pos] = *((TSeqListNode*)node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线性表的长度加1</span></span><br><span class="line">        slist-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回操作结果(成功为1，失败为0)</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表中删除指定的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.去除删除元素</span></span><br><span class="line">    SeqListNode* ret = SeqList_Get(slist,pos);</span><br><span class="line">    <span class="comment">//因为上面是指针变量，所以删除后，ret指向的指针会改变，对于的值自然也会变，所以要及时转换成数值类型的变量</span></span><br><span class="line">    TSeqListNode date = *(TSeqListNode*)ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("在为SeqList_Delete函数中:%d\n",*(int*)ret);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.把删除后的元素全部向前移动一个单元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; slist-&gt;length ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i<span class="number">-1</span>] = slist-&gt;node[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slist-&gt;length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回删除的值</span></span><br><span class="line">    <span class="keyword">return</span> &amp;date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出线性表对应位置的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    SeqListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = (SeqListNode*)(&amp;slist-&gt;node[pos]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqList* <span class="built_in">list</span> = SeqList_Create(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;i, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;j, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;k, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;x, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;y, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;z, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;SeqList_Length(<span class="built_in">list</span>); index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)SeqList_Get(<span class="built_in">list</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SeqList_Length(<span class="built_in">list</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(<span class="keyword">int</span>*)SeqList_Delete(<span class="built_in">list</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    SeqList_Destroy(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><p><strong>运行结果：</strong></p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/5.png" style="zoom:50%;"><br><h3 id="4-顺序存储的优缺点"><a href="#4-顺序存储的优缺点" class="headerlink" title="(4).顺序存储的优缺点"></a>(4).顺序存储的优缺点</h3><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/7.png" style="zoom:40%;"><hr><br><h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/8.png" style="zoom:50%;"><p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/9.png" style="zoom:30%;"><p><strong>链表的基本概念:</strong></p><ul><li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li><li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li><li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/10.png" style="zoom:40%;"><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/11.png" style="zoom:60%;"><p><strong>C语言用结构体来定义链表中的结点：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><br><h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/13.png" style="zoom:45%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li><p>获取第pos个元素</p></li><li><p>将第pos个元素从链表中删除</p></li><li><p>线性表长度减1</p></li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/12.png" style="zoom:45%;"><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line"><span class="comment">//3.获取第pos个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line">current-&gt;next = ret-&gt;next;</span><br><span class="line"><span class="comment">//5.线性表长度减1</span></span><br><span class="line">sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><br><h3 id="3-代码具体实现-1"><a href="#3-代码具体实现-1" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_LINKLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_LINKLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span> <span class="title">LinkListNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList* <span class="title">LinkList_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Destroy</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Clear</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Length</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Insert</span><span class="params">(LinkList* <span class="built_in">list</span>, LinkListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Delete</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIST_LINKLIST_H</span></span></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function">LinkList* <span class="title">LinkList_Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//动态生成一个表头结点</span></span><br><span class="line">    TLinkList* ret = (TLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TLinkList));</span><br><span class="line">    <span class="comment">//判断是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回创建的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Destroy</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Clear</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度设置为0，头结点指向空</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;length = <span class="number">0</span>;</span><br><span class="line">        slist-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Length</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//长度赋给变量然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Insert</span><span class="params">(LinkList* <span class="built_in">list</span>, LinkListNode* node, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">    <span class="keyword">int</span> ret = (slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到需要插入的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入节点</span></span><br><span class="line">        node-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = node;</span><br><span class="line">        <span class="comment">//链表长度加一</span></span><br><span class="line">        slist-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得对应节点的值</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">   <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到指定的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把对应的节点地址赋给ret</span></span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Delete</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">    <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到指定的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行删除操作</span></span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">        current-&gt;next = ret-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链表长度减一</span></span><br><span class="line">        slist-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode header;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList*  <span class="built_in">list</span> = LinkList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v3</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v5</span>;</span></span><br><span class="line"></span><br><span class="line">    v1.v = <span class="number">1</span>;</span><br><span class="line">    v2.v = <span class="number">2</span>;</span><br><span class="line">    v3.v = <span class="number">3</span>;</span><br><span class="line">    v4.v = <span class="number">4</span>;</span><br><span class="line">    v5.v = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v1, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v2, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v3, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v4, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v5, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; LinkList_Length(<span class="built_in">list</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Value</span>* <span class="title">pv</span> = (<span class="title">struct</span> <span class="title">Value</span>*)<span class="title">LinkList_Get</span>(<span class="title">list</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点%d的值为:%d\n"</span>, i, pv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( LinkList_Length(<span class="built_in">list</span>) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Value</span>* <span class="title">pv</span> = (<span class="title">struct</span> <span class="title">Value</span>*)<span class="title">LinkList_Delete</span>(<span class="title">list</span>, 0);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除的节点的值为:%d\n"</span>, pv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    LinkList_Destroy(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><p><strong>运行结果：</strong></p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/14.png" style="zoom:40%;"><h3 id="4-单链表结构与顺序存储结构优缺点"><a href="#4-单链表结构与顺序存储结构优缺点" class="headerlink" title="(4).单链表结构与顺序存储结构优缺点"></a>(4).单链表结构与顺序存储结构优缺点</h3><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/15.png" style="zoom:50%;"><hr><br><h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和next。也就是说，数组的每个下标都对应一个data和一个next。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而next相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把next叫做游标。</p><ul><li>顺序表数组中的元素由两个数据域组成:data和next</li><li>data域用于存储数据</li><li>next域用于存储下一个元素在数组中的下标</li></ul><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/17.png" style="zoom:50%;"><blockquote><p>表头结点中，<code>data = 3</code> 表示链表长度为3，<code>next = 1</code> 表示下一个结点的位置是1。</p></blockquote><p><font color="red"><strong>静态链表是在顺序表的基础 静态链表是在顺序表的基础上利用数组实现的单链表。</strong></font></p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//节点结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_StaticListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> date;</span><br><span class="line">  <span class="keyword">int</span> next;</span><br><span class="line">&#125;TStaticListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态链表结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_StaticList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> capacity;</span><br><span class="line">  TStaticListNode header;</span><br><span class="line">  TStaticListNode node[];</span><br><span class="line">&#125;TStaticList;</span><br></pre></td></tr></table></figure></div><br><h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li><font color="red">在数组中查找空闲位置index</font></li><li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><h3 id="3-具体代码实现"><a href="#3-具体代码实现" class="headerlink" title="(3).具体代码实现"></a>(3).具体代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><h3 id="4-静态链表优缺点"><a href="#4-静态链表优缺点" class="headerlink" title="(4).静态链表优缺点"></a>(4).静态链表优缺点</h3><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/18.png" style="zoom:50%;"><hr><br><h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/19.png" style="zoom:50%;"><br><h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p><ul><li>创建链表</li><li>销毁链表</li><li>获取链表长度</li><li>清空链表</li><li>获取第pos个元素操作</li><li>插入元素到位置pos</li><li>删除位置pos处的元素</li></ul><br><h3 id="3-代码具体实现-2"><a href="#3-代码具体实现-2" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><br><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><hr><br><h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="线性表" scheme="https://zybtree.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <link href="https://zybtree.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/</id>
    <published>2020-04-12T03:50:54.000Z</published>
    <updated>2020-06-02T06:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><blockquote><p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul></blockquote><p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p><blockquote><p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p></blockquote><p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p><blockquote><p>性质相同，是指数据元素具有相同数量和类型的数据项。</p></blockquote><p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/1.png" style="zoom:50%;"><h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote><p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p></blockquote><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/2.png" style="zoom:50%;"><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p><blockquote><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p></blockquote><p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/3.png" style="zoom:50%;"><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p><img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/4.png" style="zoom:40%;"><h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p></blockquote><p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><hr><br><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://zybtree.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据结构绪论" scheme="https://zybtree.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅸ-C预处理器和C库/</id>
    <published>2020-04-10T03:25:38.000Z</published>
    <updated>2020-04-12T04:14:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅷ-位操作/</id>
    <published>2020-04-10T03:25:16.000Z</published>
    <updated>2020-04-10T04:09:24.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅶ-结构体和其他数据形式/</id>
    <published>2020-04-10T03:24:48.000Z</published>
    <updated>2020-04-10T04:09:17.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅵ 文件</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅵ-文件/</id>
    <published>2020-04-10T03:24:23.000Z</published>
    <updated>2020-04-10T04:09:09.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅴ 存储类,链接和内存管理</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅴ-存储类-链接和内存管理/</id>
    <published>2020-04-10T03:24:06.000Z</published>
    <updated>2020-04-21T12:40:24.694Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。</p></blockquote><h1 id="一-存储类别"><a href="#一-存储类别" class="headerlink" title="一.存储类别"></a>一.存储类别</h1><p><strong>硬件方面来看：</strong>被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<code>对象(object)</code>。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)。</p><p><strong>软件方面来看：</strong>程序需要一种方法访问对象。这可以通过声明变量来完成。</p><p>以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div><p>该声明创建了一个名为<code>entity</code>的<code>标识符(identifier)</code>。标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符<code>entity</code>即是软件(即C程序)指定<strong>硬件内存中的对象的方式</strong>。该声明还提供了<strong>储存在对象中的值</strong>。</p><p>但是变量名不是指定对象的唯一途径。以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>第1行声明中，<code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与 <code>entity</code>指定的对象相同。一般而言，那些指定对象的表达式被称为<em>左值<em>。所以，<code>entity</code>既是标识符也是左值；`</em>pt<code>既是表达式也是左值。按照这个思路，</code>ranks + 2 * entity<code>既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式</code></em>(ranks + 2 * entity)`是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅳ 字符串和字符串函数</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/</id>
    <published>2020-04-10T03:23:31.000Z</published>
    <updated>2020-04-19T09:54:42.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五-字符串函数"><a href="#五-字符串函数" class="headerlink" title="五.字符串函数"></a>五.字符串函数</h1><h2 id="1-strlen-函数"><a href="#1-strlen-函数" class="headerlink" title="1.strlen()函数"></a>1.strlen()函数</h2><p>strlen()函数用于统计字符串的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_fit.c -- try the string-shrinking function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* contains string function prototypes */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mesg[] = <span class="string">"Things should be as simple as possible,"</span></span><br><span class="line">    <span class="string">" but not simpler."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    fit(mesg,<span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Let's look at some more of the string."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg + <span class="number">39</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size)</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/1.png" style="zoom:50%;"><p><code>fit()</code>函数把第39个元素的逗号替换成<code>&#39;\0&#39;</code>字符。<code>puts()</code>函数在空字符处停止输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把这些字符打印了出来：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(mesg + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></div><p>表达式<code>mesg + 39</code>是<code>mesg[39]</code>的地址，该地址上储存的是空格字符。所以<code>put()</code>显示该字符并继续输出直至遇到原来字符串中的空字符.</p><p>演示过程如下图所示：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/2.png" style="zoom:50%;"><h2 id="2-strcat-和strncat-函数"><a href="#2-strcat-和strncat-函数" class="headerlink" title="2.strcat()和strncat()函数"></a>2.strcat()和strncat()函数</h2><p><code>strcat()</code>（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p><p><code>strcat()</code>函数的类型是<code>char *</code>（即，指向char的指针）。<code>strcat()</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p><p><code>strcat()</code>的用法:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* str_cat.c -- joins two strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  /* declares the strcat() function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/3.png" style="zoom:50%;"><p><code>strcat()</code>函数问题：</p><p><font color="red"><code>strcat()</code>函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。</font></p><p>解决方法：</p><ul><li>用<code>strlen()</code>查看第1个数组的长度。注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。</li></ul><ul><li>用<code>strncat()</code>，该函数的第3 个参数指定了最大添加字符数。</li></ul><p><code>strncat()</code>例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* join_chk.c -- joins two strings, check size first */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">    <span class="keyword">int</span> available;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    s_gets(flower, SIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(addon) + <span class="built_in">strlen</span>(flower) + <span class="number">1</span>) &lt;= SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">    <span class="built_in">puts</span>(flower);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite bug?"</span>);</span><br><span class="line">    s_gets(bug, BUGSIZE);</span><br><span class="line">    available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(bug, addon, available);</span><br><span class="line">    <span class="built_in">puts</span>(bug);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/4.png" style="zoom:50%;"><blockquote><p>strcat()和 gets()类似，也会导致缓冲区溢出。为什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？<strong>这也许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的。</strong>无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的使用安全。</p></blockquote><h2 id="三-strcmp-函数"><a href="#三-strcmp-函数" class="headerlink" title="三.strcmp()函数"></a>三.strcmp()函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅲ 数组与指针</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅲ-数组与指针/</id>
    <published>2020-04-10T03:23:09.000Z</published>
    <updated>2020-04-12T04:13:49.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
      <category term="指针" scheme="https://zybtree.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅱ 函数</title>
    <link href="https://zybtree.github.io/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/"/>
    <id>https://zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/</id>
    <published>2020-04-10T03:22:47.000Z</published>
    <updated>2020-04-10T09:02:02.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>什么是函数？</strong>函数（function）是完成特定任务的独立程序代码单元。</p><p><strong>为什么要使用函数？</strong>首先，使用函数可以省去编写重复代码，提高效率。其次，让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。如果不是自己编写函数，根本不用关心黑盒的内部行为；以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上</p></blockquote><p>以下面程序为例分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;            /* for strlen() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaces;</span><br><span class="line">    </span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);   <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    show_n_char(SPACE, <span class="number">12</span>);    <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line">    spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* Let the program calculate    */</span></span><br><span class="line">    <span class="comment">/* how many spaces to skip      */</span></span><br><span class="line">    show_n_char(SPACE, spaces);<span class="comment">/* use a variable as argument   */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line">    show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* an expression as argument    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* show_n_char() definition */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序在3处使用了<code>show_n_char()</code>标识符：<strong>函数原型(function prototype)</strong>告诉编译器函数<code>show_n_char()</code>的类型；<strong>函数调用(function call)</strong>表明在此处执行函数；<strong>函数定义(function definition)</strong>明确地指定了函数要做什么。</p><p><strong>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。</strong>因此，在main()函数定义的前面</p><h2 id="1-对于函数声明"><a href="#1-对于函数声明" class="headerlink" title="1.对于函数声明"></a>1.对于函数声明</h2><p>出现了下面的ANSI C风格的函数原型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></div><p>圆括号表明<code>show_n_char()</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。后面的<code>char</code>,<code>int</code>（在圆括号中）表明该函数带有两个参数，一个为<code>char</code>类型，一个为<code>int</code>类型。分号表明这是在声明函数，不是定义函数。<font color="red">函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。</font></p><blockquote><p>程序把 <code>show_n_char()</code>原型置于<code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p></blockquote><h2 id="2-对于函数参数"><a href="#2-对于函数参数" class="headerlink" title="2.对于函数参数"></a>2.对于函数参数</h2><p>还是以这个有ANSI C风格的函数头为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure></div><p>该行告知编译器<code>show_n_char()</code>使用两个参数ch和num，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数（formal argument，但是最近的标准推荐使用formal parameter）</strong>，简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。</p><blockquote><p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：void dibs(int x, y, z)　　　　 /* 无效的函数头 */</p></blockquote><p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，也可以省略变量名：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><p>在函数调用中，<strong>实际参数（actual argument，简称实参）</strong>提供了ch和num的值。考虑上例中第1次调用<code>show_n_char()</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_n_char(SPACE, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></div><p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，<font color="red">形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。</font></p><blockquote><p>1.注意 实际参数和形式参数：<strong>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</strong></p><p>2.<font color="red">为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</font></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div></blockquote><h2 id="3-关于return从函数中返回值"><a href="#3-关于return从函数中返回值" class="headerlink" title="3.关于return从函数中返回值"></a>3.关于return从函数中返回值</h2><p>函数的返回值可以把信息从被调函数传回主调函数。关键字<code>return</code>后面的表达式的值就是函数的返回值。</p><p>问题：如果函数返回值的类型与函数声明的类型不匹配会怎样？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">what_if</span><span class="params">(<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span>　z　=　<span class="number">100.0</span>　/　(<span class="keyword">double</span>)　n;</span><br><span class="line"><span class="keyword">return</span> z; <span class="comment">// 会发生什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = what_if(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div><p>虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。</p><h2 id="4-查找地址：-amp-运算符"><a href="#4-查找地址：-amp-运算符" class="headerlink" title="4.查找地址：&amp;运算符"></a>4.查找地址：&amp;运算符</h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。</p><p>下面例子中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* loccheck.c  -- checks to see where variables are stored  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;                      <span class="comment">/* declare function  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;             <span class="comment">/* local to main()   */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span>                   <span class="comment">/* define function   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">10</span>;                     <span class="comment">/* local to mikado() */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/3.png" style="zoom:50%;"><blockquote><p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值 2 传递给形式参数（mikado()中的bah）。<strong>注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。</strong></p></blockquote><h2 id="5-使用指针在函数间通信"><a href="#5-使用指针在函数间通信" class="headerlink" title="5.使用指针在函数间通信"></a>5.使用指针在函数间通信</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。</p><p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;　　 <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> * pc;　　　　<span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="keyword">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure></div><p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int * pi; 声明的意思是pi是一个指针,`</em>pi<code>是</code>int`类型 </p><p>pc指向的值（<em>pc）是char类型。pc本身是什么类型？我们描述它的类型是*</em>“指向char类型的指针<strong>。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，</strong>但是不能把两个指针相乘**。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。</p><p>下面例子就介绍了指针在函数间通信：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap2.c -- researching swap1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/4.png" style="zoom:50%;"><p>  该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把           地址作为它们的值。因此，应把它们声明为指针。</p><p>在<code>interchange(int *u, int *v)</code>函数中 <code>* u = x, * v = y</code>;即 <code>u = &amp;x, v = &amp;y</code>;</p><p><code>*u = *v</code>;——&gt;把 v 的地址赋值给 u; <code>*v = temp</code>;——&gt;把temp的地址赋值给v。</p><p><code>u</code>和 <code>v</code> 互换了地址。</p><p><strong>猜想：如果直接int * temp;是否也能改变值？</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u , *v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchangeo Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/6.png" style="zoom:50%;"><p>实践证明是不行的，因为定义指针temp后的交换与定义<code>int temp</code>,然后<code>interchange(int  u, int  v)</code>这样交换是一样的，都是同类型的交换。</p><p><strong>对于指针与地址的实验：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;n;</span><br><span class="line"><span class="keyword">int</span> temp = *p;</span><br><span class="line"><span class="keyword">int</span> *v;</span><br><span class="line">v = &amp;temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d,the loacl of n = %p\n"</span>,n,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p = %d,the loacl of p = %p\n"</span>,*p,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"temp = %d,the loacl of temp = %p\n"</span>,temp,&amp;temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*v = %d,the loacl of v = %p\n"</span>,*v,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/7.png" style="zoom:50%;"><blockquote><p>为什么temp的地址与* v的地址不一样呢，因为temp是新定义的变量，编译时给temp新分配了一个地址。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://zybtree.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://zybtree.github.io/tags/C/"/>
    
  </entry>
  
</feed>
