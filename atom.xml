<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYBO_o&#39;s Blogs</title>
  
  <subtitle>Follow Excellence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zybo_o.github.io/"/>
  <updated>2020-09-11T13:18:07.217Z</updated>
  <id>https://zybo_o.github.io/</id>
  
  <author>
    <name>ZYBO_o</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>研究生学习历程</title>
    <link href="https://zybo_o.github.io/2020/08/05/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <id>https://zybo_o.github.io/2020/08/05/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</id>
    <published>2020-08-05T11:30:18.000Z</published>
    <updated>2020-09-11T13:18:07.217Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2020年9学习计划"><a href="#2020年9学习计划" class="headerlink" title="2020年9学习计划"></a>2020年9学习计划</h1><h4 id="9月第一周"><a href="#9月第一周" class="headerlink" title="9月第一周"></a>9月第一周</h4><p>也就成功进行了Debug<code>l1app</code>子项目，论文没有进展，数据结构也没有真的开始，要戒骄戒躁啊。重新规划一下吧。</p><h2 id="2020年9月第二周"><a href="#2020年9月第二周" class="headerlink" title="2020年9月第二周"></a>2020年9月第二周</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul><li>论文阅读<ul><li>自适应矩阵完全搞懂</li><li>综述论文修改+排版</li><li>论文汇报</li></ul></li><li>论文仿真<ul><li>K临近算法</li></ul></li><li>数据结构<ul><li>基本概念+线性结构</li></ul></li><li>操作系统<ul><li>概述——书 + 视频</li></ul></li><li>项目<ul><li>调通 testMac 与 l1app</li></ul></li></ul><h3 id="每日任务"><a href="#每日任务" class="headerlink" title="每日任务"></a>每日任务</h3><h4 id="9月7日"><a href="#9月7日" class="headerlink" title="9月7日"></a>9月7日</h4><ul><li>[x] 综述论文修改完三分之一</li><li>[x] 汇报的论文完成三分之一</li><li>[x] VScode Debug例子结局，能够同时在Server与Client进行调试</li></ul><p>明天开始晚上停止打球了，不然累了什么都不想干。坚持跳绳21天，每天5k个，看看究竟能瘦多少。</p><h4 id="9月8日"><a href="#9月8日" class="headerlink" title="9月8日"></a>9月8日</h4><ul><li>[x]   综述论文修改到射频增强部分</li><li>[x]  汇报的论文完成三分之二</li><li>[x]  数据结构完成概述笔记</li><li>[x] 跳绳5k</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="研究生学习" scheme="https://ZYBO_o.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="规划" scheme="https://ZYBO_o.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅷ排序</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T03:54:09.000Z</published>
    <updated>2020-09-22T12:10:53.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="排序" scheme="https://ZYBO_o.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅶ查找</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-12T03:53:45.000Z</published>
    <updated>2020-04-12T04:08:16.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="查找" scheme="https://ZYBO_o.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅵ图</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</id>
    <published>2020-04-12T03:53:24.000Z</published>
    <updated>2020-04-12T04:07:58.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="图" scheme="https://ZYBO_o.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅴ树</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</id>
    <published>2020-04-12T03:53:15.000Z</published>
    <updated>2020-10-26T12:53:23.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h2><h3 id="1-需要掌握的定义："><a href="#1-需要掌握的定义：" class="headerlink" title="1.需要掌握的定义："></a>1.需要掌握的定义：</h3><ul><li>结点(根结点，双亲结点，子节点，兄弟结点)</li><li>子树和空树</li><li>结点的深度和高</li><li>有序树和无序树</li><li>森林</li><li>树的表示方法</li></ul><blockquote><p>对于结点ni，ni的深度是指<strong>从根到ni</strong>的唯一路径的长；ni的高是指<strong>从ni到一片树叶</strong>的最长路径的长。</p></blockquote><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/1.png" style="zoom:25%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图1：线性结构与树结构对比</div></center><p><br></p><h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二.二叉树"></a>二.二叉树</h2><h3 id="1-二叉树需要掌握的概念"><a href="#1-二叉树需要掌握的概念" class="headerlink" title="1.二叉树需要掌握的概念"></a>1.二叉树需要掌握的概念</h3><h4 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="(1).二叉树的定义"></a>(1).二叉树的定义</h4><ul><li>有序树</li><li>节点的度只能为0，1，2</li></ul><h4 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="(2).二叉树的性质"></a>(2).二叉树的性质</h4><ul><li>第$i$层最多有 $2^{i-1}$ 个结点。</li><li>若深度为$K$，则最多有$2^K-1$个结点。</li><li>终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$=$n_2$+1。</li></ul><blockquote><p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点(设为$n_1$)，那么总结点$n=n_0+n_1+n_2$。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数$n=B+1$。而分枝数是可以通过$n_1$和$n_2$表示的，即$B$=$n_1$+2<em>$n_2$。所以，n用另外一种方式表示为n=$n_1$+2</em>$n_2$+1。两种方式得到的n值组成一个方程组，就可以得出$n_0$=$n_2$+1。</p></blockquote><h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="(3).满二叉树"></a>(3).满二叉树</h4><ul><li><p>概念定义</p><ul><li>除了叶子结点外其余结点的度都为2，则为满二叉树。</li></ul></li><li><p>性质</p><ul><li>满二叉树中第i层的节点数为$2^n-1$个。</li><li>深度为k的满二叉树必有$2^k-1$个节点，叶子数为$2^k-1$。</li><li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有n个节点的满二叉树的深度为 $log_2(n+1)$。</li></ul></li></ul><h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="(4).完全二叉树"></a>(4).完全二叉树</h4><ul><li>概念定义<ul><li>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，且<font color="red"><strong>最后一层的结点依次从左到右分布</strong></font>，则此二叉树被称为完全二叉树。</li></ul></li></ul><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/2.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图2：完全二叉树与非完全二叉树</div></center><ul><li>性质<ul><li>n 个结点的完全二叉树的深度为$⌊log_2n⌋+1$。</li><li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号,对于任意一个结点 i,完全二叉树还有以下几个结论成立:<ul><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果2*i&gt;n(总结点的个数)，则结点i肯定没有左孩子(为叶子结点)；否则其左孩子是结点2*i 。</li><li>如果2*i+1&gt;n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1。</li></ul></li></ul></li></ul><p><br></p><h3 id="2-二叉树的存储结构"><a href="#2-二叉树的存储结构" class="headerlink" title="2.二叉树的存储结构"></a>2.二叉树的存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="(1).顺序存储结构"></a>(1).顺序存储结构</h4><p>二叉树的顺序存储，指的是使用顺序表(数组)存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，<font color="red">如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树，然后从根节点开始，按照层次依次将树中节点存储到数组即可。</font></p><p>如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/3.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图3：普通二叉树的转换</div></center><p> <br></p><p>普通二叉树的数组存储状态如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/4.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图4：普通二叉树的存储状态</div></center><p><br></p><h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="(2).链式存储结构"></a>(2).链式存储结构</h4><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/5.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图5：普通二叉树示意图</div></center><p>如图5所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图5对应的链式存储结构如图6所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/6.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图6：二叉树链式存储结构示意图</div></center><p>由图可知采用链式存储二叉树时，其节点结构由 3 部分构成：</p><ul><li>指向左孩子节点的指针（Left）；</li><li>节点存储的数据（Element）；</li><li>指向右孩子节点的指针（Right）；</li></ul><p>表示该节点结构的 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><br></p><h3 id="3-二叉树遍历介绍"><a href="#3-二叉树遍历介绍" class="headerlink" title="3.二叉树遍历介绍"></a>3.二叉树遍历介绍</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="(1).层序遍历"></a>(1).层序遍历</h4><p>通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/7.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图7：层次遍历二叉树示意图</div></center><h4 id="2-普通遍历"><a href="#2-普通遍历" class="headerlink" title="(2).普通遍历"></a>(2).普通遍历</h4><p>按照 “从上到下，从左到右” 的顺序遍历整棵二叉树，此种方式称为普通遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/8.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图8：普通遍历二叉树示意图</div></center><p>在层次遍历中，整个遍历过程只经过各个节点一次，因此在层次遍历过程，每经过一个节点，都必须立刻访问该节点，否则错失良机，后续无法再对其访问。</p><p>而普通遍历方式则不同，通过观察图 7 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 7 中的节点 2 为例，如图 8 所示，它被经过了 3 次。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/9.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图9：遍历节点2的过程示意图</div></center><p>因此，在编程实现时可以设定真正访问各个节点的时机，换句话说，既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。这也就引出了以下 3 种遍历二叉树的算法：</p><ol><li><strong><font color="red">先序遍历</font>：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 9 中的 ①）；</strong></li><li><strong><font color="red">中序遍历</font>：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 9 中的 ②）；</strong></li><li><strong><font color="red">后序遍历</font>：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 9 中的 ③）；</strong></li></ol><h2 id="三-遍历二叉树代码实现"><a href="#三-遍历二叉树代码实现" class="headerlink" title="三.遍历二叉树代码实现"></a>三.遍历二叉树代码实现</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>二叉树先序遍历的实现思想是：</p><ol><li>访问根节点；</li><li>访问当前节点的左子树；</li><li>若当前节点无左子树，则访问当前节点的右子树；</li></ol><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/10.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图10：二叉树</div></center><p>因此，图 10 中二叉树采用先序遍历得到的序列为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></div><h4 id="1-递归先序遍历"><a href="#1-递归先序遍历" class="headerlink" title="(1).递归先序遍历"></a>(1).递归先序遍历</h4><p>前序的规则就是<code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>.在调用递归前进行节点操作。对于先序，就是先访问(输出)该节点。而递归左，递归右侧，会优先递归左侧。<code>直到没有左节点</code>。才会停止。访问次序大致为：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/11.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图11：递归先序遍历过程</div></center><h4 id="2-非递归优先遍历"><a href="#2-非递归优先遍历" class="headerlink" title="(2).非递归优先遍历"></a>(2).非递归优先遍历</h4><p>非递归的先序利用栈的性质替代递归，因为<code>递归有时候在效率</code>方面不是令人满意的。<br>因为栈的顺序为后进先出。递归是左递归，右递归。<strong>所以利用栈要相反。</strong>利用递归的思路，需要先把右节点进栈，再遍历(输出)左节点。然后循环一直到最后，达到和递归顺序相仿效果。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/12.jpg" style="zoom:70%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图12：非递归先序遍历过程</div></center><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h4><p><strong>递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionPreOrderTraverse</span><span class="params">( Tree T )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DisplayElement( T );<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Left );<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Right );<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>非递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span> = CreateStack( <span class="number">20</span> );<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    Tree p;<span class="comment">//临时指针</span></span><br><span class="line">    Push( T ,<span class="built_in">stack</span> );<span class="comment">//根结点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">stack</span>-&gt;TopOfStack != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Top( <span class="built_in">stack</span> );<span class="comment">//取栈顶元素</span></span><br><span class="line">        Pop( <span class="built_in">stack</span> );<span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            DisplayElement( p );<span class="comment">//调用结点的操作函数</span></span><br><span class="line">            <span class="comment">//如果该结点有右孩子，右孩子进栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;Right) &#123;</span><br><span class="line">                Push(  p-&gt;Right ,<span class="built_in">stack</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;Left;<span class="comment">//一直指向根结点最后一个左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><h2 id="四-二叉树查找树"><a href="#四-二叉树查找树" class="headerlink" title="四.二叉树查找树"></a>四.二叉树查找树</h2><h2 id="五-平衡树-AVL"><a href="#五-平衡树-AVL" class="headerlink" title="五.平衡树(AVL)"></a>五.平衡树(AVL)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>AVL树本质上是<strong>一棵二叉查找树</strong>，但是它又具有以下特点：<strong><font color="red">它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font></strong>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树。</p><p>平衡二叉树和非平衡二叉树对比的例图：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/13.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图13：左边为一般二叉树，右边为二叉查找树</div></center><p><strong>平衡因子(bf)：</strong>结点的左子树的深度减去右子树的深度，那么显然-1&lt;=bf&lt;=1;</p><h3 id="2-AVL的作用"><a href="#2-AVL的作用" class="headerlink" title="2.AVL的作用"></a>2.AVL的作用</h3><p>对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度 $ O(log_2n)$ 同时也由此而决定。<strong>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 $O(n)$  </strong>。</p><p>所以可以通过随机化建立二叉搜索树来尽量的避免这种情况，<strong><font color="red">但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</font></strong></p><p>例如：按顺序将一组数据1,2,3,4,5,6分别插入到一棵空二叉查找树和AVL树中，插入的结果如下图：</p><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/14.png" style="zoom:30%"><br>  <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/15.png" style="zoom:40%"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图14：左边为二叉搜索树，右边为二叉平衡树</div></center></p><p>由上图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<strong>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是 $O(N)$ ，而AVL树就不会出现这种情况，树的高度始终是 $O(lgN)$ .高度越小，对树的一些基本操作的时间复杂度就会越小。这也就是引入AVL树的原因。</strong></p><h3 id="3-AVL的操作"><a href="#3-AVL的操作" class="headerlink" title="3.AVL的操作"></a>3.AVL的操作</h3><p>AVL树的操作基本和二叉查找树一样，这里关注的是两个变化很大的操作：<strong>插入</strong>和<strong>删除！</strong></p><p>AVL树不仅是一颗二叉查找树，它还有其他的性质。<strong>如果按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以要做一些特殊的处理，包括：单旋转和双旋转！</strong></p><h4 id="1-单选转"><a href="#1-单选转" class="headerlink" title="(1).单选转"></a>(1).单选转</h4><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/16.png" style="zoom:90%"><br> <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/17.png" style="zoom:100%;"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图15：单选转</div></center></p><p>显示单选转</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="树" scheme="https://ZYBO_o.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅳ串</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</id>
    <published>2020-04-12T03:52:59.000Z</published>
    <updated>2020-04-12T04:07:33.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串" scheme="https://ZYBO_o.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-12T03:52:40.000Z</published>
    <updated>2020-04-12T04:07:25.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="栈和队列" scheme="https://ZYBO_o.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2020-04-12T03:52:15.000Z</published>
    <updated>2020-09-25T02:21:22.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p><blockquote><p><strong>性质：</strong></p><ul><li>线性表中的数据元素之间是有顺序的。</li><li>线性表中的数据元素个数是有限的。</li><li>线性表中的数据元素的类型必须相同。</li></ul></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div><hr><p>&lt;/br&gt;</p><h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png" style="zoom:45%;">. </p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p><ul><li>创建</li><li>分配内存</li><li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li><li>返回表的地址</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/6.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过数组下标的方式获取元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>把最后一个元素到插入位置的元素后移一个位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/3.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/4.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.将元素取出</span></span><br><span class="line">ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line"><span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.线性表长度减1</span></span><br><span class="line"><span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-顺序存储的优缺点"><a href="#3-顺序存储的优缺点" class="headerlink" title="(3).顺序存储的优缺点"></a>(3).顺序存储的优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/7.png" style="zoom:40%;"></p><hr><p>&lt;/br&gt;</p><h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/8.png" style="zoom:50%;"></p><p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/9.png" style="zoom:30%;"></p><p><strong>链表的基本概念:</strong></p><ul><li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li><li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li><li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/10.png" style="zoom:40%;"></p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/11.png" style="zoom:60%;"></p><p><strong>C语言用结构体来定义链表中的结点：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/13.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/12.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line"><span class="comment">//3.获取第pos个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line">current-&gt;next = ret-&gt;next;</span><br><span class="line"><span class="comment">//5.线性表长度减1</span></span><br><span class="line">sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-单链表结构与顺序存储结构优缺点"><a href="#3-单链表结构与顺序存储结构优缺点" class="headerlink" title="(3).单链表结构与顺序存储结构优缺点"></a>(3).单链表结构与顺序存储结构优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/15.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。</p><ul><li>顺序表数组中的元素由两个数据域组成:data和cur</li><li>data域用于存储数据</li><li>cur域用于存储下一个元素在数组中的下标</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/17.png" style="zoom:60%;"></p><p>把未被使用的数组元素称为<strong>备用链表。</strong>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；</p><p><strong>数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。</p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">    <span class="comment">//Cursor,为0时表示无指向 </span></span><br><span class="line"><span class="keyword">int</span> Cur; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p><strong>操作步骤：</strong></p><ul><li>申请MAXSIZE大小的空间</li><li>给游标赋值，最后一个游标赋为0</li><li>返回链表指针</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List <span class="built_in">list</span> = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*MAXSIZE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>[i].Cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="built_in">list</span>[MAXSIZE - <span class="number">1</span>].Cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></div><h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li><font color="red">在数组中查找空闲位置index</font></li><li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-静态链表优缺点"><a href="#3-静态链表优缺点" class="headerlink" title="(3).静态链表优缺点"></a>(3).静态链表优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/18.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/19.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p><ul><li>创建链表</li><li>销毁链表</li><li>获取链表长度</li><li>清空链表</li><li>获取第pos个元素操作</li><li>插入元素到位置pos</li><li>删除位置pos处的元素</li></ul><p>&lt;/br&gt;</p><h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2><h3 id="1-结构分析-4"><a href="#1-结构分析-4" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="线性表" scheme="https://ZYBO_o.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-04-12T03:50:54.000Z</published>
    <updated>2020-06-02T06:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><blockquote><p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul></blockquote><p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p><blockquote><p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p></blockquote><p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p><blockquote><p>性质相同，是指数据元素具有相同数量和类型的数据项。</p></blockquote><p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/1.png" style="zoom:50%;"></p><h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote><p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/2.png" style="zoom:50%;"></p><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p><blockquote><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p></blockquote><p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/3.png" style="zoom:50%;"></p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/4.png" style="zoom:40%;"></p><h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p></blockquote><p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><hr><p>&lt;/br&gt;</p><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据结构绪论" scheme="https://ZYBO_o.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/</id>
    <published>2020-04-10T03:25:38.000Z</published>
    <updated>2020-04-12T04:14:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-10T03:25:16.000Z</published>
    <updated>2020-04-10T04:09:24.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/</id>
    <published>2020-04-10T03:24:48.000Z</published>
    <updated>2020-04-10T04:09:17.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅵ 文件</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-10T03:24:23.000Z</published>
    <updated>2020-04-10T04:09:09.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅴ 存储类,链接和内存管理</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-04-10T03:24:06.000Z</published>
    <updated>2020-04-21T12:40:24.694Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。</p></blockquote><h1 id="一-存储类别"><a href="#一-存储类别" class="headerlink" title="一.存储类别"></a>一.存储类别</h1><p><strong>硬件方面来看：</strong>被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<code>对象(object)</code>。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)。</p><p><strong>软件方面来看：</strong>程序需要一种方法访问对象。这可以通过声明变量来完成。</p><p>以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div><p>该声明创建了一个名为<code>entity</code>的<code>标识符(identifier)</code>。标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符<code>entity</code>即是软件(即C程序)指定<strong>硬件内存中的对象的方式</strong>。该声明还提供了<strong>储存在对象中的值</strong>。</p><p>但是变量名不是指定对象的唯一途径。以下面的例子作为分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>第1行声明中，<code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与 <code>entity</code>指定的对象相同。一般而言，那些指定对象的表达式被称为<em>左值</em>。所以，<code>entity</code>既是标识符也是左值；<code>*pt</code>既是表达式也是左值。按照这个思路，<code>ranks + 2 * entity</code>既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式<code>*(ranks + 2 * entity)</code>是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅳ 字符串和字符串函数</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-10T03:23:31.000Z</published>
    <updated>2020-04-19T09:54:42.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五-字符串函数"><a href="#五-字符串函数" class="headerlink" title="五.字符串函数"></a>五.字符串函数</h1><h2 id="1-strlen-函数"><a href="#1-strlen-函数" class="headerlink" title="1.strlen()函数"></a>1.strlen()函数</h2><p>strlen()函数用于统计字符串的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* test_fit.c -- try the string-shrinking function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* contains string function prototypes */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mesg[] = <span class="string">&quot;Things should be as simple as possible,&quot;</span></span><br><span class="line">    <span class="string">&quot; but not simpler.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    fit(mesg,<span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s look at some more of the string.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg + <span class="number">39</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size)</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img src="/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/1.png" style="zoom:50%;"></p><p><code>fit()</code>函数把第39个元素的逗号替换成<code>&#39;\0&#39;</code>字符。<code>puts()</code>函数在空字符处停止输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把这些字符打印了出来：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(mesg + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></div><p>表达式<code>mesg + 39</code>是<code>mesg[39]</code>的地址，该地址上储存的是空格字符。所以<code>put()</code>显示该字符并继续输出直至遇到原来字符串中的空字符.</p><p>演示过程如下图所示：</p><p><img src="/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/2.png" style="zoom:50%;"></p><h2 id="2-strcat-和strncat-函数"><a href="#2-strcat-和strncat-函数" class="headerlink" title="2.strcat()和strncat()函数"></a>2.strcat()和strncat()函数</h2><p><code>strcat()</code>（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p><p><code>strcat()</code>函数的类型是<code>char *</code>（即，指向char的指针）。<code>strcat()</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p><p><code>strcat()</code>的用法:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* str_cat.c -- joins two strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  /* declares the strcat() function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">&quot;s smell like old shoes.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What is your favorite flower?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End of file encountered!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == &#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/3.png" style="zoom:50%;"></p><p><code>strcat()</code>函数问题：</p><font color="red">`strcat()`函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。</font><p>解决方法：</p><ul><li>用<code>strlen()</code>查看第1个数组的长度。注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。</li></ul><ul><li>用<code>strncat()</code>，该函数的第3 个参数指定了最大添加字符数。</li></ul><p><code>strncat()</code>例子</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* join_chk.c -- joins two strings, check size first */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">&quot;s smell like old shoes.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">    <span class="keyword">int</span> available;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What is your favorite flower?&quot;</span>);</span><br><span class="line">    s_gets(flower, SIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(addon) + <span class="built_in">strlen</span>(flower) + <span class="number">1</span>) &lt;= SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">    <span class="built_in">puts</span>(flower);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What is your favorite bug?&quot;</span>);</span><br><span class="line">    s_gets(bug, BUGSIZE);</span><br><span class="line">    available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(bug, addon, available);</span><br><span class="line">    <span class="built_in">puts</span>(bug);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == &#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><img src="/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/4.png" style="zoom:50%;"></p><blockquote><p>strcat()和 gets()类似，也会导致缓冲区溢出。为什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？<strong>这也许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的。</strong>无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的使用安全。</p></blockquote><h2 id="三-strcmp-函数"><a href="#三-strcmp-函数" class="headerlink" title="三.strcmp()函数"></a>三.strcmp()函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅲ 数组与指针</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</id>
    <published>2020-04-10T03:23:09.000Z</published>
    <updated>2020-04-12T04:13:49.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
      <category term="指针" scheme="https://ZYBO_o.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅱ 函数</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-10T03:22:47.000Z</published>
    <updated>2020-04-10T09:02:02.624Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>什么是函数？</strong>函数（function）是完成特定任务的独立程序代码单元。</p><p><strong>为什么要使用函数？</strong>首先，使用函数可以省去编写重复代码，提高效率。其次，让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。如果不是自己编写函数，根本不用关心黑盒的内部行为；以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上</p></blockquote><p>以下面程序为例分析：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;            /* for strlen() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">&quot;GIGATHINK, INC.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">&quot;101 Megabuck Plaza&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">&quot;Megapolis, CA 94904&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">&#x27; &#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaces;</span><br><span class="line">    </span><br><span class="line">    show_n_char(<span class="string">&#x27;*&#x27;</span>, WIDTH);   <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    show_n_char(SPACE, <span class="number">12</span>);    <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, NAME);</span><br><span class="line">    spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* Let the program calculate    */</span></span><br><span class="line">    <span class="comment">/* how many spaces to skip      */</span></span><br><span class="line">    show_n_char(SPACE, spaces);<span class="comment">/* use a variable as argument   */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ADDRESS);</span><br><span class="line">    show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* an expression as argument    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, PLACE);</span><br><span class="line">    show_n_char(<span class="string">&#x27;*&#x27;</span>, WIDTH);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* show_n_char() definition */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>程序在3处使用了<code>show_n_char()</code>标识符：<strong>函数原型(function prototype)</strong>告诉编译器函数<code>show_n_char()</code>的类型；<strong>函数调用(function call)</strong>表明在此处执行函数；<strong>函数定义(function definition)</strong>明确地指定了函数要做什么。</p><p><strong>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。</strong>因此，在main()函数定义的前面</p><h2 id="1-对于函数声明"><a href="#1-对于函数声明" class="headerlink" title="1.对于函数声明"></a>1.对于函数声明</h2><p>出现了下面的ANSI C风格的函数原型：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></div><p>圆括号表明<code>show_n_char()</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。后面的<code>char</code>,<code>int</code>（在圆括号中）表明该函数带有两个参数，一个为<code>char</code>类型，一个为<code>int</code>类型。分号表明这是在声明函数，不是定义函数。<font color="red">函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。</font></p><blockquote><p>程序把 <code>show_n_char()</code>原型置于<code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p></blockquote><h2 id="2-对于函数参数"><a href="#2-对于函数参数" class="headerlink" title="2.对于函数参数"></a>2.对于函数参数</h2><p>还是以这个有ANSI C风格的函数头为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure></div><p>该行告知编译器<code>show_n_char()</code>使用两个参数ch和num，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数（formal argument，但是最近的标准推荐使用formal parameter）</strong>，简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。</p><blockquote><p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：void dibs(int x, y, z)　　　　 /<em> 无效的函数头 </em>/</p></blockquote><p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，也可以省略变量名：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><p>在函数调用中，<strong>实际参数（actual argument，简称实参）</strong>提供了ch和num的值。考虑上例中第1次调用<code>show_n_char()</code>：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_n_char(SPACE, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></div><p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，<font color="red">形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。</font></p><blockquote><p>1.注意 实际参数和形式参数：<strong>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</strong></p><p>2.<font color="red">为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</font></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></div></blockquote><h2 id="3-关于return从函数中返回值"><a href="#3-关于return从函数中返回值" class="headerlink" title="3.关于return从函数中返回值"></a>3.关于return从函数中返回值</h2><p>函数的返回值可以把信息从被调函数传回主调函数。关键字<code>return</code>后面的表达式的值就是函数的返回值。</p><p>问题：如果函数返回值的类型与函数声明的类型不匹配会怎样？</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">what_if</span><span class="params">(<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span>　z　=　<span class="number">100.0</span>　/　(<span class="keyword">double</span>)　n;</span><br><span class="line"><span class="keyword">return</span> z; <span class="comment">// 会发生什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = what_if(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div><p>虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。</p><h2 id="4-查找地址：-amp-运算符"><a href="#4-查找地址：-amp-运算符" class="headerlink" title="4.查找地址：&amp;运算符"></a>4.查找地址：&amp;运算符</h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。</p><p>下面例子中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* loccheck.c  -- checks to see where variables are stored  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;                      <span class="comment">/* declare function  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;             <span class="comment">/* local to main()   */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main(), pooh = %d and &amp;pooh = %p\n&quot;</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main(), bah = %d and &amp;bah = %p\n&quot;</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span>                   <span class="comment">/* define function   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">10</span>;                     <span class="comment">/* local to mikado() */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In mikado(), pooh = %d and &amp;pooh = %p\n&quot;</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In mikado(), bah = %d and &amp;bah = %p\n&quot;</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/3.png" style="zoom:50%;"></p><blockquote><p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值 2 传递给形式参数（mikado()中的bah）。<strong>注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。</strong></p></blockquote><h2 id="5-使用指针在函数间通信"><a href="#5-使用指针在函数间通信" class="headerlink" title="5.使用指针在函数间通信"></a>5.使用指针在函数间通信</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。</p><p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;　　 <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> * pc;　　　　<span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="keyword">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure></div><p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int </em> pi; 声明的意思是pi是一个指针,<code>*pi</code> 是 <code>int</code>类型 </p><p>pc指向的值（<em>pc）是char类型。pc本身是什么类型？我们描述它的类型是<strong>“指向char类型的指针</strong>。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，<em>*但是不能把两个指针相乘</em></em>。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。</p><p>下面例子就介绍了指针在函数间通信：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* swap2.c -- researching swap1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main Originally x = %d and y = %d.\n&quot;</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In interchange Originally u = %d and v = %d.\n&quot;</span>, *u, *v);</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In interchange Now u = %d and v = %d.\n&quot;</span>, *u, *v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/4.png" style="zoom:50%;"></p><p>  该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把           地址作为它们的值。因此，应把它们声明为指针。</p><p>在<code>interchange(int *u, int *v)</code>函数中 <code>* u = x, * v = y</code>;即 <code>u = &amp;x, v = &amp;y</code>;</p><p><code>*u = *v</code>;——&gt;把 v 的地址赋值给 u; <code>*v = temp</code>;——&gt;把temp的地址赋值给v。</p><p><code>u</code>和 <code>v</code> 互换了地址。</p><p><strong>猜想：如果直接int * temp;是否也能改变值？</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main Originally x = %d and y = %d.\n&quot;</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In main Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In interchange Originally u = %d and v = %d.\n&quot;</span>, *u , *v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In interchangeo Now u = %d and v = %d.\n&quot;</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/6.png" style="zoom:50%;"></p><p>实践证明是不行的，因为定义指针temp后的交换与定义<code>int temp</code>,然后<code>interchange(int  u, int  v)</code>这样交换是一样的，都是同类型的交换。</p><p><strong>对于指针与地址的实验：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;n;</span><br><span class="line"><span class="keyword">int</span> temp = *p;</span><br><span class="line"><span class="keyword">int</span> *v;</span><br><span class="line">v = &amp;temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n = %d,the loacl of n = %p\n&quot;</span>,n,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d,the loacl of p = %p\n&quot;</span>,*p,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;temp = %d,the loacl of temp = %p\n&quot;</span>,temp,&amp;temp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*v = %d,the loacl of v = %p\n&quot;</span>,*v,v);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/7.png" style="zoom:50%;"></p><blockquote><p>为什么temp的地址与* v的地址不一样呢，因为temp是新定义的变量，编译时给temp新分配了一个地址。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅰ 字符</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/</id>
    <published>2020-04-10T03:22:17.000Z</published>
    <updated>2020-04-10T08:57:35.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-单字符I-O-getchar-和-putchar"><a href="#1-单字符I-O-getchar-和-putchar" class="headerlink" title="1.单字符I/O : getchar() 和 putchar()"></a>1.单字符I/O : getchar() 和 putchar()</h2><blockquote><p>getchar() 和 putchar ()每次只能输入和输出一个字符。</p></blockquote><p>ANSI C 将 <code>stdio.h</code> 头文件与getchar() 和 putchar()相关联，这就是为什么程序中将该文件包含在内的原因。而且，getchar() 和 putchar() 不是真正的函数，而是定义为预处理器宏。</p><h3 id="1-getchar-与-scanf-的区分与混用"><a href="#1-getchar-与-scanf-的区分与混用" class="headerlink" title="1.getchar() 与 scanf() 的区分与混用"></a>1.getchar() 与 scanf() 的区分与混用</h3><p>在缓冲输入时需要按下Enter键，这一动作还传输一个程序必须处理的换行符。而<code>getchar()</code> 读取每个字符，包括空格，制表符和换行符；但是 <code>scanf()</code> 在在<strong>读取数字</strong>时会跳过空格，制表符和换行符。举例说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">int</span> rows,cols;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a character and a integers:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rows,&amp;cols);</span><br><span class="line">display(ch,rows,cols);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter anthor character and a integers:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a newline to quit.\n &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row,col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line"><span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(cr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/1.png" style="zoom:50%;"></p><p><img src style="zoom:50%;"></p><blockquote><p>程序会在输入之后，没有做出其他输入响应之前就结束了，原因是紧跟在输入3之后的那个换行符。</p></blockquote><p><strong><code>scanf()</code>函数将该换行符留在输入队列中，与<code>scanf()</code>不同，<code>getchar()</code> 并不跳过换行符。</strong>所以在循环的下一周期，再有机会输入任何其他内容之前，这一换行符由<code>getchar()</code>读出，然后将其赋值为ch，而ch为换行符才是结束循环的条件。</p><p>改善程序：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">int</span> rows,cols;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a character and a integers:\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;rows,&amp;cols) != <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">display(ch,rows,cols);</span><br><span class="line">    <span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter anthor character and a integers:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a newline to quit.\n &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row,col;</span><br><span class="line"><span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line"><span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line"><span class="built_in">putchar</span>(cr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/2.png" style="zoom:50%;"></p><blockquote><p>程序跳过了一个输入周期中输入的最后一个数字与下一行开始处输入的字符之间的所有换行符和空格。</p></blockquote><h3 id="2-输入流和数字"><a href="#2-输入流和数字" class="headerlink" title="2.输入流和数字"></a>2.输入流和数字</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is 28 12.4</span><br></pre></td></tr></table></figure></div><p>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。<font color="red">但是对 C程序而言，这是一个字节流。</font><strong>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等</strong>。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">putchar</span>(ch); <span class="comment">// 处理错误的输入</span></span><br></pre></td></tr></table></figure></div><p>虽然输入流由字符组成，但是也可以设置<code>scanf()</code>函数把它们转换成数值。例如，考虑下面的输入：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure></div><p>如果在<code>scanf()</code>函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，“它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，<code>scanf()</code>同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，<code>scanf()</code>也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。<br><strong>简而言之，输入由字符组成，但是<code>scanf()</code>可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而<code>getchar()</code>和使用%c的<code>scanf()</code>接受所有的字符。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>gdb学习</title>
    <link href="https://zybo_o.github.io/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zybo_o.github.io/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-26T10:54:52.000Z</published>
    <updated>2020-04-10T00:23:57.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p><p>在终端输入以下命令安装 GDB：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gdb</span></span><br></pre></td></tr></table></figure></div><h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2+3+...+%d= %d\n&quot;</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc bugging.c -o bugging -g -m64</span></span><br></pre></td></tr></table></figure></div><p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p><p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libc6-dev-i386</span></span><br></pre></td></tr></table></figure></div><p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb bugging</span></span><br></pre></td></tr></table></figure></div><p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) run</span></span><br></pre></td></tr></table></figure></div><p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) quit</span></span><br></pre></td></tr></table></figure></div><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/1.png" style="zoom:50%;"></p><h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p><blockquote><p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p></blockquote><p>部分 gdb 常用命令一览表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">简写形式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">list</td><td style="text-align:center">l</td><td style="text-align:center">查看源码</td></tr><tr><td style="text-align:center">backtrace</td><td style="text-align:center">bt,where</td><td style="text-align:center">打印函数栈信息</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">n</td><td style="text-align:center">执行下一行</td></tr><tr><td style="text-align:center">step</td><td style="text-align:center">s</td><td style="text-align:center">一次执行一行，遇到函数会进入</td></tr><tr><td style="text-align:center">finish</td><td style="text-align:center"></td><td style="text-align:center">运行到函数结束</td></tr><tr><td style="text-align:center">continue</td><td style="text-align:center">c</td><td style="text-align:center">继续运行</td></tr><tr><td style="text-align:center">break</td><td style="text-align:center">b</td><td style="text-align:center">设置断点</td></tr><tr><td style="text-align:center">info breakpoints</td><td style="text-align:center"></td><td style="text-align:center">显示断点信息</td></tr><tr><td style="text-align:center">delete</td><td style="text-align:center">d</td><td style="text-align:center">删除断点</td></tr><tr><td style="text-align:center">print</td><td style="text-align:center">p</td><td style="text-align:center">打印表达式的值</td></tr><tr><td style="text-align:center">run</td><td style="text-align:center">r</td><td style="text-align:center">启动程序</td></tr><tr><td style="text-align:center">until</td><td style="text-align:center">u</td><td style="text-align:center">执行到指定行</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">i</td><td style="text-align:center">显示信息</td></tr><tr><td style="text-align:center">help</td><td style="text-align:center">h</td><td style="text-align:center">帮助信息</td></tr></tbody></table></div><p>查询用法：</p><blockquote><p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p></blockquote><p>执行 Shell 命令：</p><blockquote><p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb)!shell 命令</span></span><br></pre></td></tr></table></figure></div><p>例如查看当前目录的文件：</p><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p></blockquote><h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p><ul><li>list 行号，显示某一行附近的代码：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/3.png" style="zoom:50%;"></p><ul><li>list 函数名，显示某个函数附近的代码：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/4.png" style="zoom:50%;"></p><ul><li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li></ul><h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p><ul><li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/5.png" style="zoom:50%;"></p><ul><li>break 文件名 : 行号，适用于有多个源文件的情况。</li></ul><ul><li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/6.png" style="zoom:50%;"></p><ul><li>break 文件名 : 函数名，适用于有多个源文件的情况。</li></ul><h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/7.png" style="zoom:50%;"></p><p>其中每一项的信息：</p><blockquote><ul><li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li><li>Type 列代表断点类型，一般为 breakpoint</li><li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li><li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li><li>Address 列代表该断点处虚拟内存的地址</li><li>What 列代表该断点在源文件中的信息</li></ul></blockquote><h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p><ul><li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/8.png" style="zoom:50%;"></p><ul><li>delete，不带任何参数，默认删除所有断点：</li></ul><h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p><blockquote><p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p><p><em>enable</em> 命令用于启用断点。</p></blockquote><ul><li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/9.png" style="zoom:50%;"></p><ul><li><p>disable，不带任何参数，默认关闭所有断点。</p></li><li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p></li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/10.png" style="zoom:50%;"></p><ul><li>enable，不带任何参数，默认启用所有断点。</li></ul><p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p><h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p><ul><li>enable once Num，断点 hit 一次之后关闭该断点</li><li>enable delete Num，断点 hit 一次之后删除该断点</li></ul><p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/11.png" style="zoom:50%;"></p><p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p><h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol><li><strong>打印变量</strong></li></ol><p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p><blockquote><ul><li><p><code>info locals</code></p><p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p></li><li><p><code>print 变量或表达式</code></p><p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p><p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p></li></ul></blockquote><ol><li><strong>启动程序</strong></li></ol><p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p><blockquote><ul><li><p><code>run</code></p><p>不带任何参数，启动待调试程序，不传递参数。</p></li><li><p><code>run 参数</code></p><p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p></li></ul></blockquote><ol><li><strong>单步命令</strong></li></ol><p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p><blockquote><ul><li><p><code>next</code></p><blockquote><p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p><p>next N，表示单步执行N次</p></blockquote></li><li><p><code>step</code></p><blockquote><p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p><p>step N，表示单步执行N次</p></blockquote></li><li><p><code>finish</code></p><p>执行程序到当前函数结束</p></li><li><p><code>continue</code></p><p>执行程序到下个断点</p></li><li><p><code>until</code></p><p>until N，执行程序到源代码的某一行</p></li></ul></blockquote><h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p><blockquote><ul><li><code>list</code></li><li><code>info breakpoints</code></li><li><code>break</code></li><li><code>delete</code></li><li><code>disable</code> 和 <code>enable</code></li><li><code>enable once</code> 和 <code>enable delete</code></li><li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li><li><code>info locals</code> 和 <code>print</code></li></ul></blockquote><p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
      <category term="gdb" scheme="https://ZYBO_o.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习</title>
    <link href="https://zybo_o.github.io/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zybo_o.github.io/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-15T02:09:41.000Z</published>
    <updated>2020-08-04T01:44:52.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-为什么使用Makefile"><a href="#一-为什么使用Makefile" class="headerlink" title="一.为什么使用Makefile"></a>一.为什么使用Makefile</h1><p>假设有一个如图所示的C工程：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/1.png" alt></p><p>如果要编译出可执行程序project_demo，必须执行以下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤1：编译主程序模块</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;100个主程序模块的o文件&gt; -c &lt;100个主程序模块的c文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤2：编译功能模块a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块a的o文件&gt; &lt;1000个功能模块a的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs liba.a &lt;1000个功能模块a的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤3：编译功能模块b</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块b的o文件&gt; &lt;1000个功能模块b的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libb.a &lt;1000个功能模块b的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤4：生成可执行文件demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o demo &lt;100个主程序模块的o文件&gt; -L. -la -lb</span></span><br></pre></td></tr></table></figure></div><p><strong>这样就出现了两个问题：</strong></p><blockquote><ul><li>上述4个编译步骤中，几乎每个步骤都有亢长的文件名列表需要输入而且有些还是重复的，这种工作枯燥而又费时，且极易因人为疏忽而出现错误；</li><li>假设demo项目每次编译所需的时间都比较长，那么如果之就前已经成功编译过了demo项目，而此后当我们修改了某些源文件需要更新的demo文件时，理论上我们是不希望也不需要去重新编译整个项目的，我们只需要仅分析其中的依赖关系，仅执行需要重新编译链接的命令，以节省编译时间，但是对于依赖关系非常复杂的工程而言，分析源文件涉及到的依赖关系是个非常复杂且容易出错的过程。</li></ul></blockquote><p><strong>而make和Makefile的出现就是为了解决这两个问题的：</strong></p><blockquote><ul><li>makefile文件帮助我们<strong>记录了整个项目工程的所有需要编译的文件列表</strong>，这样我们在编译时仅需要输入简单的make命令就能编译出我们期望的结果。</li><li>makefile文件<strong>反映了整个项目中各个模块的依赖关系</strong>，这样我们改动了某些源文件后，仅需简单的输入make命令，<strong>make工具就会根据makefile文件里描述的依赖关系帮助我们分析哪些模块需要重新编译</strong>，并执行相应的操作。</li></ul></blockquote><p><strong>在linux/unix开发环境中，makefile文件则是描述了一个特定编译系统所需要的策略，而make工具则是通过解析makefile文件并执行相应的命令来帮助我们构建其编译系统。</strong></p><p>所以主要围绕着下面两个问题来学习Makefile和Make：</p><ol><li><font color="red">makefile如何记录整个项目工程的所有需要编译的文件列表及如何反映整个项目中各个模块的依赖关系?</font></li><li><font color="red">提供了makefile策略描述后，make工具又是是如何解析makefile文件来帮助我们构建其编译系统的？</font></li></ol><hr><h1 id="二-关于Makefile"><a href="#二-关于Makefile" class="headerlink" title="二.关于Makefile"></a>二.关于Makefile</h1><h2 id="1-Makefile简介"><a href="#1-Makefile简介" class="headerlink" title="1.Makefile简介"></a>1.Makefile简介</h2><p>makefile就是一个简单的文本文件，它基本上就是由一条条的<code>规则</code>构成。了解一下makefile里的最基本的语法单元，<strong>规则</strong>。</p><p>一条makefile的规则构成如下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target:prerequisites</span></span><br><span class="line">&lt;tab&gt; command1</span><br><span class="line">&lt;tab&gt; command2</span><br><span class="line">.....</span><br><span class="line">&lt;tab&gt; commandN</span><br></pre></td></tr></table></figure></div><ul><li>target：<font color="red">规则的目标</font>，可以简单理解为<strong>这条规则存在的目的是什么</strong>。通常是<strong>程序中间或者最后需要生成的文件名</strong>，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。</li><li>prerequisites：<font color="red">规则的依赖列表</font>，可以简单的理解为<strong>要达到本条规则的目标所需要的先决条件是什么</strong>。可以是文件名，也可以是其他规则的目标；</li><li>command：<font color="red">规则的命令</font>，可以简单的理解为<strong>当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标</strong>。规则的命令其实就是shell命令。一条规则中可以有多行命令，<strong>特别注意：每行命令都必须以tab键开始！</strong></li></ul><p>实践一个简单的makefile例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最简单的makefile文件</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span>  <span class="comment">#注意：每行命令都必须以tab键开始！</span></span><br></pre></td></tr></table></figure></div><p>这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(<strong>规则不可以没有目标但是可以没有依赖</strong>)，以及一条命令(其实规则也是可以不需要任何命令的)。</p><p>在终端执行Makefile文件：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p><h2 id="2-Make的工作原理"><a href="#2-Make的工作原理" class="headerlink" title="2.Make的工作原理"></a>2.Make的工作原理</h2><p>通过回答下面三个问题来解释make的工作原理：</p><blockquote><ol><li>make命令如何使用</li><li>make从哪读取Makefile</li><li>make如何解析执行Makefile文件的规则</li></ol></blockquote><p>make命令的基本使用范式如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make [ -f makefile ] [ options ] ... [ targets ] ...</span><br></pre></td></tr></table></figure></div><p>使用make命令的最简单的方式主要有如下四种形式:</p><ol><li>简单粗暴，不带任何参数，直接执行make：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure></div><ol><li>指定makefile文件：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f &lt;makefile_name&gt;</span><br></pre></td></tr></table></figure></div><ol><li>指定makefile目标：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &lt;target&gt;</span><br></pre></td></tr></table></figure></div><ol><li>指定目录下执行make：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C &lt;subdir&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure></div><p>在执行make的时候，我们可以带上<code>-f &lt;文件名&gt;</code>参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为<strong>GNUmakefile, makefile,和 Makefile</strong>的文件来作为其makefile文件。</p><p>在读取完makefile的内容后，make工具<strong>并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。</strong><font color="red">而这条作为突破口的规则的目标，称为<strong>终极目标</strong></font> 。我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。</p><p>一般情况下，make执行一条规则的具体过程是这样的：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/3.png" alt></p><p><strong>make解析makefile的流程如下：</strong></p><p>假设有makefile内容如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">终极目标：依赖A  依赖B 依赖C</span><br><span class="line">    终极目标命令</span><br><span class="line"></span><br><span class="line">依赖A：子依赖A1 子依赖A2 </span><br><span class="line">    依赖A命令</span><br><span class="line"></span><br><span class="line">依赖B：子依赖B1 子依赖B2 </span><br><span class="line">    依赖B命令</span><br><span class="line"></span><br><span class="line">依赖C：子依赖C1 子依赖C2 </span><br><span class="line">    依赖C命令</span><br></pre></td></tr></table></figure></div><p><strong>过程一，以终极目标为树根，解析出整颗依赖树：</strong></p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/4.png" alt></p><p><strong>过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则：</strong></p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/5.png" alt></p><hr><h1 id="三-Makefile基本概念实例"><a href="#三-Makefile基本概念实例" class="headerlink" title="三.Makefile基本概念实例"></a>三.Makefile基本概念实例</h1><p>通过构建一个简单的c语言项目工程(project_simple)来理解makefile的基本概念。</p><p>project_simple的整体目录结构：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/6.png" alt></p><h2 id="1-编写文件代码"><a href="#1-编写文件代码" class="headerlink" title="1.编写文件代码"></a>1.编写文件代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple.c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is simple project!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="2-Makefile文件编写"><a href="#2-Makefile文件编写" class="headerlink" title="2.Makefile文件编写"></a>2.Makefile文件编写</h2><p>最后就是要编写makefile了，一般在编写makefile之前都需要先分析清楚整个工程各个模块的依赖关系，及相应的生成命令。project_simple工程最终生产的是一个叫simple的可执行文件，而该可执行文件是使用gcc命令编译main.c和simple.c生成的。</p><p>因此整个工程的关系依赖图，如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/7.png" alt></p><p>因此Makefile这么写：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">simple: main.c simple.c</span></span><br><span class="line">    gcc -o simple main.c simple.c</span><br></pre></td></tr></table></figure></div><h2 id="3-运行验证Makefile"><a href="#3-运行验证Makefile" class="headerlink" title="3.运行验证Makefile"></a>3.运行验证Makefile</h2><h3 id="能否编译出可执行的simple"><a href="#能否编译出可执行的simple" class="headerlink" title="能否编译出可执行的simple"></a>能否编译出可执行的simple</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">pwd</span>        <span class="comment">#查看当前路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译前当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make       <span class="comment">#编译simple项目</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译结果</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./simple   <span class="comment">#执行simple可执行文件</span></span></span><br></pre></td></tr></table></figure></div><p>过程及结果如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/8.png" alt></p><h3 id="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"><a href="#已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作" class="headerlink" title="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"></a>已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt <span class="comment">#查看当前项目中各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make   <span class="comment">#再次执行编译，查看是否会执行编译命令</span></span></span><br></pre></td></tr></table></figure></div><p>过程及结果如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/9.png" alt></p><h3 id="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"><a href="#已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件" class="headerlink" title="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"></a>已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#对比当前项目各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch main.c <span class="comment">#将main.c文件的时间戳修改至最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看main.c的时间戳是否最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make         <span class="comment">#执行编译命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看simple的时间戳是否被更新至最新</span></span></span><br></pre></td></tr></table></figure></div><p>过程及结果如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/10.png" alt></p><hr><h1 id="四-Makefile语法"><a href="#四-Makefile语法" class="headerlink" title="四.Makefile语法"></a>四.Makefile语法</h1><p>完整的makefile所包含的语法模块：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/11.png" alt></p><h2 id="1-通过complicated项目来进行学习Makefile语法"><a href="#1-通过complicated项目来进行学习Makefile语法" class="headerlink" title="1.通过complicated项目来进行学习Makefile语法"></a>1.通过complicated项目来进行学习Makefile语法</h2><p>构建一个名为project_complicated的项目工程，目录结构如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/12.png" alt></p><p>编写源代码文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, HELLO_STRING);</span><br><span class="line">    complicated();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_STRING <span class="meta-string">&quot;Hello !&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_NAME <span class="meta-string">&quot;complicated&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a %s porject!\n&quot;</span>, PROJECT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>项目依赖关系：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/13.png" alt></p><p>对比simple项目，发现complicated项目貌似只是多了一个头文件，但是依赖关系图却多了一层.o文件。</p><blockquote><p>在用gcc 编译出可执行文件的过程中是包含两个阶段的：编译阶段和链接阶段。</p></blockquote><p>上述的依赖关系图更加准确的反映出了整个项目的构建过程，这样据此写出来的makefile才能更加灵活及更具可扩展性，<strong>精确的分析清楚项目的依赖关系，是编写一个好的makefile的关键。</strong></p><p>编写Makefile文件:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div><p>验证过程及结果如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/14.png" alt></p><h2 id="2-使用注解提高可维护性"><a href="#2-使用注解提高可维护性" class="headerlink" title="2.使用注解提高可维护性"></a>2.使用注解提高可维护性</h2><ul><li>makefile中<code>#</code>字符后的内容被作为是注释内容（和shell脚本一样）处理。</li><li>注释行的结尾如果存在反斜线<code>\</code>，那么下一行也被作为注释行。</li><li>当在makefile中如果需要使用字符<code>#</code>时，可以使用反斜线加<code>#</code>（<code>\#</code>）来实现，其表示将<code>#</code>作为一字符而不是注释的开始标志。</li></ul><p>写一个例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个演示注释语法的makefile</span></span><br><span class="line"><span class="section">all: test #关于依赖的注释</span></span><br><span class="line"><span class="comment">#    echo &quot;Makefile for comment 1&quot;   这里是注释，不是命令</span></span><br><span class="line">    echo <span class="string">&quot;Makefile for comment 2&quot;</span> </span><br><span class="line"><span class="comment"># 这是一个关于test规则的 \</span></span><br><span class="line">  多行注释</span><br><span class="line"><span class="section">test:</span></span><br><span class="line"><span class="comment"># 没有反斜线\, #被当作注释的开始</span></span><br><span class="line">    echo this is a <span class="comment"># test rule1 </span></span><br><span class="line"><span class="comment"># 加上反斜线\, #被当作普通字符</span></span><br><span class="line">    echo this is a \<span class="comment"># test rule2 </span></span><br></pre></td></tr></table></figure></div><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/15.png" alt></p><blockquote><p>可以看出make在执行时一般情况下对于makefile中以<code>#</code>开始到行尾的内容都是直接忽略不做任何处理的。</p></blockquote><p>complicated项目Makefile:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.1</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div><h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。</p><p>变量定义的基本格式：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 赋值符 变量值</span><br></pre></td></tr></table></figure></div><blockquote><ul><li>变量名指的就是该变量的名字，是不包括<code>:</code>、<code>#</code>、<code>=</code>、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但<strong>定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义</strong>，并且这样命名的变量对于一些shell来说不能作为环境变量使用。<strong>变量名是大小写敏感的。</strong>变量<code>foo</code>、<code>Foo</code>和<code>FOO</code>指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。</li><li>变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。</li><li>赋值符，有<code>=</code> 、 <code>:=</code> 、 <code>?=</code>和 <code>+=</code>四种格式，其中<code>=</code> 和 <code>:=</code> 为基本定义类型， <code>?=</code>和 <code>+=</code>为基于<code>=</code>的扩展定义类型</li></ul></blockquote><p>一个在makefile中定义变量的例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br></pre></td></tr></table></figure></div><h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>当我们定义了一个变量之后，我们就可以在makfile中的<strong>目标</strong>、<strong>依赖</strong>、<strong>命令</strong>中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量<strong>被展开的过程</strong> )，替换掉变量的名字。</p><p>变量的引用有以下几种方式：</p><blockquote><ol><li><code>$&#123;变量名&#125;</code></li><li><code>$（变量名）</code></li><li><code>$单字符变量名</code> ，变量名仅包含一个字符，如<code>$@</code> 、<code>$^</code>等</li></ol></blockquote><p>一个在makefile中引用变量的例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program : <span class="variable">$(objects)</span>          <span class="comment">#在依赖中引用变量</span></span><br><span class="line">    gcc -o program $&#123;objects&#125; <span class="comment">#在命令中引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h           <span class="comment">#在目标中引用变量</span></span><br></pre></td></tr></table></figure></div><h3 id="变量的分类与赋值"><a href="#变量的分类与赋值" class="headerlink" title="变量的分类与赋值"></a>变量的分类与赋值</h3><p>根据变量定义时所使用的<strong>赋值操作符的不同</strong>，可以将变量分成两种类型(或者说是两种风格)：</p><p><code>递归展开式变量</code>和<code>直接展开式变量</code>；</p><blockquote><p>使用赋值操作符<code>=</code> 、 <code>+=</code> 和 <code>?=</code>定义的变量都是<strong>递归展开式变量</strong>，使用赋值操作符 <code>:=</code>定义的变量为<strong>直接展开式变量</strong> 。</p><p>两种变量类型的的最根本区别在于：<strong>变量值的求值时机</strong>，递归式变量的求值时机在于<strong>变量被引用时</strong>，直接展开式的求值时机在于<strong>变量被定义时</strong>。</p></blockquote><p>编写Makefile实例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo1 = <span class="variable">$(bar)</span>   <span class="comment">#递归展开式变量</span></span><br><span class="line">foo2 := <span class="variable">$(bar)</span>  <span class="comment">#直接展开式变量</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;foo1 is <span class="variable">$(foo1)</span>, foo2 is <span class="variable">$(foo2)</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p>然后，使用 <code>$ make -f variabletype.mk</code> 执行variabletype.mk，演示及结果如下：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/16.png" alt></p><p>由于变量<code>foo1</code>的变量值是在执行<code>echo</code>命令时才求的值，所以<code>foo1</code>的值被递归的展开为<code>Huh?</code>； 而变量<code>foo2</code>的变量值在定义时就被求值了，此时由于变量<code>bar</code>的值为空，因此<code>foo2</code>的值也为空。</p><blockquote><p><strong>注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败</strong></p></blockquote><p><code>+=</code> 和 <code>?=</code>是基于<code>=</code>扩展而来的两种变量赋值操作符；</p><p><code>+=</code> 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bar = foo1   </span><br><span class="line">bar += foo2  <span class="comment">#追加赋值，bar的值将为 foo1 foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure></div><p><code>?=</code>称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bar1 = foo1</span><br><span class="line">bar1 ?= foo2  <span class="comment"># bar1 的值还是foo1</span></span><br><span class="line">bar2 ?= foo2  <span class="comment"># bar2 的值为foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:  </span></span><br><span class="line">    echo <span class="string">&quot;bar1 is <span class="variable">$(bar1)</span>, bar2 is <span class="variable">$(bar2)</span>&quot;</span> </span><br></pre></td></tr></table></figure></div><h3 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h3><p>在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。</p><ul><li>自动化变量</li></ul><p>所谓自动化变量，<strong>就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量</strong>，一般情况下常用的有以下几个自动化变量：</p><blockquote><p><code>$@</code> — 代表规则中的目标文件名</p><p><code>$&lt;</code> — 代表规则的第一个依赖的文件名</p><p><code>$^</code> — 代表规则中所有依赖文件的列表，文件名用空格分割</p></blockquote><p>Makefile实例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: first second third</span></span><br><span class="line">    echo <span class="string">&quot;\$<span class="variable">$@</span> = <span class="variable">$@</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$^</span> = <span class="variable">$^</span>&quot;</span></span><br><span class="line"></span><br><span class="line">first second third:</span><br></pre></td></tr></table></figure></div><blockquote><ol><li><script type="math/tex; mode=display">`字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给`echo`命令执行，需要使用`$</script></li><li><code>$@</code>在bash shell中也有特殊用途，因此如果希望<code>echo</code>命令在bash中正常输出<code>$@</code>， 需要加上<code>\</code>字符</li><li>该makefile的最后一行<code>first second third:</code> 看起来有点奇怪，这是一条<strong>没有依赖和命令的多目标规则</strong>，读者可自行将它删除看有什么效果，并思考原因。</li></ol></blockquote><p>运行结果:</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/17.png" alt></p><p>删除<code>first second third</code>后的运行结果:</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/18.png" alt></p><h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul><li>变量的分类与赋值</li></ul><p>对于一个c已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为<code>$(VAR:A=B)</code>或者<code>$&#123;VAR:A=B&#125;</code>，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources := a.c b.c c.c d.d</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;objects = <span class="variable">$(objects)</span>&quot;</span></span><br></pre></td></tr></table></figure></div><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/19.png" alt></p><p>使用变量改进complicated项目的makefile(v1.2)：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.2</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div><h3 id="多目标规则与多规则目标"><a href="#多目标规则与多规则目标" class="headerlink" title="多目标规则与多规则目标"></a>多目标规则与多规则目标</h3><h4 id="多目标规则"><a href="#多目标规则" class="headerlink" title="多目标规则"></a>多目标规则</h4><p>多目标规则，可以简单的理解为是一种将多条具有</p><ul><li><strong>相同依赖</strong></li><li><strong>相同生成命令</strong></li></ul><p>的规则，合并成一条规则的语法，其基本格式为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets...: prerequisites...</span></span><br><span class="line">    commands</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><p>假设有以下Makefile：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target1: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target2: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div><p>利用多目标规则，可以将makefile改写成 makefile 文件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用多目标规则合并 target1 和target2的规则</span></span><br><span class="line">target1 target2: dep</span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div><p>运行结果:</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/20.png" alt></p><p>可以观察到，虽然多目标规则中要求命令必须相同，但是配合上自动化变量的使用，就是可以针对不同的目标有不同的执行结果。</p><h4 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h4><p>Makefile中，一个目标可以同时出现在多条规则中。</p><blockquote><p>这种情况下，此目标文件的所有依赖文件将会被合并成此目标一个依赖文件列表，其中任何一个依赖文件比目标更新（比较目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目标。</p><p>对于一个多规则的目标，<strong>重建此目标的命令只能出现在一个规则中</strong>（可以是多条命令）。</p><p>如果多个规则同时给出重建此目标的命令，make将使用最后一个规则的命令，同时提示错误信息。</p></blockquote><h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>仔细观察complicated项目中的两条子规则：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div><p>首先<strong>它们的命令是一样的</strong>，其次它们目标依赖关系有点相似(目标都是以.o结尾的文件，依赖都是以.c结尾的文件)。<font color="red">对于这种长得很像的规则，makefile提供了一种称为<strong>静态模式规则</strong>的规则来帮助我们简化规则的编写。</font></p><p>静态模式规则：</p><blockquote><p>可以理解为一种特殊的多目标规则，它仅要求多条规则具有相同的命令，而依赖可以不完全一样。</p></blockquote><p>静态模式规则，其基本语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...</span><br><span class="line">    COMMANDS</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><p>其大致意思就是，用<code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>描述的模式，从<code>TARGETS ...</code>取值来形成一条条规则，所有规则的命令都用<code>COMMANDS</code>。</p><p><code>TARGETS ...</code>代表具有相同模式的规则的目标列表，在我们的项目中就是main.o和complicated.o，我们可以直接引用我们先前定义的objects变量。</p><p><code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>部分定义了，如何为目标列表中的目标，生成依赖；<code>TARGET-PATTERN</code>称为目标模式，<code>PREREQ-PATTERNS</code>称为依赖模式；目标模式和依赖模式中，一般需要包含模式字符<code>%</code>。</p><p>目标模式的作用就是从目标列表中的目标匹配过滤出需要的值，目标模式中的字符<code>%</code>表示在匹配过滤的过程中不做过滤的部分，目标模式中的其他字符表示要与目标列表中的目标精确匹配，例如，目标模式<code>%.o</code>， 表示从目标列表的目标中匹配所有以<code>.o</code>结尾的目标，然后过滤掉匹配目标的<code>.o</code>部分， 因此目标<code>main.o</code>经过目标模式<code>%.o</code>匹配过滤后，得到的输出就是<code>main</code>。</p><p>依赖模式的作用就是表示要如何生成依赖文件。具体的生成过程，就是使用目标模式过滤出来的值，替换依赖模式字符<code>%</code>所表示的位置。因此，如果依赖模式为<code>%.c</code>， 则使用上述例子过滤出来的<code>main</code>来替换字符<code>%</code>， 最终得到依赖文件<code>main.c</code></p><p>因此，可以用静态模式规则来简化我们的complicated项目：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静态模式规则简化complicated makefile</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div><h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>complicated项目编译完成后，会有可执行文件及中间目标文件，有时出于某些需求，需要将编译生成的文件都删除，让整个项目回到最初的状态。修改后的Makefile如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">executbale := complicated</span><br><span class="line">sources := main.c complicated.c</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(object)</span>:%.o:%.c</span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div><p> 运行结果:</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/21.png" alt></p><p>上述的clean规则，貌似能正常工作，但其实是存在bug的，当目录下刚好存在一个叫做clean的文件时，事情就没那么顺利了：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/22.png" alt></p><blockquote><p>出现以上问题的原因是，当编译目录下存在clean文件时，由于clean规则没有依赖，所以clean文件的时间戳永远显得都是最新的，故其命令也无法被执行，这时我们就得请伪目标出手帮助了。</p></blockquote><p>当我们将一个目标定义成伪目标时，意味着它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。</p><p>定义一个伪目标的基本语法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: &lt;伪目标&gt;</span></span><br></pre></td></tr></table></figure></div><p>因此我们以定义complicated项目的clean目标，为伪目标，如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div><p>这样目标<code>clean</code>就是一个伪目标，无论当前目录下是否存在<code>clean</code>这个文件。我们输入<code>make clean</code>之后。<code>rm</code>命令都会被执行。</p><p>运行结果：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/23.png" alt></p><h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><h3 id="命令的回显"><a href="#命令的回显" class="headerlink" title="命令的回显"></a>命令的回显</h3><p>通常，make在执行命令行之前会把要执行的命令行进行输出，如以下makefile：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div><p>在执行make时，其输出：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">  echo &quot;Hello world!&quot;</span><br><span class="line">  Hello world!</span><br></pre></td></tr></table></figure></div><p><strong>关闭命令回显有以下几种方式：</strong></p><ol><li>每个需要关闭回显的命令行前加上”@”字符，上述例子关闭回显：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div><ol><li>执行make时带上参数<code>-s</code>或<code>--slient</code>禁止所有执行命令的显示</li><li>在Makefile中使用没有依赖的特殊目标<code>.SILENT</code>也可以禁止所有命令的回显</li></ol><h3 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>在Makefile中<strong>书写在同一行中的多个命令属于一个完整的shell命令行</strong>，<strong>书写在独立行的一条命令是一个独立的shell命令行</strong>。所以需要注意：在一个规则的命令中，命令行<code>cd</code>改变目录不会对其后的命令的执行产生影响。就是说其后的命令执行的工作目录不会是之前使用<code>cd</code>进入的那个目录。如果要实现这个目的<strong>，</strong>就不能把<code>cd</code>和其后的命令放在两行来书写。而应该把这两条命令写在一行上，用分号分隔。这样它们才是一个完整的shell命令行。</p><p>对比以下例子两个规则的输出，编写makefile 文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target1:</span></span><br><span class="line">    @echo <span class="string">&quot;target1&quot;</span></span><br><span class="line">    @cd ~</span><br><span class="line">    @pwd</span><br><span class="line"></span><br><span class="line"><span class="section">target2:</span></span><br><span class="line">    @echo <span class="string">&quot;target2&quot;</span></span><br><span class="line">    @cd ~; pwd</span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/24.png" alt></p><h3 id="命令执行的错误处理"><a href="#命令执行的错误处理" class="headerlink" title="命令执行的错误处理"></a>命令执行的错误处理</h3><p>通常情况下，规则中的每一条命令在运行结束后，make都会检测命令执行的返回状态，如果返回成功，就执行下一条命令；命令出错（返回状态非0），make就会放弃对当前规则的执行，或者终止对当前makefile的解析执行。</p><p>在一些情况下，规则中的一个命令的执行失败并不代表规则执行的错误。为了忽略一些无关紧要的命令执行失败的情况，我们可以在命令之前加一个减号<code>-</code>，来告诉make忽略此命令的执行失败检查。</p><p>在更加深入的认识了makefile的规则后，我们complicated项目的makefile(v1.3)就可以这样写了：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.3</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div><h2 id="5-内嵌函数"><a href="#5-内嵌函数" class="headerlink" title="5.内嵌函数"></a>5.内嵌函数</h2><p>make的内嵌函数为我们提供了处理文件名、变量、文本和命令的方法。使我们的Makefile更为灵活和健壮。我们可以在需要的地方调用函数来处理指定的文本（参数），函数在调用它的地方被替换为它的处理结果。函数调用（引用）的展开和变量引用的展开方式类似：</p><p>函数调用方式1:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(FUNCTION ARGUMENTS)</span></span><br></pre></td></tr></table></figure></div><p>函数调用方式2：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;FUNCTION ARGUMENTS&#125;</span><br></pre></td></tr></table></figure></div><h3 id="内嵌函数的分类"><a href="#内嵌函数的分类" class="headerlink" title="内嵌函数的分类"></a>内嵌函数的分类</h3><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/25.png" alt></p><p><strong>使用wildcard函数改进complicated项目makefile:</strong></p><p>wildcard函数，其使用范式：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure></div><blockquote><p>函数名称：wildcard</p><p>函数功能：列出当前目录下所有符合模式“PATTERN”格式的文件名。</p><p>返回值：空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</p><p>函数说明：“PATTERN”使用shell可识别的通配符，包括<code>?</code>（单字符）、<code>*</code>（多字符）等。</p></blockquote><p>示例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure></div><p>返回值为当前目录下所有.c源文件列表。</p><p>我们可以引进wildcard函数，改进complicated项目的makefile，使其能够自动扫描当前目录下的源文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.4</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 引进wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sourcecs := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> </span><br></pre></td></tr></table></figure></div><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/26.png" alt></p><h2 id="6-自动生成依赖关系"><a href="#6-自动生成依赖关系" class="headerlink" title="6.自动生成依赖关系"></a>6.自动生成依赖关系</h2><p>complicated项目的makefile已经完成的比较完善了，但还存在一个问题，当更新头文件complicated.h的内容后，执行make时，项目并不会重新编译。</p><p>出现以上问题的根本原因是，我们的makefile还没能精确的反映整个项目工程的依赖关系！很明显，项目的依赖关系应该加入对于头文件的依赖，即如下图：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/27.png" alt></p><p>根据上述依赖关系，我们可以在makefile加上如下规则：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(objects)</span>: complicated.h</span><br></pre></td></tr></table></figure></div><p>上述新增规则，是一条多目标规则，它与之前的静态模式规则，又组成了多规则目标，可自行思考其工作原理。</p><p>上述规则加入虽然能解决我们的问题，但是对于大型复杂的项目，这种需要我们逐个去分析头文件被依赖的关系，几乎是不可能的。所以我们需要工具来帮我们做这个事。下面我们来介绍如何实现自动生成依赖关系。</p><p>gcc提供了这样的功能，帮助我们分析一个文件对其他文件的依赖关系列表。在执行gcc时带上<code>-MM</code>选项时，gcc工具就会列出指定文件对其他文件的依赖关系列表。直接来看例子：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/28.png" alt></p><p>接下来要考虑的问题就是如何将gcc的输出导入到makefile中了。</p><p>makefile支持使用<code>sinclude</code>关键字将指定文件导入到当前的makefile当中，它的作用与C语言的<code>#include</code>预处理命令是一样的。使用方式<code>sinclude &lt;other_makefiles&gt;</code>。</p><p>因此，可以将gcc对于源文件的依赖关系分析输出到某个文件(可以称为依赖描述文件，一般命名为与源文件同名但以.d结尾的文件)当中，然后再将依赖描述文件导入到makefile中。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖描述文件列表</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br></pre></td></tr></table></figure></div><p>当使用<code>sinclude</code>关键字向当前makefile导入文件时，如果所导入的文件不存在，make会试图去执行可以生产导入文件的规则去生产被导入的文件，然后再执行导入。</p><p>因此可以使用静态模式规则，让make在执行时，去调用gcc生成依赖关系文件，可以这么写：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    gcc -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div><p>因此，complicated项目的最终makefile可以这么写：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.5</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"><span class="comment"># 6. 加入自动规则依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sources := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动规则依赖</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div><p>运行结果：</p><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/29.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
      <category term="Makefile" scheme="https://ZYBO_o.github.io/tags/Makefile/"/>
    
  </entry>
  
</feed>
