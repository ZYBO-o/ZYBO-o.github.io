<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZYBO_o&#39;s Blogs</title>
  
  <subtitle>Follow Excellence</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zybo_o.github.io/"/>
  <updated>2020-11-10T01:59:40.488Z</updated>
  <id>https://zybo_o.github.io/</id>
  
  <author>
    <name>ZYBO_o</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈工大学习—设备驱动与文件系统</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-11-10T01:56:13.000Z</published>
    <updated>2020-11-10T01:59:40.488Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="设备驱动与文件系统" scheme="https://ZYBO_o.github.io/tags/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—内存管理</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-11-10T01:55:59.000Z</published>
    <updated>2020-11-10T01:59:24.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存管理" scheme="https://ZYBO_o.github.io/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—进程与线程</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-11-10T01:55:51.000Z</published>
    <updated>2020-11-10T01:59:05.352Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程与线程" scheme="https://ZYBO_o.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>哈工大学习—操作系统基础</title>
    <link href="https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>https://zybo_o.github.io/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-10T01:55:44.000Z</published>
    <updated>2020-11-10T01:58:47.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统基础" scheme="https://ZYBO_o.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-I/O和文件</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-I-O%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-I-O%E5%92%8C%E6%96%87%E4%BB%B6/</id>
    <published>2020-11-10T01:54:56.000Z</published>
    <updated>2020-11-10T01:58:18.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="I/O和文件" scheme="https://ZYBO_o.github.io/tags/I-O%E5%92%8C%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-调度</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%B0%83%E5%BA%A6/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%B0%83%E5%BA%A6/</id>
    <published>2020-11-10T01:54:40.000Z</published>
    <updated>2020-11-10T01:57:16.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="调度" scheme="https://ZYBO_o.github.io/tags/%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-内存</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E5%86%85%E5%AD%98/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E5%86%85%E5%AD%98/</id>
    <published>2020-11-10T01:54:30.000Z</published>
    <updated>2020-11-10T01:57:58.230Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="内存" scheme="https://ZYBO_o.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-进程</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-11-10T01:54:25.000Z</published>
    <updated>2020-11-10T02:07:56.463Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-进程描述和控制"><a href="#一-进程描述和控制" class="headerlink" title="一.进程描述和控制"></a>一.进程描述和控制</h1><h2 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="(一).什么是进程"></a>(一).什么是进程</h2><ul><li><strong>1.为什么操作系统需要提出进程的概念</strong><ul><li>有了应用程序，系统软件和资源的概念，就可以讨论操作系统怎样以一个有序的方式管理程序的执行，而执行中的程序就是进程。所以提出进程的概念来更好的管理。</li></ul></li></ul><p><br></p><ul><li><strong>2.什么是进程(概念)</strong><ul><li>一组指令序列的执行+ 一个当前状态+相关的系统资源集</li><li>进程由 程序代码+相关数据+进程控制块 组成</li></ul></li></ul><p><br></p><ul><li><strong>3.进程的表征元素有哪些</strong><ul><li>标识符</li><li>状态</li><li>优先级</li><li>程序计数器：下一条即将被执行的指令的地址</li><li>内存指针</li><li>I/O状态信息</li><li>记账信息：处理器时间的总和, 使用的时钟数总和,时间限制,记账号</li></ul></li></ul><p><br></p><ul><li><strong>4.什么是进程控制块</strong><ul><li>包含上述表征元素的数据结构，该控制块由操作系统创建和管理。</li></ul></li></ul><p><br></p><h2 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2.进程状态"></a>2.进程状态</h2><ul><li><p><strong>1.为什么需要提出进程状态模型，以及进程状态模型发展历程</strong></p><ul><li><p>操作系统的基本职责是控制进程的执行，这包括交替执行的方式和给进程分配资源。而在设计控制进程的程序时吗，第一步就是描述进程所展现出的行为。<strong>所以就是为了更高的管理进程。</strong></p></li><li><p><strong>两状态进程模型</strong></p><ul><li><strong>进程的创建：</strong>1.操作系统建立用于管理该进程的数据结构。2.在内存中给它分配地址空间。通常有4个事件(新的批处理作业，交互登录，给操作系统提供一项服务，现有进程派生)导致创建一个进程。</li><li><strong>进程终止：</strong>批作业中应该包含一个<strong><code>Halt</code>指令</strong>(产生中断警告操作系统进程已完成) 或 <strong>用于终止操作系统显式服务调用来终止</strong>。导致进程终止的原因很多。</li><li><strong>局限性：</strong>存在这一些处于非运行状态但已经就绪等待执行的进程，而同时存在一些处于阻塞状态等待I/O操作结束的进程。所以对于使用单个排队队列，调度器不能只考虑队列中最老的进程，需要扫描整个列表，查找那些未被阻塞且在队列中时间最长的进程。</li><li><strong>解决方法：</strong> 五状态进程</li></ul></li><li><p><strong>五状态进程模型</strong></p><ul><li>将两状态模型中的未运行态分成：就绪和阻塞这两个状态。增加 新建态 和 退出态。</li><li>操作系统分两步定义新建态：<ul><li>OS执行一些必须的辅助工作，将标识符关联到进程，分配和创建管理进程所需要的所有表，这些信息存在内存中。</li><li>进程本身还未进入内存，即即将需要执行的代码还不在内存，也没有给这个程序相关的数据分配空间，通常在外存磁盘中。</li></ul></li><li>进程退出系统也分为两步：<ul><li>进程终止，切换为退出态，与作业相关的表与其他信息保存在内存中。</li><li>一旦其他实用程序提取了内存中关于这个进程的信息，操作系统就不再保存，该进程将从系统中删除。</li></ul></li><li><strong>局限性：</strong>处理器处理速度比I/O要快得多，以至于内存中所有进程都在等待I/O的情况很常见，因此即使是多道程序设计，大多数时候处理器仍可能处于空闲状态。</li><li><strong>解决方案：</strong>把内存中某个进程的一部分或者全部移到磁盘中。当内存中没有处于就绪态的进程时，操作系统就把被阻塞的进程换出到磁盘中的“挂起队列”，然后取出挂起队列中的另一个进程或者接受一个新进程的请求，将其纳入内存运行。</li></ul></li><li><p><strong>引入挂起状态的进程模型</strong></p></li></ul></li></ul><p><br></p><ul><li><strong>2.描述进程各个状态</strong><ul><li>创建</li><li>终止</li><li>就绪</li><li>阻塞</li><li>运行</li><li>挂起(就绪/挂起，阻塞挂起)</li></ul></li></ul><p><br></p><h2 id="5-操作系统的执行"><a href="#5-操作系统的执行" class="headerlink" title="5.操作系统的执行"></a>5.操作系统的执行</h2><ul><li><strong>1.操作系统是一个进程吗？如果是，如何控制它？</strong> <ul><li><strong>无进程的内核</strong><ul><li>在所有进程之外执行操作系统内核。操作系统代码是作为一个在特权模式下工作的独立实体被执行。</li></ul></li><li><strong>在用户进程中执行</strong><ul><li>在用户程序的上下文中执行所有操作系统软件。在任何时刻，操作系统管理着进程映像，每个进程映像不仅包括用户进程控制块的内容，还包括内核程序的程序，数据和栈区域。</li></ul></li><li><strong>基于进程的操作系统</strong><ul><li>把操作系统作为一组系统进程来实现。</li></ul></li></ul></li></ul><hr><h1 id="二-线程，对称多处理和微内核"><a href="#二-线程，对称多处理和微内核" class="headerlink" title="二.线程，对称多处理和微内核"></a>二.线程，对称多处理和微内核</h1><h2 id="一-进程和线程"><a href="#一-进程和线程" class="headerlink" title="(一).进程和线程"></a>(一).进程和线程</h2><ul><li><strong>1.线程有哪些功能特性？</strong><ul><li><strong>线程状态</strong><ul><li>无挂起态。</li></ul></li><li><strong>线程同步</strong><ul><li>一个进程中的所有线程共享同一个地址空间和资源。所以一个线程对资源的任意修改都会影响同一个进程中其他线程的环境。所以需要同步各种线程中的活动，以便它们互不干涉且不破坏数据结构。</li></ul></li></ul></li></ul><p><br></p><ul><li><strong>2.用户级线程和内核级线程的描述</strong><ul><li><strong>用户级线程：</strong><ul><li>在一个纯粹的用户线程软件中，有关线程管理的所有工作都是由应用程序完成的，内核意识不到线程的存在。任何程序都可以通过使用线程库[用于用户级线程管理的一个例程包]被设计成多线程程序。</li><li><strong>使用用户级线程而不是内核级线程的优点：</strong><ul><li>线程切换不需要内核态特权，因此进程不需要为了线程管理而切换到内核态吗，节约了状态转换的开销。</li><li>调度可以是应用程序相关的，可以做到为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序。</li><li>用户级线程可以在任何操作系统执行，不需要为对底层内核进行修改以支持用户级线程。</li></ul></li><li><strong>用户级线程对于内核级线程的缺点：</strong><ul><li>当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中所有线程都会被阻塞。</li><li>在纯粹的用户级线程策略中，一个多线程应用程序不能利用多处理技术。因为内核一次只把一个进程分配给处理器，因此一个进程中只有一个线程可以执行。</li></ul></li></ul></li><li><strong>内核级线程：</strong><ul><li>在一个纯粹的内核级线程软件中，有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口(API)。</li><li><strong>内核线程的优点：</strong><ul><li>内核可以同时把同一个进程中的多个线程调度到多个处理器中。</li><li>如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程。</li><li>内核例程自身也是可以使用多线程的。</li></ul></li><li><strong>内核线程的缺点：</strong><ul><li>在把控制从一个线程传送到同一个进程中的另一个线程时，需要到内核的状态切换。</li></ul></li></ul></li><li><strong>可以按照特定的应用程序需求来组合用户级线程和内核级线程。</strong></li></ul></li></ul><p><br></p><h2 id="二-对称多处理"><a href="#二-对称多处理" class="headerlink" title="(二).对称多处理"></a>(二).对称多处理</h2><ul><li><strong>1.最基本的对于并行处理器系统的分类</strong><ul><li><strong>单指令单数据流</strong></li><li><strong>单指令多数据流</strong></li><li><strong>多指令单数据流</strong></li><li><strong>多指令多数据流</strong><ul><li>每个处理器都有自己的专用内存——<strong>集群</strong></li><li>处理器共用一个内存，通过该内存相互通信——<strong>共享内存多处理器</strong><ul><li><strong>主/从</strong><ul><li>内核只在指定的处理器上执行，其他处理用户程序。缺点明确：1.主处理器失效会导致整个系统失效。2.主处理器会成为性能瓶颈</li></ul></li><li><strong>对称多处理系统</strong><ul><li>内核可以在任何处理器上执行，并且通常是每个处理器从可用的进程或线程池中进行资金的调度工作。å</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="https://ZYBO_o.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OS Internals and Design Principles-操作系统概述</title>
    <link href="https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://zybo_o.github.io/2020/11/10/OS-Internals-and-Design-Principles-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-10T01:53:41.000Z</published>
    <updated>2020-11-10T01:56:47.502Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://ZYBO_o.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统概述" scheme="https://ZYBO_o.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅷ排序</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-12T03:54:09.000Z</published>
    <updated>2020-09-22T12:10:53.316Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="排序" scheme="https://ZYBO_o.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅶ查找</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-12T03:53:45.000Z</published>
    <updated>2020-04-12T04:08:16.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="查找" scheme="https://ZYBO_o.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅵ图</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</id>
    <published>2020-04-12T03:53:24.000Z</published>
    <updated>2020-04-12T04:07:58.443Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="图" scheme="https://ZYBO_o.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅴ树</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</id>
    <published>2020-04-12T03:53:15.000Z</published>
    <updated>2020-10-26T12:53:23.990Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h2><h3 id="1-需要掌握的定义："><a href="#1-需要掌握的定义：" class="headerlink" title="1.需要掌握的定义："></a>1.需要掌握的定义：</h3><ul><li>结点(根结点，双亲结点，子节点，兄弟结点)</li><li>子树和空树</li><li>结点的深度和高</li><li>有序树和无序树</li><li>森林</li><li>树的表示方法</li></ul><blockquote><p>对于结点ni，ni的深度是指<strong>从根到ni</strong>的唯一路径的长；ni的高是指<strong>从ni到一片树叶</strong>的最长路径的长。</p></blockquote><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/1.png" style="zoom:25%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图1：线性结构与树结构对比</div></center><p><br></p><h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二.二叉树"></a>二.二叉树</h2><h3 id="1-二叉树需要掌握的概念"><a href="#1-二叉树需要掌握的概念" class="headerlink" title="1.二叉树需要掌握的概念"></a>1.二叉树需要掌握的概念</h3><h4 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="(1).二叉树的定义"></a>(1).二叉树的定义</h4><ul><li>有序树</li><li>节点的度只能为0，1，2</li></ul><h4 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="(2).二叉树的性质"></a>(2).二叉树的性质</h4><ul><li>第$i$层最多有 $2^{i-1}$ 个结点。</li><li>若深度为$K$，则最多有$2^K-1$个结点。</li><li>终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$=$n_2$+1。</li></ul><blockquote><p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点(设为$n_1$)，那么总结点$n=n_0+n_1+n_2$。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数$n=B+1$。而分枝数是可以通过$n_1$和$n_2$表示的，即$B$=$n_1$+2<em>$n_2$。所以，n用另外一种方式表示为n=$n_1$+2</em>$n_2$+1。两种方式得到的n值组成一个方程组，就可以得出$n_0$=$n_2$+1。</p></blockquote><h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="(3).满二叉树"></a>(3).满二叉树</h4><ul><li><p>概念定义</p><ul><li>除了叶子结点外其余结点的度都为2，则为满二叉树。</li></ul></li><li><p>性质</p><ul><li>满二叉树中第i层的节点数为$2^n-1$个。</li><li>深度为k的满二叉树必有$2^k-1$个节点，叶子数为$2^k-1$。</li><li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li><li>具有n个节点的满二叉树的深度为 $log_2(n+1)$。</li></ul></li></ul><h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="(4).完全二叉树"></a>(4).完全二叉树</h4><ul><li>概念定义<ul><li>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，且<font color="red"><strong>最后一层的结点依次从左到右分布</strong></font>，则此二叉树被称为完全二叉树。</li></ul></li></ul><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/2.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图2：完全二叉树与非完全二叉树</div></center><ul><li>性质<ul><li>n 个结点的完全二叉树的深度为$⌊log_2n⌋+1$。</li><li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号,对于任意一个结点 i,完全二叉树还有以下几个结论成立:<ul><li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li><li>如果2*i&gt;n(总结点的个数)，则结点i肯定没有左孩子(为叶子结点)；否则其左孩子是结点2*i 。</li><li>如果2*i+1&gt;n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1。</li></ul></li></ul></li></ul><p><br></p><h3 id="2-二叉树的存储结构"><a href="#2-二叉树的存储结构" class="headerlink" title="2.二叉树的存储结构"></a>2.二叉树的存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="(1).顺序存储结构"></a>(1).顺序存储结构</h4><p>二叉树的顺序存储，指的是使用顺序表(数组)存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，<font color="red">如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树，然后从根节点开始，按照层次依次将树中节点存储到数组即可。</font></p><p>如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/3.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图3：普通二叉树的转换</div></center><p> <br></p><p>普通二叉树的数组存储状态如下图所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/4.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图4：普通二叉树的存储状态</div></center><p><br></p><h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="(2).链式存储结构"></a>(2).链式存储结构</h4><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/5.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图5：普通二叉树示意图</div></center><p>如图5所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图5对应的链式存储结构如图6所示：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/6.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图6：二叉树链式存储结构示意图</div></center><p>由图可知采用链式存储二叉树时，其节点结构由 3 部分构成：</p><ul><li>指向左孩子节点的指针（Left）；</li><li>节点存储的数据（Element）；</li><li>指向右孩子节点的指针（Right）；</li></ul><p>表示该节点结构的 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><br></p><h3 id="3-二叉树遍历介绍"><a href="#3-二叉树遍历介绍" class="headerlink" title="3.二叉树遍历介绍"></a>3.二叉树遍历介绍</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="(1).层序遍历"></a>(1).层序遍历</h4><p>通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/7.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图7：层次遍历二叉树示意图</div></center><h4 id="2-普通遍历"><a href="#2-普通遍历" class="headerlink" title="(2).普通遍历"></a>(2).普通遍历</h4><p>按照 “从上到下，从左到右” 的顺序遍历整棵二叉树，此种方式称为普通遍历。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/8.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图8：普通遍历二叉树示意图</div></center><p>在层次遍历中，整个遍历过程只经过各个节点一次，因此在层次遍历过程，每经过一个节点，都必须立刻访问该节点，否则错失良机，后续无法再对其访问。</p><p>而普通遍历方式则不同，通过观察图 7 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 7 中的节点 2 为例，如图 8 所示，它被经过了 3 次。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/9.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图9：遍历节点2的过程示意图</div></center><p>因此，在编程实现时可以设定真正访问各个节点的时机，换句话说，既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。这也就引出了以下 3 种遍历二叉树的算法：</p><ol><li><strong><font color="red">先序遍历</font>：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 9 中的 ①）；</strong></li><li><strong><font color="red">中序遍历</font>：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 9 中的 ②）；</strong></li><li><strong><font color="red">后序遍历</font>：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 9 中的 ③）；</strong></li></ol><h2 id="三-遍历二叉树代码实现"><a href="#三-遍历二叉树代码实现" class="headerlink" title="三.遍历二叉树代码实现"></a>三.遍历二叉树代码实现</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>二叉树先序遍历的实现思想是：</p><ol><li>访问根节点；</li><li>访问当前节点的左子树；</li><li>若当前节点无左子树，则访问当前节点的右子树；</li></ol><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/10.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图10：二叉树</div></center><p>因此，图 10 中二叉树采用先序遍历得到的序列为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></div><h4 id="1-递归先序遍历"><a href="#1-递归先序遍历" class="headerlink" title="(1).递归先序遍历"></a>(1).递归先序遍历</h4><p>前序的规则就是<code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>.在调用递归前进行节点操作。对于先序，就是先访问(输出)该节点。而递归左，递归右侧，会优先递归左侧。<code>直到没有左节点</code>。才会停止。访问次序大致为：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/11.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图11：递归先序遍历过程</div></center><h4 id="2-非递归优先遍历"><a href="#2-非递归优先遍历" class="headerlink" title="(2).非递归优先遍历"></a>(2).非递归优先遍历</h4><p>非递归的先序利用栈的性质替代递归，因为<code>递归有时候在效率</code>方面不是令人满意的。<br>因为栈的顺序为后进先出。递归是左递归，右递归。<strong>所以利用栈要相反。</strong>利用递归的思路，需要先把右节点进栈，再遍历(输出)左节点。然后循环一直到最后，达到和递归顺序相仿效果。</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/12.jpg" style="zoom:70%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图12：非递归先序遍历过程</div></center><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h4><p><strong>递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionPreOrderTraverse</span><span class="params">( Tree T )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DisplayElement( T );<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Left );<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Right );<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>非递归优先遍历：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span> = CreateStack( <span class="number">20</span> );<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    Tree p;<span class="comment">//临时指针</span></span><br><span class="line">    Push( T ,<span class="built_in">stack</span> );<span class="comment">//根结点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">stack</span>-&gt;TopOfStack != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Top( <span class="built_in">stack</span> );<span class="comment">//取栈顶元素</span></span><br><span class="line">        Pop( <span class="built_in">stack</span> );<span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            DisplayElement( p );<span class="comment">//调用结点的操作函数</span></span><br><span class="line">            <span class="comment">//如果该结点有右孩子，右孩子进栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;Right) &#123;</span><br><span class="line">                Push(  p-&gt;Right ,<span class="built_in">stack</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;Left;<span class="comment">//一直指向根结点最后一个左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><h2 id="四-二叉树查找树"><a href="#四-二叉树查找树" class="headerlink" title="四.二叉树查找树"></a>四.二叉树查找树</h2><h2 id="五-平衡树-AVL"><a href="#五-平衡树-AVL" class="headerlink" title="五.平衡树(AVL)"></a>五.平衡树(AVL)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>AVL树本质上是<strong>一棵二叉查找树</strong>，但是它又具有以下特点：<strong><font color="red">它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font></strong>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树。</p><p>平衡二叉树和非平衡二叉树对比的例图：</p><center class="half">     <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/13.png" style="zoom:40%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图13：左边为一般二叉树，右边为二叉查找树</div></center><p><strong>平衡因子(bf)：</strong>结点的左子树的深度减去右子树的深度，那么显然-1&lt;=bf&lt;=1;</p><h3 id="2-AVL的作用"><a href="#2-AVL的作用" class="headerlink" title="2.AVL的作用"></a>2.AVL的作用</h3><p>对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度 $ O(log_2n)$ 同时也由此而决定。<strong>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 $O(n)$  </strong>。</p><p>所以可以通过随机化建立二叉搜索树来尽量的避免这种情况，<strong><font color="red">但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</font></strong></p><p>例如：按顺序将一组数据1,2,3,4,5,6分别插入到一棵空二叉查找树和AVL树中，插入的结果如下图：</p><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/14.png" style="zoom:30%"><br>  <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/15.png" style="zoom:40%"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图14：左边为二叉搜索树，右边为二叉平衡树</div></center></p><p>由上图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<strong>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是 $O(N)$ ，而AVL树就不会出现这种情况，树的高度始终是 $O(lgN)$ .高度越小，对树的一些基本操作的时间复杂度就会越小。这也就是引入AVL树的原因。</strong></p><h3 id="3-AVL的操作"><a href="#3-AVL的操作" class="headerlink" title="3.AVL的操作"></a>3.AVL的操作</h3><p>AVL树的操作基本和二叉查找树一样，这里关注的是两个变化很大的操作：<strong>插入</strong>和<strong>删除！</strong></p><p>AVL树不仅是一颗二叉查找树，它还有其他的性质。<strong>如果按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以要做一些特殊的处理，包括：单旋转和双旋转！</strong></p><h4 id="1-单选转"><a href="#1-单选转" class="headerlink" title="(1).单选转"></a>(1).单选转</h4><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/16.png" style="zoom:90%"><br> <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/17.png" style="zoom:100%;"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">图15：单选转</div></center></p><p>显示单选转</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="树" scheme="https://ZYBO_o.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅳ串</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</id>
    <published>2020-04-12T03:52:59.000Z</published>
    <updated>2020-04-12T04:07:33.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="串" scheme="https://ZYBO_o.github.io/tags/%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2020-04-12T03:52:40.000Z</published>
    <updated>2020-04-12T04:07:25.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="栈和队列" scheme="https://ZYBO_o.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2020-04-12T03:52:15.000Z</published>
    <updated>2020-09-25T02:21:22.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p><blockquote><p><strong>性质：</strong></p><ul><li>线性表中的数据元素之间是有顺序的。</li><li>线性表中的数据元素个数是有限的。</li><li>线性表中的数据元素的类型必须相同。</li></ul></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div><hr><p>&lt;/br&gt;</p><h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png" style="zoom:45%;">. </p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p><ul><li>创建</li><li>分配内存</li><li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li><li>返回表的地址</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/6.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>直接通过数组下标的方式获取元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>把最后一个元素到插入位置的元素后移一个位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/3.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断删除位置是否合法</li><li>将元素取出</li><li>将删除位置后的元素分别向前移动一个位置</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/4.png" style="zoom:50%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.将元素取出</span></span><br><span class="line">ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line"><span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.线性表长度减1</span></span><br><span class="line"><span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-顺序存储的优缺点"><a href="#3-顺序存储的优缺点" class="headerlink" title="(3).顺序存储的优缺点"></a>(3).顺序存储的优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/7.png" style="zoom:40%;"></p><hr><p>&lt;/br&gt;</p><h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/8.png" style="zoom:50%;"></p><p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/9.png" style="zoom:30%;"></p><p><strong>链表的基本概念:</strong></p><ul><li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li><li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li><li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/10.png" style="zoom:40%;"></p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/11.png" style="zoom:60%;"></p><p><strong>C语言用结构体来定义链表中的结点：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/13.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p><ul><li><p>判断线性表是否合法</p></li><li><p>判断插入位置是否合法</p></li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/12.png" style="zoom:45%;"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line"><span class="comment">//3.获取第pos个元素</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">ret = current-&gt;next;</span><br><span class="line">current-&gt;next = ret-&gt;next;</span><br><span class="line"><span class="comment">//5.线性表长度减1</span></span><br><span class="line">sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-单链表结构与顺序存储结构优缺点"><a href="#3-单链表结构与顺序存储结构优缺点" class="headerlink" title="(3).单链表结构与顺序存储结构优缺点"></a>(3).单链表结构与顺序存储结构优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/15.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。</p><ul><li>顺序表数组中的元素由两个数据域组成:data和cur</li><li>data域用于存储数据</li><li>cur域用于存储下一个元素在数组中的下标</li></ul><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/17.png" style="zoom:60%;"></p><p>把未被使用的数组元素称为<strong>备用链表。</strong>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；</p><p><strong>数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。</p><p><strong>在C中用一维数组来实现顺序存储结构：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElementType Data;</span><br><span class="line">    <span class="comment">//Cursor,为0时表示无指向 </span></span><br><span class="line"><span class="keyword">int</span> Cur; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p><strong>操作步骤：</strong></p><ul><li>申请MAXSIZE大小的空间</li><li>给游标赋值，最后一个游标赋为0</li><li>返回链表指针</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List <span class="built_in">list</span> = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*MAXSIZE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">list</span>[i].Cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="built_in">list</span>[MAXSIZE - <span class="number">1</span>].Cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></div><h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断位置是否合法</li><li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li><font color="red">在数组中查找空闲位置index</font></li><li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li><li>将新元素插入</li><li>线性表长度加1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p><ul><li>判断线性表是否合法</li><li>判断插入位置是否合法</li><li>获取第pos个元素</li><li>将第pos个元素从链表中删除</li><li>线性表长度减1</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div><p>&lt;/br&gt;</p><h3 id="3-静态链表优缺点"><a href="#3-静态链表优缺点" class="headerlink" title="(3).静态链表优缺点"></a>(3).静态链表优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/18.png" style="zoom:50%;"></p><hr><p>&lt;/br&gt;</p><h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/19.png" style="zoom:50%;"></p><p>&lt;/br&gt;</p><h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p><ul><li>创建链表</li><li>销毁链表</li><li>获取链表长度</li><li>清空链表</li><li>获取第pos个元素操作</li><li>插入元素到位置pos</li><li>删除位置pos处的元素</li></ul><p>&lt;/br&gt;</p><h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2><h3 id="1-结构分析-4"><a href="#1-结构分析-4" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="线性表" scheme="https://ZYBO_o.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <link href="https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/"/>
    <id>https://zybo_o.github.io/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</id>
    <published>2020-04-12T03:50:54.000Z</published>
    <updated>2020-06-02T06:56:01.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><blockquote><p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p><ul><li>可以输入到计算机中。</li><li>能被计算机程序处理。</li></ul></blockquote><p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p><blockquote><p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p></blockquote><p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p><blockquote><p>性质相同，是指数据元素具有相同数量和类型的数据项。</p></blockquote><p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/1.png" style="zoom:50%;"></p><h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote><p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p></blockquote><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/2.png" style="zoom:50%;"></p><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p><blockquote><p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p></blockquote><p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/3.png" style="zoom:50%;"></p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/4.png" style="zoom:40%;"></p><h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p><blockquote><p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p></blockquote><p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p><h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p><hr><p>&lt;/br&gt;</p><h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据结构与算法设计" scheme="https://ZYBO_o.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="数据结构绪论" scheme="https://ZYBO_o.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/</id>
    <published>2020-04-10T03:25:38.000Z</published>
    <updated>2020-04-12T04:14:33.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-10T03:25:16.000Z</published>
    <updated>2020-04-10T04:09:24.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <link href="https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/"/>
    <id>https://zybo_o.github.io/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/</id>
    <published>2020-04-10T03:24:48.000Z</published>
    <updated>2020-04-10T04:09:17.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux C" scheme="https://ZYBO_o.github.io/categories/Linux-C/"/>
    
    
      <category term="C" scheme="https://ZYBO_o.github.io/tags/C/"/>
    
  </entry>
  
</feed>
