<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('请输入密码') !== ''){
                alert('密码错误');
                history.back();
            }
        }
    })();
</script>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/head.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/head.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/head.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="进程,">





  <link rel="alternate" href="/atom.xml" title="ZYBO_o's Blogs" type="application/atom+xml">






<meta name="description" content="一.进程基本概念 以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许多个程序同时进入内存并运行。主要是为了提高 CPU的利用率,进而提高整个系统的效率。   来看一个例子： ​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。 ​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流">
<meta name="keywords" content="进程">
<meta property="og:type" content="article">
<meta property="og:title" content="进程&amp;线程模型">
<meta property="og:url" content="https://zybtree.github.io/2020/08/10/进程-线程模型/index.html">
<meta property="og:site_name" content="ZYBO_o&#39;s Blogs">
<meta property="og:description" content="一.进程基本概念 以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许多个程序同时进入内存并运行。主要是为了提高 CPU的利用率,进而提高整个系统的效率。   来看一个例子： ​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。 ​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/1.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/2.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/3.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/4.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/5.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/6.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/7.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/8.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/9.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/10.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/11.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/12.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/13.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/14.png">
<meta property="og:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/15.png">
<meta property="og:updated_time" content="2020-08-11T12:22:15.893Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="进程&amp;线程模型">
<meta name="twitter:description" content="一.进程基本概念 以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许多个程序同时进入内存并运行。主要是为了提高 CPU的利用率,进而提高整个系统的效率。   来看一个例子： ​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。 ​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流">
<meta name="twitter:image" content="https://zybtree.github.io/2020/08/10/进程-线程模型/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zybtree.github.io/2020/08/10/进程-线程模型/">





  <title>进程&线程模型 | ZYBO_o's Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZYBO_o's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Follow Excellence</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-路径">
          <a href="/top/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-fire"></i> <br>
            
            路径
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zybtree.github.io/2020/08/10/进程-线程模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZYBO_o">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZYBO_o's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">进程&线程模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-10T18:34:19+08:00">
                2020-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.9k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-进程基本概念"><a href="#一-进程基本概念" class="headerlink" title="一.进程基本概念"></a>一.进程基本概念</h1><blockquote>
<p>以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许<font color="red">多个程序同时进入内存</font>并运行。主要是<strong>为了提高 CPU的利用率,进而提高整个系统的效率。</strong></p>
</blockquote>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/1.png" style="zoom:40%;"></p>
<p>来看一个例子：</p>
<p>​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。</p>
<p>​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流，占用一个逻辑的程序计数器。这也是<strong>操作系统虚拟性的一个体现</strong>，<font color="red">把一个物理的程序计数器，给它变换成多个逻辑的程序计数器</font>，实际上每个程序都有自己的程序计数器，由于物理上只有一个程序计数器，所以每个程序真正的上 CPU 就把逻辑程序计数器的内容，推送到物理程序计数器里头。通过这种变换，达到了在内存中同时有多个程序，达到并发执行的效果。</p>
<p>​        C图表示出在一个时间间隔内，每一个程序 A B C D 都执行过了。由于只有一个物理 CPU ，所以这些程序是轮流在 CPU 上执行。但是从宏观上讲它们都在并发执行。</p>
<p><strong>同时又产生了一个问题：在这样一个计算环境下，多个程序并发执行，如何管理在并发环境下同时执行的这些程序？</strong>首先来看下并发环境与并发程序。</p>
<h2 id="1-并发环境与并发程序"><a href="#1-并发环境与并发程序" class="headerlink" title="1.并发环境与并发程序"></a>1.并发环境与并发程序</h2><p><strong>并发环境：</strong>一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态， 并且次序不是事先确定的。</p>
<p><strong>并发程序：</strong>在并发环境中执行的程序。</p>
<blockquote>
<p>在一个并发环境下执行的并发程序，怎么样来刻画这样的程序呢？于是进程的定义就应运而生了。</p>
</blockquote>
<h2 id="2-进程的定义"><a href="#2-进程的定义" class="headerlink" title="2.进程的定义"></a>2.进程的定义</h2><p><strong>定义：</strong>进程是具有独立功能的程序，关于某个数据集合上的一次运行活动，是资源分配的单位，也是CPU调度的单位。又称任务。</p>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>进程是程序的一次执行过程。</strong>（一个程序执行了两次,三次， 那就是不同的进程） </p>
</li>
<li><p><strong>进程是运行程序的一个抽象。</strong>（它代表了所运行的那个环境，代表了一个 CPU，因此有时候说进程是对 CPU 的一个抽象）</p>
</li>
<li><p><strong>将一个 CPU 把它变换成多个虚拟的 CPU 。</strong>(虚拟化技术)</p>
</li>
<li><p><strong>操作系统的资源是以进程为单位来分配的。比如说内存，文件等等。 最重要的一个资源就是地址空间。</strong>(操作系统为每一个进程分配了一个独立的地址空间)</p>
</li>
<li><p><strong>操作系统把CPU的控制权，交给了某一个进程，让这个进程上去运行，这称之为一个调度。</strong></p>
</li>
</ul>
<blockquote>
<p>在操作系统执行过程中，会有很多的程序向操作系统提出申请来运行，那么操作系统怎么知道这些进程是存在，还是不存在呢？ 这里就介绍操作系统为了管理进程所设计的一个非常重要的数据结构，进程控制块 PCB 。</p>
</blockquote>
<h2 id="3-进程控制块PCB"><a href="#3-进程控制块PCB" class="headerlink" title="3.进程控制块PCB"></a>3.进程控制块PCB</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1).定义"></a>(1).定义</h3><p><strong>PCB：Process Control Block.</strong>又称进程描述符、进程属性。</p>
<p>​        操作系统为了管理进程而，设计的一个非常重要的<strong>数据结构</strong>，这就是进程控制块PCB。这个数据结构是专门用于<strong>控制和管理进程的，它保存控制和管理进程所需要的所有的信息。</strong>主要是记录了进程的<strong>各种属性</strong>，并且描述出进程的<strong>运动变化过程</strong>，进程的<strong>发展程度</strong>。<strong>进程控制块PCB这个数据结构是操作系统感知进程存在的一个标志。它们是一一对应的。</strong></p>
<p><strong>进程表：</strong>由于操作系统管理了很多的进程，为了便于管理，就把所有进程的每个进程的PCB集中在一起，放在了内存的固定区域，这就形成了进程表。</p>
<blockquote>
<p>进程表是所有进程的 PCB 的一个集合。而且就是进程表的大小往往是固定的，确定了在一个操作系统中最多支持多少个进程 。</p>
</blockquote>
<h3 id="2-PCB包含的信息内容"><a href="#2-PCB包含的信息内容" class="headerlink" title="(2).PCB包含的信息内容"></a>(2).PCB包含的信息内容</h3><h4 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h4><ul>
<li><strong>进程标识符(process ID)</strong>，唯一的，通常是一个整数。</li>
<li><strong>进程名</strong>，通常基于可执行文件名，不唯一。</li>
<li><strong>用户标识符(user ID)</strong></li>
<li><strong>进程组关系</strong></li>
</ul>
<h4 id="进程控制信息"><a href="#进程控制信息" class="headerlink" title="进程控制信息"></a>进程控制信息</h4><ul>
<li><strong>当前状态</strong></li>
<li><strong>优先级(priority)</strong></li>
<li><strong>代码执行入口地址</strong></li>
<li><strong>程序的磁盘地址</strong></li>
<li><strong>运行统计信息</strong>(执行时间、页面调度) </li>
<li><strong>进程间同步和通信</strong></li>
<li><strong>进程的队列指针</strong></li>
<li><strong>进程的消息队列指针</strong></li>
</ul>
<h4 id="所拥有的资源和使用情况"><a href="#所拥有的资源和使用情况" class="headerlink" title="所拥有的资源和使用情况"></a>所拥有的资源和使用情况</h4><ul>
<li><strong>虚拟地址空间的状况</strong> </li>
<li><strong>打开文件列表</strong></li>
</ul>
<h4 id="CPU现场信息"><a href="#CPU现场信息" class="headerlink" title="CPU现场信息"></a>CPU现场信息</h4><blockquote>
<p><strong>CPU的现场信息</strong>是指当进程不运行的时候，操作系统要把一些重要的信息，硬件执行的状态信息，保存在PCB 里。</p>
</blockquote>
<ul>
<li><p><strong>寄存器值</strong>(通用寄存器、程序计数 器PC、程序状态字PSW、栈指针)</p>
</li>
<li><p><strong>指向该进程页表的指针</strong></p>
</li>
</ul>
<h3 id="3-SOLARIS的进程控制块与进程表"><a href="#3-SOLARIS的进程控制块与进程表" class="headerlink" title="(3).SOLARIS的进程控制块与进程表"></a>(3).SOLARIS的进程控制块与进程表</h3><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/2.png" style="zoom:33%;"></p>
<p>SOLARIS是基于 Unix 操作系统，它的进程控制块的名字一般叫Proc结构。每一个Proc结构代表一个PCB。把所有的Proc结构组织成一个链，那么这就是一个进程表。</p>
<p><strong>Proc 结构保存的信息：</strong>（重点介绍三个）</p>
<p>第一个是可执行文件 p_exec，通过这样一个记录信息，可以找到这个进程所对应的可执行文件在磁盘上的位置。</p>
<p>第二个是进程的地址空间 p_as，进程地址空间放了很多内容，每一项内容都放在一段里头，通过段来把进程地址空间描述清楚，把这些段按照地址大小的顺序，把它建立成一个 AVL 树，便于以后的查找。 </p>
<p>第三个是文件表，通过这张表可以把所有打开的文件都能找到。</p>
<hr>
<h1 id="二-进程状态及状态转换"><a href="#二-进程状态及状态转换" class="headerlink" title="二.进程状态及状态转换"></a>二.进程状态及状态转换</h1><h2 id="1-进程的三种状态及状态的转换"><a href="#1-进程的三种状态及状态的转换" class="headerlink" title="1.进程的三种状态及状态的转换"></a>1.进程的三种状态及状态的转换</h2><h3 id="1-进程的三种基本状态"><a href="#1-进程的三种基本状态" class="headerlink" title="(1).进程的三种基本状态"></a>(1).进程的三种基本状态</h3><p><strong>运行态(Running)</strong> </p>
<p>进程占有CPU，并在CPU上运行。</p>
<p><strong>就绪态(Ready)</strong> </p>
<p>进程已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。</p>
<p><strong>等待态(Waiting/Blocked)</strong></p>
<blockquote>
<p>也称阻塞态、封锁态、睡眠态 </p>
</blockquote>
<p>进程因等待某一事件而暂时不能运行。</p>
<h3 id="2-三状态模型及状态转换"><a href="#2-三状态模型及状态转换" class="headerlink" title="(2).三状态模型及状态转换"></a>(2).三状态模型及状态转换</h3><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/3.png" style="zoom:25%;"></p>
<h2 id="2-进程的其他状态"><a href="#2-进程的其他状态" class="headerlink" title="2.进程的其他状态"></a>2.进程的其他状态</h2><h3 id="1-创建态"><a href="#1-创建态" class="headerlink" title="(1).创建态"></a>(1).创建态</h3><p>已完成创建一进程所必要的工作，比如分配了PID、填写了PCB。但由于某些原因，操作系统尚未同意执行该进程。</p>
<h3 id="2-终止态"><a href="#2-终止态" class="headerlink" title="(2).终止态"></a>(2).终止态</h3><p>终止执行后，进程进入该状态。</p>
<ul>
<li><p>可完成一些数据统计工作</p>
</li>
<li><p><strong>资源回收</strong></p>
</li>
</ul>
<h3 id="3-挂起态"><a href="#3-挂起态" class="headerlink" title="(3).挂起态"></a>(3).挂起态</h3><p>在操作系统当中，如果想进行一些负载调节时，可能会把进程送入这个状态。</p>
<p>比如如果现在系统中进程太多，CPU也忙不过来了，此时操作系统会把一部分进程，让它暂时不能运行，但是它又不是等待某个事件发生，所以就把它弄成一个特殊的状态，叫挂起态。</p>
<p>一旦进程进入了挂起态，操作系统会把它的内存空间呢收回来。把这些进程的相关的内容送到磁盘上保存起来，一旦继续让它运行，我们通常称之为激活。进程的内容再从磁盘上读入内存就可以了。</p>
<h2 id="3-五状态模型"><a href="#3-五状态模型" class="headerlink" title="3.五状态模型"></a>3.五状态模型</h2><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/4.png" style="zoom:30%;"></p>
<h2 id="4-七状态模型"><a href="#4-七状态模型" class="headerlink" title="4.七状态模型"></a>4.七状态模型</h2><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/5.png" style="zoom:32%;"></p>
<h2 id="5-进程队列"><a href="#5-进程队列" class="headerlink" title="5.进程队列"></a>5.进程队列</h2><blockquote>
<p>操作系统在设计进程模型的时候要确定有什么样的状态，确定状态之间的转换，在什么条件下转换 ，通过什么样的操作来促成这种转换。 而且操作系统当中有很多的进程，它们都处于不同的状态。所以需要按不同的状态把它们管理起来，因此，操作系统设计了一个若干个进程队列。</p>
</blockquote>
<p>操作系统设计了一个若干个进程队列，为<strong>每一个类进程建立一个或者多个队列也是可以的。</strong> 每个队列的元素，实际上就是PCB 状态的改变，其实就是某个进程的PCB从一个队列出队，然后在另一个队列里头入队的过程。也就是伴随着状态的改变，进程的PCB从一个队列进入到另外一个队列。 </p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/6.png" style="zoom:35%;"></p>
<p><strong>五状态进程模型的队列模型：</strong></p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/7.png" style="zoom:38%;"></p>
<hr>
<h1 id="三-进程控制"><a href="#三-进程控制" class="headerlink" title="三.进程控制"></a>三.进程控制</h1><p>进程控制操作主要是完成进程之间的各状态之间的转换，<strong>进程控制操作实际上就是具有特定功能的程序。</strong> <font color="red">这个程序执行的时候，由于不允许被中断</font>，所以把它称之为原语。</p>
<p><strong>原语：</strong> <strong>所谓原语(有时候又称之为原子操作) 是完成某种特定功能的一段程序</strong>，比如说完成创建，或者是完成阻塞，它是一段程序，完成了某种特定功能，<font color="red">但是这个程序在执行过程中，是具有不可分割性，或者是不可中断的，它必须持续地执行，不允许被打断</font>，这就是原语。</p>
<blockquote>
<p>实现原语需要操作系统通过屏蔽中断的一些措施来达到这样一个结果。进程控制操作最重要的一个就是进程的创建。</p>
</blockquote>
<h2 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h2><p><strong>主要完成以下几个工作：</strong> </p>
<ol>
<li><strong>首先给每一个新的进程分配一个标识ID，再给它找一个空的、 没有用过的进程控制块</strong></li>
<li><p><strong>然后要给这个进程分配它所需要的地址空间。</strong> (如果这个地址空间在虚拟存储机制之下，就假设给了它，只是给了一个虚拟地址空间）。</p>
</li>
<li><p><strong>再初始化这个进程控制块，填写相应的内容</strong>。</p>
<ul>
<li>通常都是设定一些默认值，比如说状态，进程的状态设定为New 等等 </li>
</ul>
</li>
<li>创建进程控制块之后，要把它插入到相应的队列当中， <strong>所以要设置相应的队列指针</strong>。</li>
</ol>
<h2 id="2-进程撤销"><a href="#2-进程撤销" class="headerlink" title="2.进程撤销"></a>2.进程撤销</h2><p><strong>进程的撤销实际上就是结束进程。</strong></p>
<p>结束进程其实主要做两件事情：</p>
<ol>
<li><p><strong>把进程所占有的资源回收</strong> </p>
<ul>
<li>关闭它打开的文件；如果有网络连接就断开；如果分配了一些内存，就把它回收了</li>
</ul>
</li>
<li><p><strong><font color="red">资源回收之后最重要的，是要把分配给它的 PCB 收回。</font></strong></p>
</li>
</ol>
<h2 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3.进程阻塞"></a>3.进程阻塞</h2><p><strong>处于运行状态的进程，在其运行过程中期待某一事件发生</strong>，如等待键盘输入、等待 磁盘数据传输完成、等待其它进程发送消息， <font color="red">当被等待的事件未发生时，由<strong>进程自己执行阻塞原语，使自己由运行态变为阻塞态</strong>。</font></p>
<h2 id="4-UNIX的几个进程控制操作"><a href="#4-UNIX的几个进程控制操作" class="headerlink" title="4.UNIX的几个进程控制操作"></a>4.UNIX的几个进程控制操作</h2><ul>
<li><p><strong>fork( )：</strong>通过<font color="red">复制调用进程来</font>建立新的进程，是 最基本的进程建立过程</p>
</li>
<li><p><strong>exec( )：</strong>包括一系列系统调用，它们都是通过用 一段新的程序代码覆盖原来的地址空间，<font color="red">实现进程执行代码的转换</font></p>
</li>
<li><strong>wait( )：</strong>提供初级进程同步操作，能使一个进程等待另外一个进程的结束</li>
<li><strong>exit( )</strong>：用来终止一个进程的运行</li>
</ul>
<blockquote>
<p>他们都是以系统调用的形式，作为一个接头呈现给用户，由用户程序来调用 。</p>
</blockquote>
<h2 id="5-UNIX的FORK-实现"><a href="#5-UNIX的FORK-实现" class="headerlink" title="5.UNIX的FORK()实现"></a>5.UNIX的FORK()实现</h2><ol>
<li><p><strong>首先会为子进程分配一个空闲的进程描述符，也就是 PCB。</strong></p>
<blockquote>
<p> PCB在 UNIX 一般叫 proc 结构 </p>
</blockquote>
</li>
<li><p><strong>给子进程分配了一个唯一的标识pid</strong> </p>
</li>
<li><p><strong>给子进程分配地址空间</strong> </p>
<blockquote>
<p>在 UNIX 里 fork 以一次一页的方式把父进程的地址空间内容完全地拷贝给子进程</p>
</blockquote>
</li>
<li><p><strong>从父进程那里继承各种共享资源</strong></p>
<blockquote>
<p>比如打开的文件，当前工作目录等等 </p>
</blockquote>
</li>
<li><p><strong>子进程的状态 设置为就绪态，并且把它插入到了就绪队列</strong> </p>
</li>
<li><p><strong>做完这项工作之后，fork 就为子进程返回一个值 0</strong> </p>
</li>
<li><strong>为父进程返回一个值，是子进程的 pid</strong> </li>
</ol>
<blockquote>
<p>那么也就是说，fork 执行完后，原来一个进程，父进程就一分为二，变成了两个进程，一个父进程，一个子进程。</p>
<p>在父进程得到的返回值是 pid，在子进程里得到的返回值是 0。</p>
</blockquote>
<p><strong>问题：以一次一页的方式来复制父进程的地址空间有什么弊端？</strong></p>
<p>​        父进程把它所有的内容都拷贝给子进程 ，但是子进程不一定需要，而且通常情况下，父进程创建子进程是让子进程做与父进程所不同的工作。所以把发父进程所有内容拷贝给子进程，实际上，子进程也不需要。因此，子进程会接着执行 exec这样一个函数来把父进程拷贝过来的这些地址空间给覆盖掉。因此之前的这种复制工作，实际上就是无用功了。</p>
<p><strong>Linux 使用了写时复制技术 Copy-On-Write，</strong><font color="red">Linux中父进程把地址空间的指针传递给子进程，再把地址空间设置为只读。那么当子进程要往地址空间里写东西的时候，操作系统会为子进程单独再开辟一块空间，把相应的内容放进去 那么这样的话呢，节省了之前复制父进程地址空间的时间，加快了 fork 的实现速度。</font></p>
<p><strong>代码例子：</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();<span class="comment">/* 创建一个子进程 */</span></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;<span class="comment">/* 出错 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “fork failed”);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span> </span><br><span class="line">    execlp(“/bin/ls”, “ls”, <span class="literal">NULL</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待子进程结束 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(“child complete”);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>流程：</strong></p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/8.png" style="zoom:50%;"></p>
<hr>
<h1 id="四-进程相关概念"><a href="#四-进程相关概念" class="headerlink" title="四.进程相关概念"></a>四.进程相关概念</h1><h2 id="1-进程的讨论"><a href="#1-进程的讨论" class="headerlink" title="1.进程的讨论"></a>1.进程的讨论</h2><h3 id="1-进程的分类"><a href="#1-进程的分类" class="headerlink" title="(1).进程的分类"></a>(1).进程的分类</h3><h4 id="第一种分类"><a href="#第一种分类" class="headerlink" title="第一种分类"></a>第一种分类</h4><ul>
<li><strong>系统进程</strong></li>
<li><strong>用户进程</strong> </li>
</ul>
<blockquote>
<p> 系统进程是操作系统为了管理一些资源而设计的进程,它的主要特点是优先级比较高。相对于用户进程而言，系统进程会优先被调度上CPU 去执行，因为它完成了一些关键的工作。</p>
</blockquote>
<h4 id="第二中分类"><a href="#第二中分类" class="headerlink" title="第二中分类"></a>第二中分类</h4><ul>
<li>前台进程</li>
<li>后台进程 </li>
</ul>
<blockquote>
<p> 前台进程实际上就是和用户直接交互的这样一些进程：用户敲键盘、 动鼠标。</p>
<p>后台进程往往是操作系统在启动了以后创建的一些进程，这些进程为用户来进行服务，比如说打印进程。</p>
<p>有一些应用进程也在系统启动的时候被创建了， 比如说防火墙，还有一些电子邮件的接收。这样的一些进程它们在后台工作，然后发生了一些事件，它们来接收这些事件。对于用户来讲，他所打交道的是前台进程。</p>
</blockquote>
<h4 id="第三种分类"><a href="#第三种分类" class="headerlink" title="第三种分类"></a>第三种分类</h4><ul>
<li>CPU 密集型进程</li>
<li>I/O 密集型程序</li>
</ul>
<blockquote>
<p> 有一些进程需要用到很多的 CPU 时间。比如说，画面渲染需要大量的计算，因此把它称之为 CPU 密集型进程 </p>
<p>有些经常需要输入、 输出、 读盘这样一些操作，这些进程被称之为 I/O 密集型 </p>
<p>那么这两类进程的区分也是为了以后调度程序的选择做一些准备 。</p>
</blockquote>
<h3 id="2-进程层次结构"><a href="#2-进程层次结构" class="headerlink" title="(2).进程层次结构"></a>(2).进程层次结构</h3><h4 id="UNIX进程家族树-init为根"><a href="#UNIX进程家族树-init为根" class="headerlink" title="UNIX进程家族树:init为根"></a>UNIX进程家族树:init为根</h4><p>UNIX 进程都是在一个家族里，这个家族树有一个根，这个根是一个 init 进程，是个 1 号进程，是所有进程的一个祖宗。在某些情况下，某一个进程它结束了，那么它的子孙进程，其实也必须全部的结束。</p>
<h4 id="Windows-地位相同"><a href="#Windows-地位相同" class="headerlink" title="Windows:地位相同"></a>Windows:地位相同</h4><p> 那在 Windows 中也是一个进程创建另一个进程，但是创建完之后，这两个进程的关系比较疏远，也就是它们的地位是相同的。 </p>
<h2 id="2-进程与程序的区别"><a href="#2-进程与程序的区别" class="headerlink" title="2.进程与程序的区别"></a>2.进程与程序的区别</h2><ul>
<li><strong>进程更能准确刻画并发，而程序不能</strong></li>
<li><strong>程序是静态的，进程是动态的</strong></li>
<li><strong>进程有生命周期的，有诞生有消亡，是 短暂的 ; 而程序是相对长久的</strong></li>
<li><strong>一个程序可对应多个进程</strong></li>
<li><strong>进程具有创建其他进程的功能</strong>(程序没有)</li>
</ul>
<h2 id="3-进程地址空间"><a href="#3-进程地址空间" class="headerlink" title="3.进程地址空间"></a>3.进程地址空间</h2><blockquote>
<p>操作系统会给每一个进程都分配了一个地址空间。怎么理解这句话？怎么理解这样一个场景？</p>
</blockquote>
<p><strong>以代码为例：</strong></p>
<div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myval;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  myval = atoi(argv[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(“myval is %d, loc <span class="number">0</span>x%lx\n”, myval, (<span class="keyword">long</span>) &amp;myval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个程序实际上是从命令行接收了参数，把这个参数赋给一个变量 myval 然后就是循环，来打印这个变量的值，同时把这个变量的位置 打印出来。 </p>
<p>现在同时执行两个 myval 程序。 也就是这两个进程在执行，因为用了一个循环，所以这个进程会一直在那运行下去。如果运行这两个进程，分别用参数 7，8 来调用这个程序，输出的结果如下：</p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/9.png" style="zoom:35%;"></p>
<blockquote>
<p>当执行 myval 7 的时候，myval 的这个变量值是 7 ，地址是 60104C 。同时 myval 8 也在执行。 发现 myval 的值是 8 ，而myval 的地址呢 也是 60104C。 <strong>为何变量 myval 的值是不一样的，地址却是相同的呢？</strong></p>
</blockquote>
<p>实际上每个进程有自己相对独立地址空间。 <font color="red"><strong>两个进程实际上是两个地址空间。而且它们的地址空间是隔离的。不同的地址空间，它的地址不是实际的物理内存地址。 实际上是一个相对地址，如果支持虚存的系统当中，那么这个地址就是虚拟地址，也可以说是一个相对地址，或者是逻辑地址。</strong></font></p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/10.png" style="zoom:35%;"></p>
<p>上图是一个进程地址空间的表示图。在这个空间里，操作系统会占一部分内容：</p>
<ul>
<li><p>上半部分是<strong>操作系统内核的地址空间</strong> </p>
</li>
<li><p>下面是<strong>用户地址空间</strong></p>
<blockquote>
<p>用户地址空间包括了用户执行的过程中所需要的一些代码数据，一些临时变量。 还有在运行过程中如果进行了过程调用函数调用，需要用栈来传递参数，那么主体有这样一些内容。在进程运行过程中还可能调一些共享库， 因此还有一些共享库放在这个位置；如果打开了文件以文件内存映射文件的方式来使用这个文件的话，那么也用到这些空间。这就是进程用户地址空间的内容。</p>
</blockquote>
</li>
</ul>
<p>myvalue 7 和 myvalue 8 这两个进程每个都有这么一个地址空间 ， <font color="red"><strong>因此myvalue这个变量实际上是在不同的地址空间里的相同的位置。因此，我们看到了虚拟地址虽然是相同的 那么这个相同指的是对于这个地址空间的位置，而不是指的在物理内存的位置。</strong></font></p>
<h2 id="4-进程映像-IMAGE"><a href="#4-进程映像-IMAGE" class="headerlink" title="4.进程映像(IMAGE)"></a>4.进程映像(IMAGE)</h2><p><strong>进程映像指的是进程执行过程中它的全过程的一个静态描述，可以把它看成是在某一瞬间的进程的快照。</strong> </p>
<p><strong>包括的内容：</strong>地址空间的内容，硬件寄存器的内容，以及与该进程相关的一些内核数据结构和内核栈。 </p>
<ul>
<li><p>用户相关:进程地址空间(包括代码段、数据段、 堆和栈、共享库……)</p>
</li>
<li><p>寄存器相关:程序计数器、指令寄存器、程序状态 寄存器、栈指针、通用寄存器等的值</p>
</li>
<li><p>内核相关:</p>
<ul>
<li>静态部分:PCB及各种资源数据结构</li>
<li>动态部分:内核栈(不同进程在进入内核后使用不同的内核栈)</li>
</ul>
</li>
</ul>
<h2 id="5-上下文-CONTEXT-切换"><a href="#5-上下文-CONTEXT-切换" class="headerlink" title="5.上下文(CONTEXT)切换"></a>5.上下文(CONTEXT)切换</h2><p><strong>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。</strong></p>
<ul>
<li><p>进程运行时，其硬件状态保存在<strong>CPU上的寄存器</strong>中。</p>
<blockquote>
<p>寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值。</p>
</blockquote>
</li>
<li><p>进程不运行时，这些寄存器的值保存在<strong>进程控制块 PCB中</strong>；<font color="red">当操作系统要运行一个新的进程时，将 PCB中的相关值送到对应的寄存器中。</font>这个就完成了上下文切换的一个过程。</p>
</li>
</ul>
<hr>
<h1 id="五-线程的引入"><a href="#五-线程的引入" class="headerlink" title="五.线程的引入"></a>五.线程的引入</h1><p>为什么在进程中再派生线程?具体有三个理由：</p>
<ul>
<li><strong>应用的需要</strong> </li>
<li><strong>开销的考虑</strong> </li>
<li><strong>性能的考虑</strong></li>
</ul>
<h2 id="1-Web服务器为例"><a href="#1-Web服务器为例" class="headerlink" title="1.Web服务器为例"></a>1.Web服务器为例</h2><h3 id="1-工作方式"><a href="#1-工作方式" class="headerlink" title="(1).工作方式"></a>(1).工作方式</h3><p><strong>以Web服务器为例，</strong>其工作方式是：</p>
<ol>
<li>从客户端接收网页请求(http协议) </li>
<li>从磁盘上检索相关网页，读入内存</li>
<li>将网页返回给对应的客户端</li>
</ol>
<blockquote>
<p>每次到磁盘上搜索相关的网页，进程就会停在那里，这样性能就比较慢。 怎么样去提高服务器的工作的效率?</p>
</blockquote>
<p>通常情况下，是在服务器的内存里头，开辟一个<strong>网页缓存</strong> ( Web page Cache )，保存了常用的网页。当Web服务器从客户端接收了网页请求之后会先到网页缓存当中去查找，如果找到就直接把结果返回给客户端，就不用到磁盘上去找。 但是如果没找到就先到磁盘上去搜索相关的网页，得到了之后写入网页缓存，然后再把结果返回给用户。 </p>
<h3 id="2-无线程的情况"><a href="#2-无线程的情况" class="headerlink" title="(2).无线程的情况"></a>(2).无线程的情况</h3><p>此时有两种解决方案：</p>
<h4 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h4><p>设定一个服务进程，这个服务进程只能是顺序编程 。也就是说，如果它到磁盘上去搜寻网页，那就不能再去接收客户端的请求。因此会造成服务器性能下降。</p>
<blockquote>
<p>为什么不能设定多个服务进程？</p>
<p><strong>每个进程有自己独立的地址空间，所以它不能共享信息，所以只能有一个服务进程。</strong></p>
</blockquote>
<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>有限状态机的方法<strong>实际上是用一个复杂的编程模型来自己模拟一些并发的工作，即进程自己来模拟并发的工作。</strong> </p>
<p>比如说接收了一个用户请求之后，如果要到磁盘上搜寻这个网页，那么原本这个进程会被暂停，这个时候就要改造这个搜寻网页的操作，把它改造成一个<strong>非阻塞的I/O</strong>。</p>
<blockquote>
<p>到磁盘上去搜寻网页的同时这个进程还可以继续做与这个网页内容无关的一些工作。 所以叫非阻塞 I/O。</p>
</blockquote>
<p>在查询网页的同时，磁盘在工作，而且<strong>这个进程就可以回来做别的事情，它可以继续去接收用户的客户端请求。 当新的请求被接收到之后，它继续可能在 Web Cache 里找网页，然后返回去，如果没找到网页呢，继续再去调用磁盘</strong>。<font color="red">但是这就出现了一个问题：磁盘的这个结果返回了，究竟是哪一个客户端的请求呢？</font></p>
<p>所以这个时候，进程要自己把这些信息记录下来，然后磁盘返回了请求之后，就要判断是哪一个客户端的请求，然后返回给对应的客户 端。因此，它的编程模型呢是比较复杂的。</p>
<h3 id="3-引进多线程之后"><a href="#3-引进多线程之后" class="headerlink" title="(3).引进多线程之后"></a>(3).引进多线程之后</h3><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/11.png" style="zoom:35%;"></p>
<p><strong>工作方式：</strong> </p>
<p>把线程分成两类：</p>
<ul>
<li><p><strong>分派线程</strong></p>
<blockquote>
<p>分派线程只需要一个，分派线程的<strong>主要工作就是监听客户端</strong>，客户端只要有请求就把请求读进来，但是它不完成客户端的请求，它把这个请求分派给其它的线程来完成，而完成工作的线程就是工作线程。 </p>
</blockquote>
</li>
<li><p><strong>工作线程</strong></p>
<blockquote>
<p>Web 服务器上有一堆工作线程，它们都是用来完成的是服务客户请求的。分派线程获得了客户端请求之后就把它分给某一个工作线程，工作线程呢还跟前面一样先到Web Cache里去查找网页是否存在，如果存在就返回给客户端，如果不存在就要启动磁盘，到磁盘上去搜寻网页。它到磁盘上搜寻网页，这是一个阻塞的I/O，<strong>这时它就会被阻塞，然后等待，但是没有关系，因为还有其它的工作线程。</strong> </p>
</blockquote>
<h2 id="2-引入线程的优点"><a href="#2-引入线程的优点" class="headerlink" title="2.引入线程的优点"></a>2.引入线程的优点</h2></li>
</ul>
<h3 id="1-从开销的角度"><a href="#1-从开销的角度" class="headerlink" title="(1).从开销的角度"></a>(1).从开销的角度</h3><p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/12.png" style="zoom:35%;"></p>
<h3 id="2-从性能的角度"><a href="#2-从性能的角度" class="headerlink" title="(2).从性能的角度"></a>(2).从性能的角度</h3><p>如果一个进程里头又有多个线程，而这些线程，有的计算，有的去 I/O，当有多个处理器的时候，就可以充分发挥这个优势了。所以当多处理器的情况下，一个进程就可以有很多的任务同时在执行。性能就提高了很多。</p>
<hr>
<h1 id="六-线程的基本概念"><a href="#六-线程的基本概念" class="headerlink" title="六.线程的基本概念"></a>六.线程的基本概念</h1><p>进程有两个基本的属性：</p>
<ul>
<li><p><strong>进程是资源的拥有者。</strong> </p>
</li>
<li><p><strong>进程是CPU的一个调度单位。</strong> </p>
</li>
</ul>
<p>但是有了线程之后，<font color="red">线程就继承了进程中的一个属性，也就是线程成为了 CPU 的调度单位。 而进程依然还是管理资源，然后是资源的一个拥有者。 </font></p>
<p>线程实际上是<strong>进程中的一个运行实体。</strong> </p>
<blockquote>
<p> 从运行的角度，它是一个运行的实体，它是一个 CPU 的调度单位。 有的时候把线程称之为轻量级进程。 也就是说，在进程当中又增加了多个执行序列， 让这些执行序列可以并发执行，以提高软件的运行效率。 </p>
</blockquote>
<p>所以强调的是：<font color="red"><strong>在进程中增加了多个执行序列，叫线程。</strong></font></p>
<hr>
<h1 id="七-线程的属性"><a href="#七-线程的属性" class="headerlink" title="七.线程的属性"></a>七.线程的属性</h1><p> 线程是一个运行实体，它有属于线程自己的一些属性： </p>
<ul>
<li><p><strong>有标识符ID</strong></p>
<blockquote>
<p> 同一个进程的不同线程要区分 </p>
</blockquote>
</li>
<li><p><strong>有状态及状态转换</strong> </p>
<blockquote>
<p>因为线程是上 CPU 的，所以它有状态。它也有状态的转换，也需要提供一些针对线程的操作。 </p>
</blockquote>
</li>
<li><p><strong>不运行的时需要保存上下文环境</strong></p>
<blockquote>
<p>上下文环境：程序计数器等寄存器(保存在线程的相对的数据结构里)</p>
</blockquote>
</li>
<li><p><strong>有自己的栈和栈指针</strong></p>
<blockquote>
<p>不同的线程，这些信息也是不一样的。 </p>
</blockquote>
</li>
<li><p><strong>共享所在进程的地址空间和其他资源</strong></p>
<blockquote>
<p>同一个进程的不同线程它们是共享所在进程地址空间，内容和这个进程所拥有的资源的，所以这是非常重要的，也就是线程之间的通信，或者其他的一些操作带来了便利的地方，它们是共享同一个进程的地址空间和有关的资源。 </p>
</blockquote>
</li>
<li><p><strong>可以创建、撤消另一个线程</strong></p>
<blockquote>
<p>当创建进程以后，实际上是只有一个线程，我们称之为一个主线程。 然后由它再创建其他的线程，所以程序开始的时候，我们可以看成是一个单线程的进程在运行。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="八-线程机制的实现"><a href="#八-线程机制的实现" class="headerlink" title="八.线程机制的实现"></a>八.线程机制的实现</h1><blockquote>
<p>在操作系统中， 如何来支持线程机制的实现? 通常有三种方式：<strong>用户级线程</strong>、 <strong>核心级线程</strong>和<strong>混合方式</strong>。 </p>
<p>由于在线程的概念提出之前，操作系统已经运行了很多年，进程的概念已经用了很长时间。 因此当有一个新的机制提出来的时候， 不同的操作系统对这个机制的支持是不一样的。</p>
</blockquote>
<h2 id="1-用户级线程"><a href="#1-用户级线程" class="headerlink" title="1.用户级线程"></a>1.用户级线程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1).概念"></a>(1).概念</h3><p><strong>用户级线程：</strong>在用户空间建了一个线程库， 这个线程库里提供了一系列的针对线程的操作。 这些线程的管理是通过一个 Run-time System 运行时系统来管理的。 它完成的就是这些线程的创建和线程数据结构的一些管理工作。 如下图所示：</p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/13.png" style="zoom:40%;"></p>
<blockquote>
<p>有一个Run-time System，它是管理这些线程里的数据结构、 线程表。这是用户级线程的一个实现。 </p>
</blockquote>
<p>对于内核而言， 线程的实现是在用户空间，所以<strong>操作系统内核并不知道线程的存在</strong>，也就是说，<font color="red">它的管理还是以进程为单位来管理，它没有感知线程的存在。</font> </p>
<p>从图中可以看到线程的数据结构是由 Run-time System 来管理的。 内核只看到了进程的数据结构， 因此线程的切换，从一个线程换到另外一个线程不需要操作系统内核的干预，也不需要进入内核来做这件事情， 所以速度比较快。 </p>
<blockquote>
<p>UNIX 内的操作系统通常采用这种方式来支持线程。</p>
</blockquote>
<h3 id="2-POSIX线程库——PTHREAD"><a href="#2-POSIX线程库——PTHREAD" class="headerlink" title="(2).POSIX线程库——PTHREAD"></a>(2).POSIX线程库——PTHREAD</h3><p>UNIX内的操作系统通常采用这种方式来支持线程。 它支持线程的时候是遵循 POSIX 规范。也就是 POSIX 规范当中确定了多线程的这种编程的接口。 </p>
<p>那以什么样的方式呈现给用户呢？它对线程库进行了相应的规范。 这个规范就是 PTHREAD 线程库。 这个线程库按照规范要提供若干个函数来支持线程、 创建线程、撤销线程，等待某个线程的结束。 </p>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/14.png" style="zoom:33%;"></p>
<blockquote>
<p>在这堆操作当中，重点介绍一下 yield 函数，<strong>这个函数表示这个线程自愿让出 CPU。</strong> </p>
<p>我们知道一个进程的若干线程实际上是相互配合来完成一项任务的。 所以这线程之间是可以协商由谁上 CPU，所以一个线程如果占 CPU 时间太长，那么别的线程得不到机会，就需要这个线程<code>高尚</code>一点，让出 CPU，它就调用 yield 让出 CPU。 如果它不让出 CPU，其实其它线程是没法上 CPU 的，<font color="red"><strong>因为对于线程而言，它感知不到时钟中断，因为整个时钟段是对进程而言的。</strong> </font></p>
</blockquote>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3).总结"></a>(3).总结</h3><p><strong>优点:</strong></p>
<ul>
<li>线程切换快</li>
<li>调度算法是应用程序特定的</li>
<li><p>用户级线程可运行在任何操作系统上(只需要实现线程库)</p>
<p><strong>缺点:</strong></p>
</li>
</ul>
<ul>
<li><p>内核只将处理器分配给进程，同一进程中的两 个线程不能同时运行于两个处理器上</p>
</li>
<li><p>大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞</p>
<blockquote>
<p><strong>改变：</strong></p>
<ul>
<li>把系统调用，阻塞系统调用改成一个非阻塞的</li>
<li>用 Jacketing/ wrapper 的这种技术在系统调用之外封装一层。 在调用系统调用之前，先判断一下调用这个系统调用会不会导致线程阻塞，如果导致线程阻塞，那么就赶紧地换其它线程，这样的话，就不会因为某个线程调用了一个阻塞的系统调用使得整个进程被阻塞。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="2-核心级线程"><a href="#2-核心级线程" class="headerlink" title="2.核心级线程"></a>2.核心级线程</h2><p>第二类实现线程机制的方法是核心级线程。这个方案就是彻底地改造了操作系统。 </p>
<ul>
<li><p>内核管理所有的线程。 通过 API 的接口向用户提供一些 API 的函数，由用户可以创建线程。 </p>
</li>
<li><p>所以内核既维护了进程的数据结构，也维护了进程里头的各个线程的数据结构。</p>
<blockquote>
<p>从下图中可以看到内核里头既管了线程表， 也管了进程表。 </p>
</blockquote>
</li>
</ul>
<p><img src="//zybtree.github.io/2020/08/10/进程-线程模型/15.png" style="zoom:35%;"></p>
<ul>
<li>线程的切换需要内核干预，因此要进入内核来完成切换的过程。 调度也是以线程为单位来进行的。 </li>
</ul>
<blockquote>
<p>实现核心级线程机制的典型的操作系统就是 Windows。 </p>
</blockquote>
<h2 id="3-混合模型"><a href="#3-混合模型" class="headerlink" title="3.混合模型"></a>3.混合模型</h2><p>混合模型就是<strong>线程的创建是在用户空间用线程库来完成的。</strong> 但是内核也要管理线程，也就是说<strong>调度是由内核来完成的。</strong> </p>
<blockquote>
<p>这个采用这种混合模型实现线程机制的是 Solaris 操作系统。 </p>
</blockquote>
<p><strong>用户空间的线程和内核的这个关系是什么？</strong></p>
<p>用户线程通过了一个多路复用来复用多个内核级线程，也就是核外的用户空间的线程通过一个机制和核内的一个内核线程对应起来。调度内核这个线程上 CPU 其实就是调度这个核外的这个线程上 CPU。这是 Solaris 的一种实现。 </p>
<hr>
<h1 id="九-总结"><a href="#九-总结" class="headerlink" title="九.总结"></a>九.总结</h1><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><ul>
<li><p><strong>并发性：</strong>任何进程都可以与其他进程一起向前推进</p>
</li>
<li><p><strong>动态性：</strong>进程是正在执行程序的实例</p>
<ul>
<li>进程是动态产生，动态消亡的</li>
<li>进程在其生命周期内，在三种基本状态之间转换</li>
</ul>
</li>
<li><p><strong>独立性：</strong>进程是<font color="red">资源分配</font>的一个独立单位 </p>
<blockquote>
<p>例如:各进程的<font color="red">地址空间相互独立</font></p>
</blockquote>
</li>
<li><p><strong>交互性：</strong>指进程在执行过程中可能与其他进程产生直 接或间接的关系</p>
</li>
<li><p><strong>异步性：</strong>每个进程都以其相对独立的、不可预知的速 度向前推进</p>
</li>
<li><p><strong>进程映像：</strong>程序 + 数据 + 栈(用户栈、内核栈) + PCB</p>
</li>
</ul>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><ul>
<li><p><strong>多线程应用场景</strong></p>
<blockquote>
<p>知道什么情况下去应用多线程</p>
</blockquote>
</li>
<li><p><strong>线程基本概念、属性</strong></p>
<blockquote>
<p>程作为一个进程中运行的一个实体，有哪些是属于它自己的信息？有哪些是共享同一个进程的其他的一些资源？</p>
</blockquote>
</li>
<li><p><strong>线程实现机制</strong></p>
<blockquote>
<p>操作系统中如何来实现线程？如何来支持线程？</p>
</blockquote>
</li>
</ul>
<p>看一个非常重要的概念：可再入程序(可重入程序）。 </p>
<p>所谓<strong>可再入程序指的是可以被多个进程同时调用的程序</strong>，因此对这个程序有限制。 也就是它必须<strong>具有的性质是它是纯代码的， 在执行过程中这个代码不会改变。</strong> 如果有改变，就需要调用它的进程提供不同的数据区。 这些改变可以放在数据区，因为代码部分是不再改变的。 实际上是大部分进程和线程都必须是可再入程序才能去运行。 </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/进程/" rel="tag"># 进程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/05/研究生学习历程/" rel="next" title="研究生学习历程">
                <i class="fa fa-chevron-left"></i> 研究生学习历程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/11/处理器调度/" rel="prev" title="处理器调度">
                处理器调度 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="ZYBO_o">
            
              <p class="site-author-name" itemprop="name">ZYBO_o</p>
              <p class="site-description motion-element" itemprop="description">C++/Python/网络安全</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zybTree" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/lin-li-yike-cao/activities" target="_blank" title="ZhiHu">
                      
                        <i class="fa fa-fw fa-globe"></i>ZhiHu</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.schwarzeni.com/" title="Schwarzeni" target="_blank">Schwarzeni</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.zhoujianguo.ltd/" title="ZhouJianGuo" target="_blank">ZhouJianGuo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jzhtech.github.io/" title="jzhBetter" target="_blank">jzhBetter</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hishiro-xiao.github.io/" title="hishiro-xiao" target="_blank">hishiro-xiao</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-进程基本概念"><span class="nav-text">一.进程基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-并发环境与并发程序"><span class="nav-text">1.并发环境与并发程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进程的定义"><span class="nav-text">2.进程的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-进程控制块PCB"><span class="nav-text">3.进程控制块PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-定义"><span class="nav-text">(1).定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-PCB包含的信息内容"><span class="nav-text">(2).PCB包含的信息内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程描述信息"><span class="nav-text">进程描述信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制信息"><span class="nav-text">进程控制信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#所拥有的资源和使用情况"><span class="nav-text">所拥有的资源和使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU现场信息"><span class="nav-text">CPU现场信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SOLARIS的进程控制块与进程表"><span class="nav-text">(3).SOLARIS的进程控制块与进程表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-进程状态及状态转换"><span class="nav-text">二.进程状态及状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-进程的三种状态及状态的转换"><span class="nav-text">1.进程的三种状态及状态的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-进程的三种基本状态"><span class="nav-text">(1).进程的三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-三状态模型及状态转换"><span class="nav-text">(2).三状态模型及状态转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进程的其他状态"><span class="nav-text">2.进程的其他状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建态"><span class="nav-text">(1).创建态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-终止态"><span class="nav-text">(2).终止态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-挂起态"><span class="nav-text">(3).挂起态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-五状态模型"><span class="nav-text">3.五状态模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-七状态模型"><span class="nav-text">4.七状态模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-进程队列"><span class="nav-text">5.进程队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-进程控制"><span class="nav-text">三.进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-进程创建"><span class="nav-text">1.进程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进程撤销"><span class="nav-text">2.进程撤销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-进程阻塞"><span class="nav-text">3.进程阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-UNIX的几个进程控制操作"><span class="nav-text">4.UNIX的几个进程控制操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-UNIX的FORK-实现"><span class="nav-text">5.UNIX的FORK()实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-进程相关概念"><span class="nav-text">四.进程相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-进程的讨论"><span class="nav-text">1.进程的讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-进程的分类"><span class="nav-text">(1).进程的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一种分类"><span class="nav-text">第一种分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二中分类"><span class="nav-text">第二中分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三种分类"><span class="nav-text">第三种分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-进程层次结构"><span class="nav-text">(2).进程层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UNIX进程家族树-init为根"><span class="nav-text">UNIX进程家族树:init为根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows-地位相同"><span class="nav-text">Windows:地位相同</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-进程与程序的区别"><span class="nav-text">2.进程与程序的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-进程地址空间"><span class="nav-text">3.进程地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-进程映像-IMAGE"><span class="nav-text">4.进程映像(IMAGE)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-上下文-CONTEXT-切换"><span class="nav-text">5.上下文(CONTEXT)切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-线程的引入"><span class="nav-text">五.线程的引入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Web服务器为例"><span class="nav-text">1.Web服务器为例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-工作方式"><span class="nav-text">(1).工作方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-无线程的情况"><span class="nav-text">(2).无线程的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务进程"><span class="nav-text">服务进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有限状态机"><span class="nav-text">有限状态机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-引进多线程之后"><span class="nav-text">(3).引进多线程之后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-引入线程的优点"><span class="nav-text">2.引入线程的优点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-从开销的角度"><span class="nav-text">(1).从开销的角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-从性能的角度"><span class="nav-text">(2).从性能的角度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六-线程的基本概念"><span class="nav-text">六.线程的基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七-线程的属性"><span class="nav-text">七.线程的属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八-线程机制的实现"><span class="nav-text">八.线程机制的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-用户级线程"><span class="nav-text">1.用户级线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-概念"><span class="nav-text">(1).概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-POSIX线程库——PTHREAD"><span class="nav-text">(2).POSIX线程库——PTHREAD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-总结"><span class="nav-text">(3).总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-核心级线程"><span class="nav-text">2.核心级线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-混合模型"><span class="nav-text">3.混合模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九-总结"><span class="nav-text">九.总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-进程"><span class="nav-text">1.进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-线程"><span class="nav-text">2.线程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZYBO_o</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">71.9k</span>
  
</div>

<!--





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>


-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":200,"height":500},"mobile":{"show":true},"encrypt":{"enable":true},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
