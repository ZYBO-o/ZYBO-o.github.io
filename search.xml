<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C Program Ⅲ 数组与指针</title>
    <url>/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅰ 字符</title>
    <url>/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-单字符I-O-getchar-和-putchar"><a href="#1-单字符I-O-getchar-和-putchar" class="headerlink" title="1.单字符I/O : getchar() 和 putchar()"></a>1.单字符I/O : getchar() 和 putchar()</h2><blockquote>
<p>getchar() 和 putchar ()每次只能输入和输出一个字符。</p>
</blockquote>
<p>ANSI C 将 <code>stdio.h</code> 头文件与getchar() 和 putchar()相关联，这就是为什么程序中将该文件包含在内的原因。而且，getchar() 和 putchar() 不是真正的函数，而是定义为预处理器宏。</p>
<h3 id="1-getchar-与-scanf-的区分与混用"><a href="#1-getchar-与-scanf-的区分与混用" class="headerlink" title="1.getchar() 与 scanf() 的区分与混用"></a>1.getchar() 与 scanf() 的区分与混用</h3><p>在缓冲输入时需要按下Enter键，这一动作还传输一个程序必须处理的换行符。而<code>getchar()</code> 读取每个字符，包括空格，制表符和换行符；但是 <code>scanf()</code> 在在<strong>读取数字</strong>时会跳过空格，制表符和换行符。举例说明：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">int</span> rows,cols;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols);</span><br><span class="line">		display(ch,rows,cols);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row,col;</span><br><span class="line">		<span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line">				<span class="built_in">putchar</span>(cr);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅰ-字符/1.png" style="zoom:50%;"></p>
<p><img src style="zoom:50%;"></p>
<blockquote>
<p>程序会在输入之后，没有做出其他输入响应之前就结束了，原因是紧跟在输入3之后的那个换行符。</p>
</blockquote>
<p><strong><code>scanf()</code>函数将该换行符留在输入队列中，与<code>scanf()</code>不同，<code>getchar()</code> 并不跳过换行符。</strong>所以在循环的下一周期，再有机会输入任何其他内容之前，这一换行符由<code>getchar()</code>读出，然后将其赋值为ch，而ch为换行符才是结束循环的条件。</p>
<p>改善程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">int</span> rows,cols;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols) != <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">		display(ch,rows,cols);</span><br><span class="line">    <span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row,col;</span><br><span class="line">		<span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line">				<span class="built_in">putchar</span>(cr);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅰ-字符/2.png" style="zoom:50%;"></p>
<blockquote>
<p>程序跳过了一个输入周期中输入的最后一个数字与下一行开始处输入的字符之间的所有换行符和空格。</p>
</blockquote>
<h3 id="2-输入流和数字"><a href="#2-输入流和数字" class="headerlink" title="2.输入流和数字"></a>2.输入流和数字</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">is 28 12.4</span><br></pre></td></tr></table></figure></div>
<p>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。<font color="red">但是对 C程序而言，这是一个字节流。</font><strong>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等</strong>。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">	<span class="built_in">putchar</span>(ch); <span class="comment">// 处理错误的输入</span></span><br></pre></td></tr></table></figure></div>
<p>虽然输入流由字符组成，但是也可以设置<code>scanf()</code>函数把它们转换成数值。例如，考虑下面的输入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure></div>
<p>如果在<code>scanf()</code>函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，“它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，<code>scanf()</code>同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，<code>scanf()</code>也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。<br><strong>简而言之，输入由字符组成，但是<code>scanf()</code>可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而<code>getchar()</code>和使用%c的<code>scanf()</code>接受所有的字符。</strong></p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅵ 文件</title>
    <url>/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅳ 字符串和字符串函数</title>
    <url>/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五-字符串函数"><a href="#五-字符串函数" class="headerlink" title="五.字符串函数"></a>五.字符串函数</h1><h2 id="1-strlen-函数"><a href="#1-strlen-函数" class="headerlink" title="1.strlen()函数"></a>1.strlen()函数</h2><p>strlen()函数用于统计字符串的长度。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* test_fit.c -- try the string-shrinking function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* contains string function prototypes */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mesg[] = <span class="string">"Things should be as simple as possible,"</span></span><br><span class="line">    <span class="string">" but not simpler."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    fit(mesg,<span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Let's look at some more of the string."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg + <span class="number">39</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size)</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/1.png" style="zoom:50%;"></p>
<p><code>fit()</code>函数把第39个元素的逗号替换成<code>&#39;\0&#39;</code>字符。<code>puts()</code>函数在空字符处停止输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把这些字符打印了出来：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(mesg + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></div>
<p>表达式<code>mesg + 39</code>是<code>mesg[39]</code>的地址，该地址上储存的是空格字符。所以<code>put()</code>显示该字符并继续输出直至遇到原来字符串中的空字符.</p>
<p>演示过程如下图所示：</p>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/2.png" style="zoom:50%;"></p>
<h2 id="2-strcat-和strncat-函数"><a href="#2-strcat-和strncat-函数" class="headerlink" title="2.strcat()和strncat()函数"></a>2.strcat()和strncat()函数</h2><p><code>strcat()</code>（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p>
<p><code>strcat()</code>函数的类型是<code>char *</code>（即，指向char的指针）。<code>strcat()</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p>
<p><code>strcat()</code>的用法:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* str_cat.c -- joins two strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  /* declares the strcat() function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/3.png" style="zoom:50%;"></p>
<p><code>strcat()</code>函数问题：</p>
<font color="red">`strcat()`函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。</font>

<p>解决方法：</p>
<ul>
<li>用<code>strlen()</code>查看第1个数组的长度。注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。</li>
</ul>
<ul>
<li>用<code>strncat()</code>，该函数的第3 个参数指定了最大添加字符数。</li>
</ul>
<p><code>strncat()</code>例子</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* join_chk.c -- joins two strings, check size first */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">    <span class="keyword">int</span> available;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    s_gets(flower, SIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(addon) + <span class="built_in">strlen</span>(flower) + <span class="number">1</span>) &lt;= SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">    <span class="built_in">puts</span>(flower);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite bug?"</span>);</span><br><span class="line">    s_gets(bug, BUGSIZE);</span><br><span class="line">    available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(bug, addon, available);</span><br><span class="line">    <span class="built_in">puts</span>(bug);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/4.png" style="zoom:50%;"></p>
<blockquote>
<p>strcat()和 gets()类似，也会导致缓冲区溢出。为什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？<strong>这也许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的。</strong>无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的使用安全。</p>
</blockquote>
<h2 id="三-strcmp-函数"><a href="#三-strcmp-函数" class="headerlink" title="三.strcmp()函数"></a>三.strcmp()函数</h2>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <url>/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅴ 存储类,链接和内存管理</title>
    <url>/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。</p>
</blockquote>
<h1 id="一-存储类别"><a href="#一-存储类别" class="headerlink" title="一.存储类别"></a>一.存储类别</h1><p><strong>硬件方面来看：</strong>被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<code>对象(object)</code>。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)。</p>
<p><strong>软件方面来看：</strong>程序需要一种方法访问对象。这可以通过声明变量来完成。</p>
<p>以下面的例子作为分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>
<p>该声明创建了一个名为<code>entity</code>的<code>标识符(identifier)</code>。标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符<code>entity</code>即是软件(即C程序)指定<strong>硬件内存中的对象的方式</strong>。该声明还提供了<strong>储存在对象中的值</strong>。</p>
<p>但是变量名不是指定对象的唯一途径。以下面的例子作为分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>
<p>第1行声明中，<code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与 <code>entity</code>指定的对象相同。一般而言，那些指定对象的表达式被称为<em>左值</em>。所以，<code>entity</code>既是标识符也是左值；<code>*pt</code>既是表达式也是左值。按照这个思路，<code>ranks + 2 * entity</code>既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式<code>*(ranks + 2 * entity)</code>是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <url>/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git提速代理</title>
    <url>/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>因为平时在Ubuntu虚拟机上使用Git clone的时候速度特别慢，使用干脆写个代理文件进行提速。</p>
</blockquote>
<h2 id="梯子准备"><a href="#梯子准备" class="headerlink" title="梯子准备"></a>梯子准备</h2><p>在主机上挂个梯子，然后查看IP地址与端口(确保能使用)。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">	options=400&lt;CHANNEL_IO&gt;</span><br><span class="line">	ether 38:f9:d3:8d:58:3e</span><br><span class="line">	inet6 fe80::1434:df1:87d5:7e09%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">	inet 192.168.1.4 netmask 0xffffff00 broadcast 192.168.1.255</span><br><span class="line">	nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/11/Git提速代理/1.png" style="zoom:50%;"></p>
<p>我的IP与端口:192.168.1.4:7890</p>
<h2 id="写代理文件"><a href="#写代理文件" class="headerlink" title="写代理文件"></a>写代理文件</h2><p>在Ubuntu上写代理文件，在与Desktop同一级的目录下新建.gitconfig文件并进行编辑。</p>
<p><img src="//ZYBO_o.github.io/2020/03/11/Git提速代理/2.png" alt></p>
<p>这样就可以加速了。实践一下。</p>
<p><img src="//ZYBO_o.github.io/2020/03/11/Git提速代理/3.png" alt></p>
<p>这个速度就爽多！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <url>/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下C链接Mysql</title>
    <url>/2020/03/02/Linux%E4%B8%8BC%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装数据库"><a href="#1-安装数据库" class="headerlink" title="1.安装数据库"></a>1.安装数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqld-dev</span><br></pre></td></tr></table></figure></div>
<h2 id="2-查看安装包"><a href="#2-查看安装包" class="headerlink" title="2.查看安装包"></a>2.查看安装包</h2><p>2.查看本地有没有安装mysql的开发包。命令是  ‘mysql_config —cflags —libs’如果有安装就会有一串编译选项和连接库。如果没有就自行安装 mysql-devel-<strong>*</strong>的rpm包后面是版本号。mysql开发包提供了基本操作接口。安装后头文件在/usr/include/mysql 而动态库在 /usr/lib/mysql 上。</p>
<p><img src="//ZYBO_o.github.io/2020/03/02/Linux下C链接数据库/1.png" alt></p>
<h2 id="3-编写C程序链接数据库"><a href="#3-编写C程序链接数据库" class="headerlink" title="3.编写C程序链接数据库"></a>3.编写C程序链接数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *conn;</span><br><span class="line">    MYSQL_RES *res;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> *server = <span class="string">"localhost"</span>;</span><br><span class="line">   <span class="keyword">char</span> *user = <span class="string">"root"</span>;</span><br><span class="line">   <span class="keyword">char</span> *password = <span class="string">"ZYB110929"</span>; <span class="comment">/* 此处改成你的密码 */</span></span><br><span class="line">   <span class="keyword">char</span> *database = <span class="string">"mysql"</span>;</span><br><span class="line"></span><br><span class="line">    conn = mysql_init(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Connect to database */</span></span><br><span class="line">   <span class="keyword">if</span> (!mysql_real_connect(conn, server,</span><br><span class="line">          user, password, database, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* send SQL query */</span></span><br><span class="line">   <span class="keyword">if</span> (mysql_query(conn, <span class="string">"show tables"</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    res = mysql_use_result(conn);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* output table name */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"MySQL Tables in mysql database:\n"</span>);</span><br><span class="line">   <span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, row[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* close connection */</span></span><br><span class="line">    mysql_free_result(res);</span><br><span class="line">    mysql_close(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test $(mysql_config --cflags) $(mysql_config --libs)</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/02/Linux下C链接数据库/2.png" alt></p>
<p>实践成功。</p>
<p>​            </p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mysql</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>东大一个月以来的反思</title>
    <url>/2019/10/04/%E4%B8%9C%E5%A4%A7%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BB%A5%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1 跑步已进入瓶颈期，6km以下已经不怎么出汗。改变有氧运动为跳绳后发现10mins就能汗如雨下，搭配着来很重要。其次，不能间断超过三天，否则要浪费一天时间去重新适应。现在又办理了健身卡，今天晚上也要制定减脂增肌的健身与饮食计划，一定要在元旦之前减到65kg以下。</p>
<hr>
<p>2 以后就算是和老师们聚餐也要控制酒精摄入。更要学会委婉的拒绝。</p>
<hr>
<p>3 事实证明自己之前的胡思乱想归根结底还是闲的，让自己有计划有节奏的忙碌起来。爱情这东西命里有时终须有，命里无时也莫强求，对现在的自己而言没有那么重要。</p>
<hr>
<p>4 至于以后到底读不读博，就业是否留在实验室得等到寒假之后再思考，这个学期主要是找到物理层安全的价值点与兴趣点所在，多读论文。</p>
<hr>
<p>5 不要过于自卑，自己也没有那么弱，运气只会对努力的，有准备的人奏效，它也是实力的一种，不然自己也不会在这进修了!</p>
<hr>
<p>6 体态和肤质只需坚持一个季度就能改变，并不难。细细想来和当初考研异曲同工，只要稳扎稳打一年就能改变所在平台，这是回报率很高的“交易”。等到11月发了奖学金可以试着买一套护肤的保养保养，毕竟自己的皮肤也需要保护，自己的形象也很重要。</p>
<hr>
<p>7 年少时觉得那些大道理似乎很空，所以忘得很快。现在读的书慢慢多了，经历的慢慢丰富了，身边却很少有人那么“苦口婆心”的教导自己，很感谢随机过程老师每节课这么督促我们，仔细琢磨后觉得既兴奋有懊悔，以后要把所以空闲时间都用在学习与思考上。</p>
<hr>
<p>8 老师们都说如果能把高考时的拼劲放到现在，没有什么是解决不了的。不过高三时的自己并没有那么拼命，也让自己刻意忘记了那时的日子。所以自己不妨试着再找回考研时候的拼劲，时刻思考，时刻背诵。我相信自己一定会有所成的。</p>
<hr>
<p>9 如切如磋，如琢如磨，战战兢兢，如履薄冰。希望不负“百载文枢江左，东南辈出英豪。”的期望!</p>
]]></content>
      <categories>
        <category>感悟与反思</category>
      </categories>
      <tags>
        <tag>感悟与反思</tag>
      </tags>
  </entry>
  <entry>
    <title>关于方向&amp;关于C++</title>
    <url>/2020/03/01/%E5%85%B3%E4%BA%8E%E6%96%B9%E5%90%91-%E5%85%B3%E4%BA%8EC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>就业与思考</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>减脂塑性规划</title>
    <url>/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-健身部位与动作"><a href="#一-健身部位与动作" class="headerlink" title="一.健身部位与动作"></a>一.健身部位与动作</h1><h2 id="1-胸部"><a href="#1-胸部" class="headerlink" title="1.胸部"></a>1.胸部</h2><ul>
<li><p><strong>俯卧撑</strong></p>
<blockquote>
<p>可以练到胸肌、肱三头肌，甚至可以练到我们的肩部，是一个非常经典的自重动作。</p>
</blockquote>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/1.jpg" alt></p>
<ul>
<li><strong>平板杠铃卧推（宽握）：</strong></li>
</ul>
<blockquote>
<p>需要注意三点，一是卧推时杠铃需要自然推起（下放在胸部而顶点在肩关节上方），二是杠铃要尽量下放到贴近胸部的位置再推起，三是卧推时杠铃下放触及的应该是乳头附近的位置。 </p>
<p>很多新手卧推时，推起放下往往不是垂直的，下放往往放到肩部附近，这就是错误的推法，这样卧推是刺激不到胸肌的。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/2.jpg" alt></p>
<ul>
<li><strong>上斜板杠铃卧推（宽握</strong></li>
</ul>
<blockquote>
<p>其实就是将平板的角度向上倾斜45~60度<br>上斜板卧推需要注意的是，下放的位置不是乳头附近，而是下放到锁骨即可。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/3.jpg" alt></p>
<ul>
<li><strong>下斜板哑铃卧推（宽握）</strong></li>
</ul>
<blockquote>
<p>下斜卧推杠铃是下放到乳头往下3cm的位置，但是远没有到腹部。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/4.jpg" alt></p>
<ul>
<li><strong>窄握</strong></li>
</ul>
<blockquote>
<p>下面这是平板杠铃卧推（窄握）。窄握是提高卧推力量的很好的方法，和宽握相比，窄握中肱三头肌受力更大，卧推力量遇到瓶颈时，可以用窄握来突破。上斜和下斜的窄握就不贴了。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/5.jpg" alt></p>
<ul>
<li><strong>绳索飞鸟</strong></li>
</ul>
<blockquote>
<p>这应该是对胸肌中缝刺激最大的动作了。</p>
<p>这个动作需要注意的是，手要尽量打开，肘关节微曲，不要用腰背过分的借力。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/6.jpg" alt></p>
<ul>
<li><strong>哑铃飞鸟</strong></li>
</ul>
<blockquote>
<p>做哑铃飞鸟时你去想象你前面有个人，你要去「拥抱」他，就是用那种拥抱的感觉去练飞鸟就对了。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/7.jpg" alt></p>
<ul>
<li><strong>双臂杆屈伸</strong></li>
</ul>
<blockquote>
<p>这是在飞鸟和卧推之外的动作，根据身体倾向状况，刺激的肌肉部位也不同，身体越前倾，胸大肌的刺激越大，越直立，就越容易刺激肱三头肌。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/8.jpg" alt></p>
<hr>
<h2 id="2-腹部"><a href="#2-腹部" class="headerlink" title="2.腹部"></a>2.腹部</h2><ul>
<li><strong>上腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/9.jpg" alt></p>
<blockquote>
<p>注意不是做全程,而是双臂托着头向上抬起,感觉上面有个鱼饵要去吃的感觉.(60+)</p>
</blockquote>
<ul>
<li><strong>中腹肌、下腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/10.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/11.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/12.jpg" alt></p>
<blockquote>
<p>对于下腹肌有非常好的效果,坚持一段时间会出现V字型的线条</p>
<p>注意：腿部不要碰到地面。50+</p>
</blockquote>
<ul>
<li><strong>侧腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/13.jpg" alt></p>
<blockquote>
<p>注意点，全程上胸处于抬起状态，而不是躺下再起来，快速交替触碰.(100+)</p>
</blockquote>
<ul>
<li><strong>中腹肌</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/14.jpg" alt></p>
<blockquote>
<p>注意这个动作要水平的打开,而不是向下去打开,完全可以在地上做以臀部为支点.(60+)</p>
</blockquote>
<ul>
<li>中腹肌</li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/15.jpg" alt></p>
<blockquote>
<p>这个动作完全可以不负重,空手快速进行.(60+)</p>
</blockquote>
<hr>
<h2 id="3-腿"><a href="#3-腿" class="headerlink" title="3.腿"></a>3.腿</h2><ul>
<li><strong>颈后杠铃深蹲</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/16.gif" alt></p>
<blockquote>
<p>一个合格的负重深蹲动作，需要让你有顺畅的感觉，不别扭，可以自由发力的感觉，膝盖不要内扣，快起慢下，感受大腿燃烧的绷感.</p>
<p><strong>站距</strong>：稍微比肩膀宽一点，八字步站开，30度左右.</p>
<p><strong>膝盖的朝向和脚一样，朝外，无论多大重量，绝对不能内扣！！</strong></p>
</blockquote>
<ul>
<li><strong>箭步深蹲</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/17.gif" alt></p>
<blockquote>
<p>十分有效的动作，深蹲的一种，对塑造臀部也十分有帮助。</p>
<p>要领：膝盖要中立，不要出现单侧内扣.</p>
</blockquote>
<hr>
<h2 id="4-背"><a href="#4-背" class="headerlink" title="4.背"></a>4.背</h2><ul>
<li><strong>无敌黄金引体向上</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/18.jpg" alt></p>
<blockquote>
<p>主要可以锻炼到的肌群有：背阔肌，大圆肌，小园肌，肱二头肌。次要肌肉：三角肌后束，胸肌，腹肌，斜方肌等。</p>
</blockquote>
<ul>
<li><p><strong>高位下拉</strong> </p>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/19.jpg" alt></p>
</li>
</ul>
<blockquote>
<p> 需要注意：背要直，可以稍微向后仰一点，调整膝垫至合适位置。膝垫可以避免身体因为阻力而上升。吐气的同时将肩膀和上臂向后下方拉动，拉下把手直至碰到上胸。</p>
<p>提示：完全收紧时集中注意力收缩后背肌肉。动作中上躯应保持固定，只有手臂运动。前臂只需抓握杠杆，没有其他动作，不要用前臂拉动把手。</p>
<p>呼吸：用力下拉时呼气，还原时吸气</p>
</blockquote>
<ul>
<li><strong>宽度动作三直臂下拉</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/20.jpg" alt></p>
<blockquote>
<ol>
<li>正握握住宽把，掌心向下，双臂距离超过肩宽。后退60厘米左右。</li>
<li>上身向前，弯向前倾斜30度，双手在前方伸直,手肘略弯.。手臂无法完全伸直就继续后退，直到手臂完全伸直，弯腰，背阔肌绷紧，准备开始。</li>
<li>保持手臂伸直,收缩背阔肌下拉把手直至大腿,</li>
</ol>
</blockquote>
<ul>
<li><strong>哑铃划船</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/21.jpg" alt></p>
<blockquote>
<p>这个动作会让你的鼠蹊部（就是腹股沟，还是不懂就叫：腚沟子）处于一个容易受伤的状态.</p>
</blockquote>
<ul>
<li><strong>坐姿划船：</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/22.jpg" alt></p>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/23.gif" alt></p>
<blockquote>
<p>1 两腿踩住前方的踏板，<strong>微屈膝，腿不可伸直</strong>，两手紧握三角形（或其他形状的）手柄，双臂前伸，<strong>腰腹固定</strong>,挺胸抬头。</p>
<p>2.收缩背部肌肉，加紧肩胛骨，用这股力量，将手柄拉至腹部，尽可能地向后牵拉你的双肩和双肘，直到手柄接触到你的身体中部。可以保持顶峰收缩1-2秒，努力挤压你的肩胛骨，得到最大程度的刺激.</p>
<p>3.以背阔肌的力量控制还原，所谓的快拉慢回，控制速度，但是！不需要过慢。</p>
</blockquote>
<ul>
<li>硬拉</li>
</ul>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/24.gif" alt></p>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/25.jpg" alt></p>
<p><img src="//ZYBO_o.github.io/2019/10/18/减脂塑性规划/26.jpg" alt></p>
<blockquote>
<p>这是一个垂直运动的轨迹，沉肩，核心收紧。发力的时候，感受力从地起，腘绳肌，大腿，臀部，下背，一气呵成，感受力从地起，屁股夹紧的感觉。</p>
<p>呼吸：硬拉在上了大重量以后（4-6RM甚至更重）用普通的呼吸方法是会出现危险的，为什么？</p>
<p>因为，在大重量的硬拉训练中，脊椎面临很大的压力，普通的呼吸造成的压力很难维持脊椎中立稳定，所以要憋气！就是所谓瓦式呼吸。先在动作进行前吸一口气，将气回压在下腹创造腹内压（往内挤压），努力紧绷你的腰椎周围肌群，想象别人要在你肚子上打一拳。直到完成一次动作后才进行吐气，动作全程是憋气的。再说一遍：准备动作深吸一口气，并且在发力的时候紧闭声门hold住这一口气。</p>
</blockquote>
]]></content>
      <categories>
        <category>减脂塑形</category>
      </categories>
      <tags>
        <tag>减脂塑形</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<blockquote>
<p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p>
<ul>
<li>可以输入到计算机中。</li>
<li>能被计算机程序处理。</li>
</ul>
</blockquote>
<p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p>
<blockquote>
<p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p>
</blockquote>
<p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p>
<blockquote>
<p>性质相同，是指数据元素具有相同数量和类型的数据项。</p>
</blockquote>
<p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<blockquote>
<p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅰ绪论/1.png" style="zoom:50%;"></p>
<h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote>
<p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅰ绪论/2.png" style="zoom:50%;"></p>
<h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p>
<blockquote>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p>
</blockquote>
<p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅰ绪论/3.png" style="zoom:50%;"></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅰ绪论/4.png" style="zoom:40%;"></p>
<h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<blockquote>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
</blockquote>
<p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>
<h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>数据结构绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅴ树</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h2><h3 id="1-需要掌握的定义："><a href="#1-需要掌握的定义：" class="headerlink" title="1.需要掌握的定义："></a>1.需要掌握的定义：</h3><ul>
<li>结点(根结点，双亲结点，子节点，兄弟结点)</li>
<li>子树和空树</li>
<li>结点的深度和高</li>
<li>有序树和无序树</li>
<li>森林</li>
<li>树的表示方法</li>
</ul>
<blockquote>
<p>对于结点ni，ni的深度是指<strong>从根到ni</strong>的唯一路径的长；ni的高是指<strong>从ni到一片树叶</strong>的最长路径的长。</p>
</blockquote>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/1.png" style="zoom:25%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图1：线性结构与树结构对比</div>
</center>

<p>&lt;/br&gt;</p>
<h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二.二叉树"></a>二.二叉树</h2><h3 id="1-二叉树需要掌握的概念"><a href="#1-二叉树需要掌握的概念" class="headerlink" title="1.二叉树需要掌握的概念"></a>1.二叉树需要掌握的概念</h3><h4 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="(1).二叉树的定义"></a>(1).二叉树的定义</h4><ul>
<li>有序树</li>
<li>节点的度只能为0，1，2</li>
</ul>
<h4 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="(2).二叉树的性质"></a>(2).二叉树的性质</h4><ul>
<li>第$i$层最多有 $2^{i-1}$ 个结点。</li>
<li>若深度为$K$，则最多有$2^K-1$个结点。</li>
<li>终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$=$n_2$+1。</li>
</ul>
<blockquote>
<p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点(设为$n_1$)，那么总结点$n=n_0+n_1+n_2$。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数$n=B+1$。而分枝数是可以通过$n_1$和$n_2$表示的，即$B=n_1+2<em>n_2$。所以，n用另外一种方式表示为$n=n_1+2</em>n_2+1$。两种方式得到的n值组成一个方程组，就可以得出$n_0=n_2+1$。</p>
</blockquote>
<h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="(3).满二叉树"></a>(3).满二叉树</h4><ul>
<li><p>概念定义</p>
<ul>
<li>除了叶子结点外其余结点的度都为2，则为满二叉树。</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>满二叉树中第i层的节点数为$2^n-1$个。</li>
<li>深度为k的满二叉树必有$2^k-1$个节点，叶子数为$2^k-1$。</li>
<li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有n个节点的满二叉树的深度为 $log_2(n+1)$。</li>
</ul>
</li>
</ul>
<h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="(4).完全二叉树"></a>(4).完全二叉树</h4><ul>
<li>概念定义<ul>
<li>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，且<font color="red"><strong>最后一层的结点依次从左到右分布</strong></font>，则此二叉树被称为完全二叉树。</li>
</ul>
</li>
</ul>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/2.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图2：完全二叉树与非完全二叉树</div>
</center>


<ul>
<li>性质<ul>
<li>n 个结点的完全二叉树的深度为$⌊log_2n⌋+1$。</li>
<li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号,对于任意一个结点 i,完全二叉树还有以下几个结论成立:<ul>
<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>
<li>如果2*i&gt;n(总结点的个数)，则结点i肯定没有左孩子(为叶子结点)；否则其左孩子是结点2*i 。</li>
<li>如果2*i+1&gt;n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&lt;/br&gt;</p>
<h3 id="2-二叉树的存储结构"><a href="#2-二叉树的存储结构" class="headerlink" title="2.二叉树的存储结构"></a>2.二叉树的存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="(1).顺序存储结构"></a>(1).顺序存储结构</h4><p>二叉树的顺序存储，指的是使用顺序表(数组)存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，<font color="red">如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树，然后从根节点开始，按照层次依次将树中节点存储到数组即可。</font></p>
<p>如下图所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/3.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图3：普通二叉树的转换</div>
</center>

<p> &lt;/br&gt;</p>
<p>普通二叉树的数组存储状态如下图所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/4.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图4：普通二叉树的存储状态</div>
</center>

<p>&lt;/br&gt;</p>
<h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="(2).链式存储结构"></a>(2).链式存储结构</h4><center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/5.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图5：普通二叉树示意图</div>
</center>

<p>如图5所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图5对应的链式存储结构如图6所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/6.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图6：二叉树链式存储结构示意图</div>
</center>

<p>由图可知采用链式存储二叉树时，其节点结构由 3 部分构成：</p>
<ul>
<li>指向左孩子节点的指针（Left）；</li>
<li>节点存储的数据（Element）；</li>
<li>指向右孩子节点的指针（Right）；</li>
</ul>
<p>表示该节点结构的 C 语言代码为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-二叉树遍历介绍"><a href="#3-二叉树遍历介绍" class="headerlink" title="3.二叉树遍历介绍"></a>3.二叉树遍历介绍</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="(1).层序遍历"></a>(1).层序遍历</h4><p>通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/7.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图7：层次遍历二叉树示意图</div>
</center>

<h4 id="2-普通遍历"><a href="#2-普通遍历" class="headerlink" title="(2).普通遍历"></a>(2).普通遍历</h4><p>按照 “从上到下，从左到右” 的顺序遍历整棵二叉树，此种方式称为普通遍历。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/8.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图8：普通遍历二叉树示意图</div>
</center>

<p>在层次遍历中，整个遍历过程只经过各个节点一次，因此在层次遍历过程，每经过一个节点，都必须立刻访问该节点，否则错失良机，后续无法再对其访问。</p>
<p>而普通遍历方式则不同，通过观察图 7 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 7 中的节点 2 为例，如图 8 所示，它被经过了 3 次。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/9.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图9：遍历节点2的过程示意图</div>
</center>

<p>因此，在编程实现时可以设定真正访问各个节点的时机，换句话说，既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。这也就引出了以下 3 种遍历二叉树的算法：</p>
<ol>
<li><strong><font color="red">先序遍历</font>：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 9 中的 ①）；</strong></li>
<li><strong><font color="red">中序遍历</font>：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 9 中的 ②）；</strong></li>
<li><strong><font color="red">后序遍历</font>：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 9 中的 ③）；</strong></li>
</ol>
<h2 id="三-遍历二叉树代码实现"><a href="#三-遍历二叉树代码实现" class="headerlink" title="三.遍历二叉树代码实现"></a>三.遍历二叉树代码实现</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>二叉树先序遍历的实现思想是：</p>
<ol>
<li>访问根节点；</li>
<li>访问当前节点的左子树；</li>
<li>若当前节点无左子树，则访问当前节点的右子树；</li>
</ol>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/10.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图10：二叉树</div>
</center>

<p>因此，图 10 中二叉树采用先序遍历得到的序列为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></div>
<h4 id="1-递归先序遍历"><a href="#1-递归先序遍历" class="headerlink" title="(1).递归先序遍历"></a>(1).递归先序遍历</h4><p>前序的规则就是<code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>.在调用递归前进行节点操作。对于先序，就是先访问(输出)该节点。而递归左，递归右侧，会优先递归左侧。<code>直到没有左节点</code>。才会停止。访问次序大致为：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/11.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图11：递归先序遍历过程</div>
</center>

<h4 id="2-非递归优先遍历"><a href="#2-非递归优先遍历" class="headerlink" title="(2).非递归优先遍历"></a>(2).非递归优先遍历</h4><p>非递归的先序利用栈的性质替代递归，因为<code>递归有时候在效率</code>方面不是令人满意的。<br>因为栈的顺序为后进先出。递归是左递归，右递归。<strong>所以利用栈要相反。</strong>利用递归的思路，需要先把右节点进栈，再遍历(输出)左节点。然后循环一直到最后，达到和递归顺序相仿效果。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/12.jpg" style="zoom:70%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图12：非递归先序遍历过程</div>
</center>

<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h4><p><strong>递归优先遍历：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionPreOrderTraverse</span><span class="params">( Tree T )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DisplayElement( T );<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Left );<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Right );<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>非递归优先遍历：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span> = CreateStack( <span class="number">20</span> );<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    Tree p;<span class="comment">//临时指针</span></span><br><span class="line">    Push( T ,<span class="built_in">stack</span> );<span class="comment">//根结点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">stack</span>-&gt;TopOfStack != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Top( <span class="built_in">stack</span> );<span class="comment">//取栈顶元素</span></span><br><span class="line">        Pop( <span class="built_in">stack</span> );<span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            DisplayElement( p );<span class="comment">//调用结点的操作函数</span></span><br><span class="line">            <span class="comment">//如果该结点有右孩子，右孩子进栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;Right) &#123;</span><br><span class="line">                Push(  p-&gt;Right ,<span class="built_in">stack</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;Left;<span class="comment">//一直指向根结点最后一个左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><h2 id="四-二叉树查找树"><a href="#四-二叉树查找树" class="headerlink" title="四.二叉树查找树"></a>四.二叉树查找树</h2><h2 id="五-平衡树-AVL"><a href="#五-平衡树-AVL" class="headerlink" title="五.平衡树(AVL)"></a>五.平衡树(AVL)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>AVL树本质上是<strong>一棵二叉查找树</strong>，但是它又具有以下特点：<strong><font color="red">它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font></strong>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树。</p>
<p>平衡二叉树和非平衡二叉树对比的例图：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/13.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图13：左边为一般二叉树，右边为二叉查找树</div>
</center>

<p><strong>平衡因子(bf)：</strong>结点的左子树的深度减去右子树的深度，那么显然-1&lt;=bf&lt;=1;</p>
<h3 id="2-AVL的作用"><a href="#2-AVL的作用" class="headerlink" title="2.AVL的作用"></a>2.AVL的作用</h3><p>对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度 $ O(log_2n)$ 同时也由此而决定。<strong>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 $O(n)$  </strong>。</p>
<p>所以可以通过随机化建立二叉搜索树来尽量的避免这种情况，<strong><font color="red">但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</font></strong></p>
<p>例如：按顺序将一组数据1,2,3,4,5,6分别插入到一棵空二叉查找树和AVL树中，插入的结果如下图：</p>
<p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/14.png" style="zoom:30%"><br>  <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/15.png" style="zoom:40%"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图14：左边为二叉搜索树，右边为二叉平衡树</div></center></p>
<p>由上图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<strong>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是 $O(N)$ ，而AVL树就不会出现这种情况，树的高度始终是 $O(lgN)$ .高度越小，对树的一些基本操作的时间复杂度就会越小。这也就是引入AVL树的原因。</strong></p>
<h3 id="3-AVL的操作"><a href="#3-AVL的操作" class="headerlink" title="3.AVL的操作"></a>3.AVL的操作</h3><p>AVL树的操作基本和二叉查找树一样，这里关注的是两个变化很大的操作：<strong>插入</strong>和<strong>删除！</strong></p>
<p>AVL树不仅是一颗二叉查找树，它还有其他的性质。<strong>如果按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以要做一些特殊的处理，包括：单旋转和双旋转！</strong></p>
<h4 id="1-单选转"><a href="#1-单选转" class="headerlink" title="(1).单选转"></a>(1).单选转</h4><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/16.png" style="zoom:90%"><br> <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/17.png" style="zoom:100%;"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图15：单选转</div></center></p>
<p>显示单选转</p>
]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅳ串</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅵ图</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅷ排序</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h1>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅶ查找</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生学习历程</title>
    <url>/2020/08/05/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2020年9学习计划"><a href="#2020年9学习计划" class="headerlink" title="2020年9学习计划"></a>2020年9学习计划</h1><h4 id="9月第一周"><a href="#9月第一周" class="headerlink" title="9月第一周"></a>9月第一周</h4><p>也就成功进行了Debug<code>l1app</code>子项目，论文没有进展，数据结构也没有真的开始，要戒骄戒躁啊。重新规划一下吧。</p>
<h2 id="2020年9月第二周"><a href="#2020年9月第二周" class="headerlink" title="2020年9月第二周"></a>2020年9月第二周</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul>
<li>论文阅读<ul>
<li>自适应矩阵完全搞懂</li>
<li>综述论文修改+排版</li>
<li>论文汇报</li>
</ul>
</li>
<li>论文仿真<ul>
<li>K临近算法</li>
</ul>
</li>
<li>数据结构<ul>
<li>基本概念+线性结构</li>
</ul>
</li>
<li>操作系统<ul>
<li>概述——书 + 视频</li>
</ul>
</li>
<li>项目<ul>
<li>调通 testMac 与 l1app</li>
</ul>
</li>
</ul>
<h3 id="每日任务"><a href="#每日任务" class="headerlink" title="每日任务"></a>每日任务</h3><h4 id="9月7日"><a href="#9月7日" class="headerlink" title="9月7日"></a>9月7日</h4><ul>
<li>[x] 综述论文修改完三分之一</li>
<li>[x] 汇报的论文完成三分之一</li>
<li>[x] VScode Debug例子结局，能够同时在Server与Client进行调试</li>
</ul>
<p>明天开始晚上停止打球了，不然累了什么都不想干。坚持跳绳21天，每天5k个，看看究竟能瘦多少。</p>
<h4 id="9月8日"><a href="#9月8日" class="headerlink" title="9月8日"></a>9月8日</h4><ul>
<li>[x]   综述论文修改到射频增强部分</li>
<li>[x]  汇报的论文完成三分之二</li>
<li>[x]  数据结构完成概述笔记</li>
<li>[x] 跳绳5k</li>
</ul>
]]></content>
      <categories>
        <category>研究生学习</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅱ 函数</title>
    <url>/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>什么是函数？</strong>函数（function）是完成特定任务的独立程序代码单元。</p>
<p><strong>为什么要使用函数？</strong>首先，使用函数可以省去编写重复代码，提高效率。其次，让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。如果不是自己编写函数，根本不用关心黑盒的内部行为；以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上</p>
</blockquote>
<p>以下面程序为例分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;            /* for strlen() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaces;</span><br><span class="line">    </span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);   <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    show_n_char(SPACE, <span class="number">12</span>);    <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line">    spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* Let the program calculate    */</span></span><br><span class="line">    <span class="comment">/* how many spaces to skip      */</span></span><br><span class="line">    show_n_char(SPACE, spaces);<span class="comment">/* use a variable as argument   */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line">    show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* an expression as argument    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* show_n_char() definition */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>程序在3处使用了<code>show_n_char()</code>标识符：<strong>函数原型(function prototype)</strong>告诉编译器函数<code>show_n_char()</code>的类型；<strong>函数调用(function call)</strong>表明在此处执行函数；<strong>函数定义(function definition)</strong>明确地指定了函数要做什么。</p>
<p><strong>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。</strong>因此，在main()函数定义的前面</p>
<h2 id="1-对于函数声明"><a href="#1-对于函数声明" class="headerlink" title="1.对于函数声明"></a>1.对于函数声明</h2><p>出现了下面的ANSI C风格的函数原型：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>圆括号表明<code>show_n_char()</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。后面的<code>char</code>,<code>int</code>（在圆括号中）表明该函数带有两个参数，一个为<code>char</code>类型，一个为<code>int</code>类型。分号表明这是在声明函数，不是定义函数。<font color="red">函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。</font></p>
<blockquote>
<p>程序把 <code>show_n_char()</code>原型置于<code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p>
</blockquote>
<h2 id="2-对于函数参数"><a href="#2-对于函数参数" class="headerlink" title="2.对于函数参数"></a>2.对于函数参数</h2><p>还是以这个有ANSI C风格的函数头为例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure></div>
<p>该行告知编译器<code>show_n_char()</code>使用两个参数ch和num，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数（formal argument，但是最近的标准推荐使用formal parameter）</strong>，简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。</p>
<blockquote>
<p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：void dibs(int x, y, z)　　　　 /<em> 无效的函数头 </em>/</p>
</blockquote>
<p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，也可以省略变量名：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>在函数调用中，<strong>实际参数（actual argument，简称实参）</strong>提供了ch和num的值。考虑上例中第1次调用<code>show_n_char()</code>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">show_n_char(SPACE, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></div>
<p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，<font color="red">形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。</font></p>
<blockquote>
<p>1.注意 实际参数和形式参数：<strong>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</strong></p>
<p>2.<font color="red">为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="3-关于return从函数中返回值"><a href="#3-关于return从函数中返回值" class="headerlink" title="3.关于return从函数中返回值"></a>3.关于return从函数中返回值</h2><p>函数的返回值可以把信息从被调函数传回主调函数。关键字<code>return</code>后面的表达式的值就是函数的返回值。</p>
<p>问题：如果函数返回值的类型与函数声明的类型不匹配会怎样？</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">what_if</span><span class="params">(<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">double</span>　z　=　<span class="number">100.0</span>　/　(<span class="keyword">double</span>)　n;</span><br><span class="line">		<span class="keyword">return</span> z; <span class="comment">// 会发生什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">result = what_if(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div>
<p>虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。</p>
<h2 id="4-查找地址：-amp-运算符"><a href="#4-查找地址：-amp-运算符" class="headerlink" title="4.查找地址：&amp;运算符"></a>4.查找地址：&amp;运算符</h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。</p>
<p>下面例子中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* loccheck.c  -- checks to see where variables are stored  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;                      <span class="comment">/* declare function  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;             <span class="comment">/* local to main()   */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span>                   <span class="comment">/* define function   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">10</span>;                     <span class="comment">/* local to mikado() */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅱ-函数/3.png" style="zoom:50%;"></p>
<blockquote>
<p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值 2 传递给形式参数（mikado()中的bah）。<strong>注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。</strong></p>
</blockquote>
<h2 id="5-使用指针在函数间通信"><a href="#5-使用指针在函数间通信" class="headerlink" title="5.使用指针在函数间通信"></a>5.使用指针在函数间通信</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。</p>
<p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;　　 <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> * pc;　　　　<span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="keyword">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure></div>
<p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int </em> pi; 声明的意思是pi是一个指针,<code>*pi</code> 是 <code>int</code>类型 </p>
<p>pc指向的值（<em>pc）是char类型。pc本身是什么类型？我们描述它的类型是<strong>“指向char类型的指针</strong>。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，<em>*但是不能把两个指针相乘</em></em>。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。</p>
<p>下面例子就介绍了指针在函数间通信：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* swap2.c -- researching swap1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅱ-函数/4.png" style="zoom:50%;"></p>
<p>  该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把           地址作为它们的值。因此，应把它们声明为指针。</p>
<p>在<code>interchange(int *u, int *v)</code>函数中 <code>* u = x, * v = y</code>;即 <code>u = &amp;x, v = &amp;y</code>;</p>
<p><code>*u = *v</code>;——&gt;把 v 的地址赋值给 u; <code>*v = temp</code>;——&gt;把temp的地址赋值给v。</p>
<p><code>u</code>和 <code>v</code> 互换了地址。</p>
<p><strong>猜想：如果直接int * temp;是否也能改变值？</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u , *v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchangeo Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅱ-函数/6.png" style="zoom:50%;"></p>
<p>实践证明是不行的，因为定义指针temp后的交换与定义<code>int temp</code>,然后<code>interchange(int  u, int  v)</code>这样交换是一样的，都是同类型的交换。</p>
<p><strong>对于指针与地址的实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">	p = &amp;n;</span><br><span class="line">	<span class="keyword">int</span> temp = *p;</span><br><span class="line">	<span class="keyword">int</span> *v;</span><br><span class="line">	v = &amp;temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n = %d,the loacl of n = %p\n"</span>,n,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*p = %d,the loacl of p = %p\n"</span>,*p,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"temp = %d,the loacl of temp = %p\n"</span>,temp,&amp;temp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*v = %d,the loacl of v = %p\n"</span>,*v,v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/04/10/C-Program-Ⅱ-函数/7.png" style="zoom:50%;"></p>
<blockquote>
<p>为什么temp的地址与* v的地址不一样呢，因为temp是新定义的变量，编译时给temp新分配了一个地址。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2020/03/12/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/1.png" alt></p>
<hr>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，它是由 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发实现的轻量级容器技术，它是基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。</p>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/2.png" style="zoom:50%;"></p>
<hr>
<h2 id="二-概念"><a href="#二-概念" class="headerlink" title="二.概念"></a>二.概念</h2><h3 id="1-概要理解"><a href="#1-概要理解" class="headerlink" title="1.概要理解"></a>1.概要理解</h3><p>Docker支持安装各种软件并做好配置后编译成镜像，最终可以直接运行镜像产生一个或多个运行于宿主机内核上的容器。为了形象的理解容器，可以简单的理解它为运行在操作系统上的独立沙箱系统，这些沙箱系统内部的文件系统和Linux的非常相似，事实上确是如此，因为Docker就是融合了Linux内核而实现的虚拟化技术，由于具有沙箱的特性，所以各个容器之间是隔离运行的、独立的、互不影响的，程序员甚至不用担心容器内部损坏或者崩溃导致宿主机出错，因为只要删除掉这些有问题的容器，而再运行相关的镜像又会得到全新的容器了，只要不进行数据挂载，整个过程甚至干净不留残余。</p>
<h3 id="2-核心内容"><a href="#2-核心内容" class="headerlink" title="2.核心内容"></a>2.核心内容</h3><p><strong>docker主机(Host)：</strong>或者称为docker宿主机，即安装了Docker程序的机器。</p>
<p>**docker客户端(Client)：连接docker主机进行操作的程序。</p>
<p><strong>docker镜像(Images)：</strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p><strong>docker容器(Container)：</strong>运行镜像后产生的实例称为容器，实质是运行于独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>的进程。</p>
<p><strong>docker仓库(Registry)：</strong>集中存储、分发镜像的仓库服务系统，作用是允许用户上传、下载并管理镜像，包括公有仓库和私有仓库。</p>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/3.png" style="zoom:80%;"></p>
<h3 id="3-对比传统虚拟机"><a href="#3-对比传统虚拟机" class="headerlink" title="3.对比传统虚拟机"></a>3.对比传统虚拟机</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">虚拟机的架构</th>
<th style="text-align:center">容器的架构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">启动</td>
<td style="text-align:center">分钟级</td>
<td style="text-align:center">秒级</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">弱于原生</td>
<td style="text-align:center">接近原生</td>
</tr>
<tr>
<td style="text-align:center">硬盘使用</td>
<td style="text-align:center">一般为GB</td>
<td style="text-align:center">一般为MB</td>
</tr>
<tr>
<td style="text-align:center">系统支持量</td>
<td style="text-align:center">一般几十个</td>
<td style="text-align:center">单机上千个容器</td>
</tr>
</tbody>
</table>
</div>
<p><strong>虚拟机的架构：</strong> 每个虚拟机都包括应用程序、必要的二进制文件和库以及一个完整的客户操作系统(Guest OS)，尽管它们被分离，它们共享并利用主机的硬件资源，将近需要十几个 GB 的大小。</p>
<p><strong>容器的架构：</strong> 容器包括应用程序及其所有的依赖，但与其他容器共享内核。它们以独立的用户空间进程形式运行在宿主机操作系统上。他们也不依赖于任何特定的基础设施，Docker 容器可以运行在任何计算机上，任何基础设施和任何云上。</p>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/4.png" style="zoom:100%;"></p>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/5.png" style="zoom:100%;"></p>
<h3 id="4-优势"><a href="#4-优势" class="headerlink" title="4.优势"></a>4.优势</h3><p>（1）快速的启动时间</p>
<p>由于Docker容器直接运行于宿主内核，无需启动完整的操作系统即可运行，因此可以做到秒级、甚至毫秒级的启动时间，这大大的节约了开发、测试、部署的时间。</p>
<p>（2）一致的运行环境</p>
<p>开发过程中一个常见的问题是环境一致性问题。由于不同物理机的开发环境不一致，经常出现安装了相同的软件但却有不同的运行效果现象，甚至有的环境下还会出现bug。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，以至于不会再出现 “这段代码在我机器上没问题啊” 这类的问题。</p>
<p>（3）持续交付和部署</p>
<p>Docker可以一次创建或配置镜像，而可以在任意地方正常运行。即”一处构建，到处运行”。</p>
<p>（4）更方便的迁移</p>
<p><code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p>（5）更轻量的维护和扩展</p>
<p><code>Docker</code>使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的<a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h3 id="5-分层存储"><a href="#5-分层存储" class="headerlink" title="5.分层存储"></a>5.分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="6-容器存储层"><a href="#6-容器存储层" class="headerlink" title="6.容器存储层"></a>6.容器存储层</h3><p>镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<h3 id="7-数据卷"><a href="#7-数据卷" class="headerlink" title="7.数据卷"></a>7.数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，当容器内部的目录(文件)映射到宿主机的某目录(文件)时，那么就称这个宿主机的目录(文件)为数据卷。它绕过 UFS，可以提供很多有用的特性，如下：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p>
</blockquote>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用<a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷(Volume)</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<hr>
<h2 id="三-安装Docker"><a href="#三-安装Docker" class="headerlink" title="三.安装Docker"></a>三.安装Docker</h2><blockquote>
<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版，EE 即企业版，强调安全，付费使用。</p>
</blockquote>
<ul>
<li>由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get remove docker docker-engine docker-ce docker.io</span><br></pre></td></tr></table></figure></div>
<ul>
<li>更新apt包索引：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></div>
<ul>
<li>安装以下包以使apt可以通过HTTPS使用存储库(repository)：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure></div>
<ul>
<li>添加Docker官方的GPG密钥：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用下面的命令来设置<strong>stable</strong>存储库：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs</span><br></pre></td></tr></table></figure></div>
<ul>
<li>再更新一下apt包索引：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></div>
<ul>
<li>安装最新版本的Docker CE：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure></div>
<ul>
<li>在生产系统上，可能会需要应该安装一个特定版本的Docker CE，而不是总是使用最新版本,列出可用的版本：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> apt-cache madison docker-ce</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/7.png" style="zoom:50%;"></p>
<p>选择要安装的特定版本，第二列是版本字符串，第三列是存储库名称，它指示包来自哪个存储库，以及扩展它的稳定性级别。要安装一个特定的版本，将版本字符串附加到包名中，并通过等号(=)分隔它们：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>例如：sudo apt-get install docker-ce=5:19.03.7~3-0~ubuntu-bionic</p>
</blockquote>
<hr>
<h2 id="四-验证Docker"><a href="#四-验证Docker" class="headerlink" title="四.验证Docker"></a>四.验证Docker</h2><ul>
<li>查看docker服务是否启动：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl status docker</span><br></pre></td></tr></table></figure></div>
<ul>
<li>若未启动，则启动docker服务：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo systemctl start docker</span><br></pre></td></tr></table></figure></div>
<ul>
<li>经典的hello world：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo docker pull hello-world</span><br><span class="line"><span class="meta">$</span> sudo docker run hello-world</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/6.png" style="zoom:50%;"></p>
<hr>
<h2 id="五-镜像下载加速"><a href="#五-镜像下载加速" class="headerlink" title="五.镜像下载加速"></a>五.镜像下载加速</h2><p>鉴于国内网络问题，Docker默认是从官方Docker Hub拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。</p>
<ul>
<li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></li>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li>
<li><a href="https://www.163yun.com/help/documents/56918246390157312" target="_blank" rel="noopener">网易云加速器 <code>https://hub-mirror.c.163.com</code></a></li>
</ul>
<blockquote>
<p>测速：<a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">https://github.com/docker-practice/docker-registry-cn-mirror-test/actions</a></p>
</blockquote>
<p>编辑 <code>/etc/docker/daemon.json</code>（Linux） 或者 <code>%programdata%\docker\config\daemon.json</code>（Windows） 来配置 Daemon（如果文件不存在请新建该文件）。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></div>
<p>添加以下内容：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>可以配置多个加速镜像。由于镜像服务可能出现宕机，建议同时配置多个加速镜像。</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>重新加载配制</span><br><span class="line"><span class="meta">$</span> systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span>重启docker</span><br><span class="line"><span class="meta">$</span> service docker restart</span><br><span class="line"><span class="meta">#</span>检查加速器是否生效</span><br><span class="line"><span class="meta">$</span> docker info</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>如果方便建议使用aliyun的镜像</p>
<p>地址：<a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors</a></p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/9.png" alt></p>
<hr>
<h2 id="六-镜像操作"><a href="#六-镜像操作" class="headerlink" title="六.镜像操作"></a>六.镜像操作</h2><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>检索	(去https://hub.docker.com上查看镜像的详细信息。eg：docker search redis)</span><br><span class="line"><span class="meta">$</span> docker  search 镜像关键字</span><br><span class="line"><span class="meta">#</span>拉取	(name是镜像名，:tag是可选的，tag表示标签，多为软件的版本，默认是latest)</span><br><span class="line"><span class="meta">$</span> docker pull name[:tag]</span><br><span class="line"><span class="meta">#</span>列出	(查看所有本地镜像)</span><br><span class="line"><span class="meta">$</span> docker images</span><br><span class="line"><span class="meta">#</span>删除	(删除指定的本地镜像,image-id是镜像id)</span><br><span class="line"><span class="meta">$</span> docker rmi image-id</span><br></pre></td></tr></table></figure></div>
<hr>
<h2 id="七-容器操作"><a href="#七-容器操作" class="headerlink" title="七.容器操作"></a>七.容器操作</h2><p><img src="//ZYBO_o.github.io/2020/03/12/Docker学习/8.png" alt></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O系统</title>
    <url>/2020/08/29/I-O%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-I-O管理概述"><a href="#一-I-O管理概述" class="headerlink" title="一.I/O管理概述"></a>一.I/O管理概述</h1><h2 id="1-计算机I-O系统结构"><a href="#1-计算机I-O系统结构" class="headerlink" title="1.计算机I/O系统结构"></a>1.计算机I/O系统结构</h2><p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/1.png" style="zoom:33%;"></p>
<h2 id="2-I-O管理示意"><a href="#2-I-O管理示意" class="headerlink" title="2.I/O管理示意"></a>2.I/O管理示意</h2><p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/2.png" style="zoom:30%;"></p>
<h2 id="3-I-O管理的特点"><a href="#3-I-O管理的特点" class="headerlink" title="3.I/O管理的特点"></a>3.I/O管理的特点</h2><ul>
<li><strong>I/O性能经常成为系统性能的瓶颈</strong> </li>
<li><strong>操作系统庞大复杂的原因之一:</strong><ul>
<li><strong>速度差异很大</strong></li>
<li><strong>应用</strong></li>
<li><strong>控制接口的复杂性</strong></li>
<li><strong>传送单位</strong> </li>
<li><strong>数据表示</strong> </li>
<li><strong>错误条件</strong></li>
</ul>
</li>
<li><strong>与其他功能联系密切，特别是文件系统</strong></li>
</ul>
<h2 id="4-设备的分类"><a href="#4-设备的分类" class="headerlink" title="4.设备的分类"></a>4.设备的分类</h2><h3 id="1-按数据组织分"><a href="#1-按数据组织分" class="headerlink" title="(1).按数据组织分"></a>(1).按数据组织分</h3><ul>
<li><p>块设备 </p>
<ul>
<li>以数据块为单位存储、传输信息 </li>
<li>传输速率较高、可寻址(随机读写)</li>
</ul>
</li>
<li><p>字符设备 </p>
<ul>
<li>以字符为单位存储、传输信息 </li>
<li>传输速率低、不可寻址</li>
</ul>
</li>
</ul>
<blockquote>
<p>另一个角度：</p>
<ul>
<li>存储设备(磁盘、磁带)</li>
<li><p>传输设备(网卡、Modem)</p>
</li>
<li><p>人机交互设备(显示器、 键盘、鼠标)</p>
</li>
</ul>
</blockquote>
<h3 id="2-从资源分配角度"><a href="#2-从资源分配角度" class="headerlink" title="(2).从资源分配角度"></a>(2).从资源分配角度</h3><ul>
<li>独占设备 <ul>
<li>在一段时间内只能有一个进程使用的设备，一般为低速I/O设备(如打印机，磁带等)</li>
</ul>
</li>
<li><p>共享设备</p>
<ul>
<li>在一段时间内可有多个进程共同使用的设备，多个进程以交叉的方式来使用设备，其资源利用率高(如硬盘)</li>
</ul>
</li>
<li><p>虚设备 </p>
<ul>
<li><p>在一类设备上模拟另一类设备，常用共享设备模拟独占设备，用高速设备模拟低速设备，被模拟的设备称为虚设备</p>
</li>
<li><p>目的：将慢速的独占设备改造成多个用户可共享的设备，提高设备的利用率</p>
<blockquote>
<p>实例:SPOOLing技术，利用虚设备技术——用硬盘模拟输入输出设备</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="5-I-O管理的目标和任务"><a href="#5-I-O管理的目标和任务" class="headerlink" title="5.I/O管理的目标和任务"></a>5.I/O管理的目标和任务</h2><ul>
<li><p>按照用户的请求，控制设备的各种操作，完成I/O设 备与内存之间的数据交换，最终完成用户的I/O请求</p>
<ul>
<li>设备分配与回收<ul>
<li>记录设备的状态</li>
<li>根据用户的请求和设备的类型，采用一定的分配算 法，选择一条数据通路</li>
</ul>
</li>
<li>执行设备驱动程序，实现真正的I/O操作</li>
<li>设备中断处理:处理外部设备的中断</li>
<li>缓冲区管理:管理I/O缓冲区</li>
</ul>
</li>
<li><p>建立方便、统一的独立于设备的接口</p>
<ul>
<li><p>方便性：向用户提供使用外部设备的方便接口，使用户编程时不考虑设备的复杂物理特性。</p>
</li>
<li><p>统一性：对不同的设备采取统一的操作方式，即在用户程序中使用的是逻辑设备</p>
<ul>
<li><p>逻辑设备与物理设备</p>
</li>
<li><p>屏蔽硬件细节(设备的物理特性、错误处理、不同I/O过程的差异性)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>充分利用各种技术(通道，中断，缓冲，异步I/O等)提高CPU设备、设备与设备之间的并行工作能力，充分利用资源，提高资源利用率</p>
<ul>
<li>并行性</li>
<li>均衡性(使设备充分忙碌</li>
</ul>
<blockquote>
<p>性能 CPU与I/O的速度差别大</p>
<p>→减少由于速度差异造成 的整体性能开销</p>
<p>→尽量使两者交叠运</p>
</blockquote>
</li>
<li><p>保护</p>
<ul>
<li>设备传送或管理的数据应该是安全的、不被破坏的、保密的</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-I-O硬件组成"><a href="#二-I-O硬件组成" class="headerlink" title="二.I/O硬件组成"></a>二.I/O硬件组成</h1><h2 id="1-I-O设备组成"><a href="#1-I-O设备组成" class="headerlink" title="1.I/O设备组成"></a>1.I/O设备组成</h2><p>I/O设备一般由机械和电子两部分组成</p>
<ul>
<li><p>机械部分是设备本身(物理装置)</p>
</li>
<li><p>电子部分又称设备控制器(或适配器)</p>
<ul>
<li><p>(端口)地址译码</p>
</li>
<li><p>按照主机与设备之间约定的格式和过程接受计算 机发来的数据和控制信号或向主机发送数据和状态信号</p>
</li>
<li><p>将计算机的数字信号转换成机械部分能识别的模拟信号，或反之</p>
</li>
<li><p>实现设备内部硬件缓冲、数据加工等提高性能或增强功能</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-设备接口——控制器的作用"><a href="#2-设备接口——控制器的作用" class="headerlink" title="2.设备接口——控制器的作用"></a>2.设备接口——控制器的作用</h2><ul>
<li><p><strong>操作系统将命令写入控制器的接口寄存器(或接口缓冲区)中，以实现输入/输出，并从接口寄存器读取状态 信息或结果信息</strong></p>
</li>
<li><p><strong>当控制器接受一条命令后，可<font color="red">独立于CPU</font>完成指定操作，CPU可以另外执行其他计算；命令完成时，控制器产生一个中断，CPU响应中断，控制转给操作系统;通过读控制器寄存器中的信息，获得操作结果和设备状态</strong></p>
</li>
</ul>
<ul>
<li><strong>控制器与设备之间的接口常常是一个低级接口</strong></li>
<li><strong>控制器的任：把串行的位流转换为字节块，并进行必 要的错误修正：首先，控制器按位进行组装，然后存入 控制器内部的缓冲区中形成以字节为单位的块;在对块 验证检查和并证明无错误时，再将它复制到内存中</strong></li>
</ul>
<h2 id="3-I-O端口地址"><a href="#3-I-O端口地址" class="headerlink" title="3.I/O端口地址"></a>3.I/O端口地址</h2><ul>
<li><p><strong>I/O端口地址：接口电路中每个寄存器具有的、唯一的地址，是个整数</strong></p>
</li>
<li><p><strong>所有I/O端口地址形成I/O端口空间(受到保护)</strong></p>
</li>
</ul>
<p>I/O指令形式与I/O地址是相互关联的， 主要有两种形式: </p>
<ul>
<li>内存映像编址(内存映像I/O模式)</li>
<li>I/O独立编址(I/O专用指令)</li>
</ul>
<h2 id="4-I-O独立编制"><a href="#4-I-O独立编制" class="headerlink" title="4.I/O独立编制"></a>4.I/O独立编制</h2><ul>
<li><p>分配给系统中所有端口的地址空间 完全独立，与内存地址空间无关</p>
</li>
<li><p>使用专门的I/O指令对端口进行操作</p>
</li>
<li><p>优点</p>
<ul>
<li>外设不占用内存的地址空间</li>
<li>编程时，易于区分是对内存操作还是对I/O端口操作</li>
</ul>
</li>
<li><p>缺点:I/O端口操作的指令类型少，操作不灵活</p>
<blockquote>
<p>例子:8086/8088，分配给I/O端口 的地址空间64K，0000H~0FFFFH， 只能用in和out指令进行读写操作</p>
</blockquote>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/3.png" style="zoom:30%;"></p>
<h2 id="5-内存映像编址"><a href="#5-内存映像编址" class="headerlink" title="5.内存映像编址"></a>5.内存映像编址</h2><ul>
<li>分配给系统中所有端口的地址空间与内存的地址空 间统一编址</li>
</ul>
<ul>
<li>把I/O端口看作一个存储单元，对I/O的读写操作等 同于对内存的操作</li>
<li>优点<ul>
<li>凡是可对内存操作的指令都可对I/O端口操作 </li>
<li>不需要专门的I/O指令</li>
<li>I/O端口可占有较大的地址空间</li>
</ul>
</li>
<li>缺点<ul>
<li>占用内存空间</li>
</ul>
</li>
</ul>
<h2 id="6-内存映射I-O的优点"><a href="#6-内存映射I-O的优点" class="headerlink" title="6.内存映射I/O的优点"></a>6.内存映射I/O的优点</h2><ul>
<li>不需要特殊的保护机制来阻止用户进程执行I/O操作 </li>
</ul>
<p>操作系统必须要做的事情:避免把包含控制寄存器的那部分地址空间放入任何用户的虚拟地址空间之中</p>
<ul>
<li>可以引用内存的每一条指令也可以引用控制寄存器</li>
</ul>
<p>例如，如果指令TEST可以测试一个内存字是否为0，那么它 也可以用来测试一个控制寄存器是否为0</p>
<h2 id="7-内存映射I-O的缺点"><a href="#7-内存映射I-O的缺点" class="headerlink" title="7.内存映射I/O的缺点"></a>7.内存映射I/O的缺点</h2><ul>
<li>对一个设备控制寄存器不能进行高速缓存</li>
<li>考虑以下汇编代码循环，第一次引用PORT_4将导致它被高速缓存，随后的引用将只从高速缓存中取值并且不会再查 询设备，之后当设备最终变为就绪时，软件将没有办法发 现这一点，结果循环将永远进行下去</li>
<li>为避免这一情形，硬件必须针对每个页面具备选择性禁用 高速缓存的能力，操作系统必须管理选择性高速缓存，所以这一特性为硬件和操作系统两者增添了额外的复杂性</li>
</ul>
<hr>
<h1 id="三-I-O控制方式"><a href="#三-I-O控制方式" class="headerlink" title="三.I/O控制方式"></a>三.I/O控制方式</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li>可编程I/O(轮询/查询) <ul>
<li>由CPU代表进程给I/O模块发I/O命令，进程进入忙等待，直到操作完成才继续执行 </li>
</ul>
</li>
<li><p>中断驱动I/O</p>
<ul>
<li>为了减少设备驱动程序不断地询问控制器状态寄存器的开销 </li>
<li>I/O操作结束后，由设备控制器主动通知设备驱动程序</li>
</ul>
</li>
<li><p>DMA</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/4.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/5.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/6.png" style="zoom:33%;"></p>
<h2 id="2-I-O部件的演变"><a href="#2-I-O部件的演变" class="headerlink" title="2.I/O部件的演变"></a>2.I/O部件的演变</h2><p>1.CPU直接控制外围设备 </p>
<p>2.增加了控制器或I/O部件，CPU使用非中断的可编程I/O</p>
<blockquote>
<p> CPU开始从外部设备接口的具体细节中分离出来 </p>
</blockquote>
<p>3.与2相同，但采用了中断方式</p>
<blockquote>
<p> CPU无需花费等待执行一次I/O操作所需的时间，效率提高 </p>
</blockquote>
<p>4.I/O部件通过DMA直接控制存储器</p>
<blockquote>
<p>可以在没有CPU参与的情况下，从内存中移出或者往内存中 移入一块数据，仅仅在传送开始和结束时需要CPU干预 </p>
</blockquote>
<p>5.I/O部件增强为一个单独的处理器，有专门为I/O设计的指令 集;CPU指导I/O处理器执行内存中的一个I/O程序。I/O处理器在 没有CPU干涉的情况下取指令并执行这些指令 </p>
<p>6.I/O部件有自己的局部存储器(其本身就是一台计算机)</p>
<blockquote>
<p> 使用这种体系结构可以控制许多I/O设备，并且使需要CPU参 与程度降到最小(通常用于控制与交互终端的通信，I/O处理器 负责大多数控制终端的任务)</p>
</blockquote>
<hr>
<h1 id="四-I-O软件组成"><a href="#四-I-O软件组成" class="headerlink" title="四.I/O软件组成"></a>四.I/O软件组成</h1><h2 id="1-I-O软件设计"><a href="#1-I-O软件设计" class="headerlink" title="1.I/O软件设计"></a>1.I/O软件设计</h2><p>分层的设计思想：</p>
<ul>
<li>把I/O软件组织成多个层次</li>
<li>每一层都执行操作系统所需要的功能的一个相关子集， 它依赖于更低一层所执行的更原始的功能，从而可以 隐藏这些功能的细节;同时，它又给高一层提供服务</li>
<li>较低层考虑硬件的特性，并向较高层软件提供接口</li>
<li>较高层不依赖于硬件，并向用户提供一个友好的、清晰的、简单的、功能更强的接口</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/7.png" style="zoom:30%;"></p>
<h2 id="2-I-O软件层次"><a href="#2-I-O软件层次" class="headerlink" title="2.I/O软件层次"></a>2.I/O软件层次</h2><p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/8.png" style="zoom:33%;"></p>
<p>(1)用户进程层执行输入输出系统调用，对I/O数据进行格 式化，为假脱机输入/输出作准备</p>
<p>(2)独立于设备的软件实现设备的命名、设备的保护、成块处理、缓冲技术和设备分配</p>
<p>(3)设备驱动程序设置设备寄存器、检查设备的执行状态</p>
<p>(4)中断处理程序负责I/O完成时，唤醒设备驱动程序进程，进行中断处理 </p>
<p>(5)硬件层实现物理I/O的操作</p>
<h2 id="3-设备独立性"><a href="#3-设备独立性" class="headerlink" title="3.设备独立性"></a>3.设备独立性</h2><blockquote>
<p>好处:设备分配时的灵活性，易于实现I/O重定向</p>
</blockquote>
<p>用户编写的程序可以访问任意I/O设备，无需事先指定设备</p>
<p><strong>从用户角度：</strong>用户在编制程序时，使用逻辑设备名， 由系统实现从逻辑设备到物理设备(实际设备)的 转换，并实施I/O操作。</p>
<p><strong>从系统角度：</strong>设计并实现I/O软件时，除了直接与设备打交道的低层软件之外，其他部分的软件不依赖于硬件。</p>
<hr>
<h1 id="五-I-O相关技术"><a href="#五-I-O相关技术" class="headerlink" title="五.I/O相关技术"></a>五.I/O相关技术</h1><h2 id="1-引入缓冲技术解决什么问题？"><a href="#1-引入缓冲技术解决什么问题？" class="headerlink" title="1.引入缓冲技术解决什么问题？"></a>1.引入缓冲技术解决什么问题？</h2><p>操作系统中最早引入的技术</p>
<ul>
<li><p><strong>解决CPU与I/O设备之间速度的不匹配问题凡是数据到达和离去速度不匹配的地方均可采用缓冲技术</strong></p>
</li>
<li><p><strong>提高CPU与I/O设备之间的并行性</strong></p>
</li>
<li><p><strong>减少了I/O设备对CPU的中断请求次数，放宽 CPU对中断响应时间的要求</strong></p>
</li>
</ul>
<h2 id="2-缓冲技术实现"><a href="#2-缓冲技术实现" class="headerlink" title="2.缓冲技术实现"></a>2.缓冲技术实现</h2><ul>
<li><p>缓冲区分类 </p>
<ul>
<li>硬缓冲:由硬件寄存器实现(例如:设备中设置的缓冲区) </li>
<li>软缓冲:在内存中开辟一个空间，用作缓冲区</li>
</ul>
</li>
<li><p>缓冲区管理 </p>
<ul>
<li>单缓冲</li>
<li>双缓冲</li>
<li>缓冲池(多缓冲，循环缓冲):统一管理多个缓冲 区，采用有界缓冲区的生产者/消费者模型对缓冲池中的缓冲区进行循环使用</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li><p>终端输入软件中的键盘驱动程序 其任务之一：收集字符</p>
<blockquote>
<p>两种常见的字符缓冲方法:</p>
<ul>
<li><p>公共缓冲池(驱动程序中)</p>
</li>
<li><p>终端数据结构缓冲</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="六-I-O设备管理"><a href="#六-I-O设备管理" class="headerlink" title="六.I/O设备管理"></a>六.I/O设备管理</h1><h2 id="1-I-O设备管理有关数据结构"><a href="#1-I-O设备管理有关数据结构" class="headerlink" title="1.I/O设备管理有关数据结构"></a>1.I/O设备管理有关数据结构</h2><ul>
<li><p><strong>描述设备、控制器等部件的表格：</strong>系统中常常为每一个部件、每一台设备分别设置一张表格，常称为设备表或部件控制块。这类表格具体描述设备的类型、标识符、状态，以及当前使用者的进程标识符等</p>
</li>
<li><p><strong>建立同类资源的队列：</strong>系统为了方便对I/O设备的分配管理，通常在设备表的基础上通过指针将相同物理属性的设备连成队列(称设备队列)</p>
</li>
<li><p><strong>面向进程I/O请求的动态数据结构：</strong>每当进程发出I/O请求时，系统建立一张表格(称I/O请求包)，将此次 I/O请求的参数填入表中，同时也将该I/O有关的系统缓冲区地址等信息填入表中。I/O请求包随着I/O的完成而被删除</p>
</li>
<li><p><strong>建立I/O队列：</strong>如请求包队列</p>
</li>
</ul>
<h2 id="2-独占设备的分配"><a href="#2-独占设备的分配" class="headerlink" title="2.独占设备的分配"></a>2.独占设备的分配</h2><p>在申请设备时，如果设备空闲，就将其独占，不再允许其他进程申请使用，一直等到该设备被释放，才允许被其他进程申请使用考虑效率问题，并避免由于不合理的分配策略造成死锁。</p>
<ul>
<li>静态分配:<br> 在进程运行前, 完成设备分配;运行结束时，收回设备 <ul>
<li>缺点:设备利用率低</li>
</ul>
</li>
<li>动态分配:<br> 在进程运行过程中，当用户提出设备要求时，进行分配，一旦停止使用立即收回<ul>
<li>优点:效率好;</li>
<li>缺点:分配策略不好时, 产生死锁</li>
</ul>
</li>
</ul>
<h2 id="3-分时式共享设备的分配"><a href="#3-分时式共享设备的分配" class="headerlink" title="3.分时式共享设备的分配"></a>3.分时式共享设备的分配</h2><ul>
<li>所谓分时式共享就是以一次I/O为单位分时使用设备，不同进程的I/O操作请求以排队方式分时地占用设备进行I/O</li>
<li>由于同时有多个进程同时访问，且访问频繁，就会影响整个设备使用效率，影响系统效率。因此要考虑多个访问请求到达时服务的顺序，使平均 服务时间越短越好</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/9.png" style="zoom:33%;"></p>
<h2 id="4-设备驱动程序"><a href="#4-设备驱动程序" class="headerlink" title="4.设备驱动程序"></a>4.设备驱动程序</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1). 基本概念"></a>(1). 基本概念</h3><ul>
<li><p>与设备密切相关的代码放在设备驱动程序中，每个设备驱动程序处理一种设备类型</p>
</li>
<li><p>一般，设备驱动程序的任务是接收来自与设备无关的上层软件的抽象请求，并执行这个请求</p>
</li>
</ul>
<ul>
<li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。设备驱动程序负责释放这些命令，并监督它们正确执行</li>
<li>在设备驱动程序的进程释放一条或多条命令后，系统 有两种处理方式，多数情况下，执行设备驱动程序的进程必须等待命令完成，这样，在命令开始执行后， 它阻塞自已，直到中断处理时将它解除阻塞为止;而 在其它情况下，命令执行不必延迟就很快完成</li>
</ul>
<h3 id="2-设备驱动程序与外界的接口"><a href="#2-设备驱动程序与外界的接口" class="headerlink" title="(2).设备驱动程序与外界的接口"></a>(2).设备驱动程序与外界的接口</h3><ul>
<li><p>与操作系统的接口</p>
<ul>
<li>为实现设备无关性，设备作为特殊文件处理。用户的 I/O请求、对命令的合法性检查以及参数处理在文件系统中完成。在需要各种设备执行具体操作时，通过相应数据结构转入不同的设备驱动程序</li>
</ul>
</li>
<li><p>与系统引导的接口(初始化，包括分配数据结构， 建立设备的请求队列)</p>
</li>
<li><p>与设备的接口</p>
</li>
</ul>
<h3 id="3-设备驱动程序接口函数"><a href="#3-设备驱动程序接口函数" class="headerlink" title="(3).设备驱动程序接口函数"></a>(3).设备驱动程序接口函数</h3><ul>
<li><strong>驱动程序初始化函数</strong><ul>
<li>如向操作系统登记该驱动程序的接口函 数，该初始化函数在系统启动时或驱动程序安装入内核时执行</li>
</ul>
</li>
<li><strong>驱动程序卸载函数</strong></li>
<li><strong>申请设备函数</strong></li>
<li><strong>释放设备函数</strong></li>
<li><strong>I/O操作函数</strong><ul>
<li>对独占设备，包含启动I/O的指令;对共享设备，将I/O请求形成一个请求包，排到设备请求队列，如果请求队列空，则直接启动设 备</li>
</ul>
</li>
<li><strong>中断处理函数</strong><ul>
<li>对I/O完成做善后处理，一般是唤醒等待刚完成I/O请求的阻塞进 程，使其能进一步做后续工作;如果存在I/O请求队列，则启动下 一个I/O请求</li>
</ul>
</li>
</ul>
<hr>
<h1 id="七-I-O性能问题"><a href="#七-I-O性能问题" class="headerlink" title="七.I/O性能问题"></a>七.I/O性能问题</h1><h2 id="1-性能问题"><a href="#1-性能问题" class="headerlink" title="1.性能问题"></a>1.性能问题</h2><ul>
<li><p>使CPU利用率尽可能不被I/O降低  使CPU尽可能摆脱I/O</p>
</li>
<li><p>减少或缓解速度差距 → 缓冲技术</p>
</li>
<li>使CPU不等待I/O → 异步I/O</li>
<li>让CPU摆脱I/O操作 → DMA、通道</li>
</ul>
<h2 id="2-异步传输"><a href="#2-异步传输" class="headerlink" title="2.异步传输"></a>2.异步传输</h2><ul>
<li><p><strong>Windows提供两种模式的I/O操作</strong>: 异步和同步</p>
</li>
<li><p><strong>异步模式</strong>：用于优化应用程序的性能</p>
<ul>
<li>通过异步I/O，应用程序可以启动一个I/O操作，然后在I/O请求执行的同时继续处理</li>
<li>基本思想:填充I/O操作间等待的CPU时间</li>
</ul>
</li>
<li><p><strong>同步I/O</strong>：应用程序被阻塞直到I/O操作完成</p>
</li>
</ul>
<h2 id="3-同步传输I-O流程"><a href="#3-同步传输I-O流程" class="headerlink" title="3.同步传输I/O流程"></a>3.同步传输I/O流程</h2><ul>
<li>在I/O处理过程中，CPU处于空闲等待状态</li>
<li>而在处理数据的过程中，不能同时进行I/O操作</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/10.png" style="zoom:33%;"></p>
<h2 id="4-异步传输I-O流程"><a href="#4-异步传输I-O流程" class="headerlink" title="4.异步传输I/O流程"></a>4.异步传输I/O流程</h2><p><img src="//ZYBO_o.github.io/2020/08/29/I-O系统/11.png" style="zoom:33%;"></p>
<ul>
<li><p>系统实现</p>
<ul>
<li>通过切换到其他线程保证CPU利用率</li>
<li>对少量数据的I/O操作会引入切换的开销</li>
</ul>
</li>
<li><p>用户实现</p>
<ul>
<li>将访问控制分成两段进行</li>
<li>发出读取指令后继续做其他操作</li>
<li>当需要用读入的数据的时候，再使用wait命令等待其完成 </li>
<li>不引入线程切换，减少开销</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>I/O系统</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb学习</title>
    <url>/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<p>在终端输入以下命令安装 GDB：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install gdb</span><br></pre></td></tr></table></figure></div>
<h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2+3+...+%d= %d\n"</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc bugging.c -o bugging -g -m64</span><br></pre></td></tr></table></figure></div>
<p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p>
<p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install libc6-dev-i386</span><br></pre></td></tr></table></figure></div>
<p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gdb bugging</span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) run</span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) quit</span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/1.png" style="zoom:50%;"></p>
<h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p>
<blockquote>
<p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p>
</blockquote>
<p>部分 gdb 常用命令一览表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">简写形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">l</td>
<td style="text-align:center">查看源码</td>
</tr>
<tr>
<td style="text-align:center">backtrace</td>
<td style="text-align:center">bt,where</td>
<td style="text-align:center">打印函数栈信息</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">n</td>
<td style="text-align:center">执行下一行</td>
</tr>
<tr>
<td style="text-align:center">step</td>
<td style="text-align:center">s</td>
<td style="text-align:center">一次执行一行，遇到函数会进入</td>
</tr>
<tr>
<td style="text-align:center">finish</td>
<td style="text-align:center"></td>
<td style="text-align:center">运行到函数结束</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">c</td>
<td style="text-align:center">继续运行</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">b</td>
<td style="text-align:center">设置断点</td>
</tr>
<tr>
<td style="text-align:center">info breakpoints</td>
<td style="text-align:center"></td>
<td style="text-align:center">显示断点信息</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">d</td>
<td style="text-align:center">删除断点</td>
</tr>
<tr>
<td style="text-align:center">print</td>
<td style="text-align:center">p</td>
<td style="text-align:center">打印表达式的值</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">r</td>
<td style="text-align:center">启动程序</td>
</tr>
<tr>
<td style="text-align:center">until</td>
<td style="text-align:center">u</td>
<td style="text-align:center">执行到指定行</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">i</td>
<td style="text-align:center">显示信息</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">h</td>
<td style="text-align:center">帮助信息</td>
</tr>
</tbody>
</table>
</div>
<p>查询用法：</p>
<blockquote>
<p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p>
</blockquote>
<p>执行 Shell 命令：</p>
<blockquote>
<p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> $ (gdb)!shell 命令</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>例如查看当前目录的文件：</p>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/2.png" style="zoom:50%;"></p>
</blockquote>
<h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p>
<ul>
<li>list 行号，显示某一行附近的代码：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/3.png" style="zoom:50%;"></p>
<ul>
<li>list 函数名，显示某个函数附近的代码：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/4.png" style="zoom:50%;"></p>
<ul>
<li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li>
</ul>
<h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p>
<ul>
<li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/5.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 行号，适用于有多个源文件的情况。</li>
</ul>
<ul>
<li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/6.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 函数名，适用于有多个源文件的情况。</li>
</ul>
<h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/7.png" style="zoom:50%;"></p>
<p>其中每一项的信息：</p>
<blockquote>
<ul>
<li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li>
<li>Type 列代表断点类型，一般为 breakpoint</li>
<li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li>
<li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li>
<li>Address 列代表该断点处虚拟内存的地址</li>
<li>What 列代表该断点在源文件中的信息</li>
</ul>
</blockquote>
<h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p>
<ul>
<li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/8.png" style="zoom:50%;"></p>
<ul>
<li>delete，不带任何参数，默认删除所有断点：</li>
</ul>
<h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p>
<blockquote>
<p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p>
<p><em>enable</em> 命令用于启用断点。</p>
</blockquote>
<ul>
<li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/9.png" style="zoom:50%;"></p>
<ul>
<li><p>disable，不带任何参数，默认关闭所有断点。</p>
</li>
<li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/10.png" style="zoom:50%;"></p>
<ul>
<li>enable，不带任何参数，默认启用所有断点。</li>
</ul>
<p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p>
<h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p>
<ul>
<li>enable once Num，断点 hit 一次之后关闭该断点</li>
<li>enable delete Num，断点 hit 一次之后删除该断点</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/03/26/gdb学习/11.png" style="zoom:50%;"></p>
<p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p>
<h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol>
<li><strong>打印变量</strong></li>
</ol>
<p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p>
<blockquote>
<ul>
<li><p><code>info locals</code></p>
<p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p>
</li>
<li><p><code>print 变量或表达式</code></p>
<p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p>
<p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>启动程序</strong></li>
</ol>
<p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p>
<blockquote>
<ul>
<li><p><code>run</code></p>
<p>不带任何参数，启动待调试程序，不传递参数。</p>
</li>
<li><p><code>run 参数</code></p>
<p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>单步命令</strong></li>
</ol>
<p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p>
<blockquote>
<ul>
<li><p><code>next</code></p>
<blockquote>
<p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p>
<p>next N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>step</code></p>
<blockquote>
<p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p>
<p>step N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>finish</code></p>
<p>执行程序到当前函数结束</p>
</li>
<li><p><code>continue</code></p>
<p>执行程序到下个断点</p>
</li>
<li><p><code>until</code></p>
<p>until N，执行程序到源代码的某一行</p>
</li>
</ul>
</blockquote>
<h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p>
<blockquote>
<ul>
<li><code>list</code></li>
<li><code>info breakpoints</code></li>
<li><code>break</code></li>
<li><code>delete</code></li>
<li><code>disable</code> 和 <code>enable</code></li>
<li><code>enable once</code> 和 <code>enable delete</code></li>
<li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li>
<li><code>info locals</code> 和 <code>print</code></li>
</ul>
</blockquote>
<p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概述</title>
    <url>/2020/07/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><p><strong>Question:</strong></p>
<ul>
<li>操作系统做了什么？</li>
<li>操作系统的定义与作用</li>
<li>操作系统的主要特征</li>
<li>操作系统的架构</li>
<li>操作系统的分类</li>
</ul>
<h2 id="一-操作系统做了什么"><a href="#一-操作系统做了什么" class="headerlink" title="一.操作系统做了什么"></a>一.操作系统做了什么</h2><p>通过下面程序的执行过程来分析操作系统对此程序的执行有哪些支持。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="built_in">puts</span>(<span class="string">"hello world"</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>用户告诉操作系统执行 <code>helloworld</code>程序.</li>
<li>操作系统: 找到 <code>helloworld</code> 程序的相关信息，检查其类型是否是可执行文件; 并通过程序首部信息, 确定代码和数据在可执行文件中的位置并计算出对 应的磁盘块地址.</li>
<li><p>操作系统: 创建一个<strong>新的进程</strong>，并将 <code>helloworld</code> 可 执行文件映射到该进程结构，表示由该进程执行 <code>helloworld</code> 程序.</p>
</li>
<li><p>操作系统:为 <code>helloworld</code> 程序设置<strong>CPU上下文环境</strong>, 并跳到程序开始处,准备执行程序 (假设调度程序选中hello程序)</p>
</li>
<li>执行helloworld程序的第一条指令，<strong>发生缺页异常</strong>（代码和数据还没有读入内存，硬件机制会捕获缺页异常，把控制权交给操作系统）</li>
<li>操作系统: 分配一页<strong>物理内存</strong>，并将代码从磁盘读入内存，然后继续执行 <code>helloworld</code> 程序.</li>
<li><code>helloworld</code> 程序执行 <code>puts</code> 函数[<strong>系统调用</strong>(<strong>操作系统完成这个功能</strong>)]，在显示器上写一字符串.</li>
<li>操作系统: 找到要将字符串送往的显示设备，通常设备是由一个<strong>进程控制</strong>的，所以，操作系统将要写的字符串送给该进程.</li>
<li>操作系统: 控制设备的进程告诉设备的窗口系统 它要显示字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的<strong>存储映像区</strong>.</li>
<li>视频硬件将像素转换成显示器可接收的一组 <strong>控制/数据信号</strong>.</li>
<li>显示器解释信号，激发液晶屏.</li>
<li>OK!!!我们在屏幕上看到了 “hello world” .</li>
</ul>
<p><strong>从用户程序在执行过程中，不断请求操作系统服务的角度来看程序执行的过程：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/07/15/操作系统概述/1.png" style="zoom:25%;"></p>
<p>在CPU上执行一个用户程序，这个用户程序会不时地去请求操作系统的服务，因此在CPU上，时而运行的是用户程序。时而运行操作系统程序。</p>
<blockquote>
<p>以helloworld程序为例：</p>
<p>在执行的时候，需要操作系统来创建进程，因此转到操作系统创建进程</p>
<p>进程创建完了以后会从操作系统返回 ，接着执行这个helloworld程序，在出现了缺页异常以后，控制权又转回了操作系统</p>
<p>操作系统分配物理内存给这个用户程序 ，然后又转向用户程序接着执行，然后helloworld程序又要去执行puts函数</p>
<p>此时又转向了操作系统去进行系统调用。 </p>
</blockquote>
<p><strong>换一个角度看用户程序的执行：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/07/15/操作系统概述/2.png" style="zoom:25%;"></p>
<blockquote>
<p> 实际上，是操作系统在执行过程中呢，如果选中了一个程序，那么就去<strong>通过调度</strong>选中这个程序，去执行这个程序</p>
<p>程序执行过程中，会不断地去陷入操作系统,  由操作系统完成一些服务.然后再通过调度再选中程序，接着执行.</p>
</blockquote>
<p>从上面的介绍过程，看到在一个程序的执行过程中，<strong>操作系统负责了这个程序的启动过程, 负责了这个程序执行的过程, 同时在执行的 过程中，不断地去为用户程序的执行 提供各种各样的支持.</strong></p>
<hr>
<h2 id="二-操作系统的定义与作用"><a href="#二-操作系统的定义与作用" class="headerlink" title="二.操作系统的定义与作用"></a>二.操作系统的定义与作用</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><p>操作系统是计算机系统中的一个系统软件，是一 些程序模块的集合，这些模块相互协作，相互配合，来完成以下这些功能：</p>
<ul>
<li><p>它们能以尽量<font color="red">有效、合理</font>的方式组织和管理计算机的软硬件资源。</p>
</li>
<li><p>合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能。</p>
</li>
<li><p>使得用户能够灵活、<font color="red">方便</font>地使用计算机，使整个计算机系统高效率运行。</p>
</li>
</ul>
<blockquote>
<p><strong>有效</strong>：让系统效率，资源利用率得以提高。</p>
<p><strong>合理</strong>：各种软硬件资源的管理是否公平合理。</p>
<p><strong>方便使用</strong>：两种角度:<strong>用户界面</strong>与<strong>编程接口</strong>。</p>
</blockquote>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h3><ul>
<li><p>资源的管理者：<font color="red">有效</font></p>
</li>
<li><p>向用户提供的各种服务：<font color="red">方便使用</font></p>
</li>
<li><p>对硬件机器的扩展：<font color="red">扩展能力</font></p>
</li>
</ul>
<h4 id="1-对于OS是资源的管理者"><a href="#1-对于OS是资源的管理者" class="headerlink" title="(1)对于OS是资源的管理者"></a>(1)对于OS是资源的管理者</h4><p>自底向上看，OS是资源的管理者。</p>
<p><strong>硬件资源：</strong>CPU，内存，设备(I/O设备、磁盘、时钟、网 络卡等)。</p>
<p><strong>软件资源：</strong>磁盘上的文件、各类管理信息等。</p>
<h4 id="2-怎么管理资源"><a href="#2-怎么管理资源" class="headerlink" title="(2)怎么管理资源"></a>(2)怎么管理资源</h4><ul>
<li><p>跟踪记录资源的使用状况(通过数据结构与算法)</p>
<blockquote>
<p>如:哪些资源空闲，分配给谁使用，允许使用多长时间等</p>
</blockquote>
</li>
<li><p>确定<font color="blue">资源分配策略——算法</font></p>
<ul>
<li>静态分配策略(会导致资源的浪费)</li>
<li>动态分配策略(根据数据结构与资源使用情况来分配，资源的利用率得到了显著的提高)</li>
</ul>
</li>
<li>实施资源的分配(根据资源分配策略去决定)和回收</li>
<li>提高资源利用率</li>
<li>保护资源的使用(一个进程使用资源时，不能被另外的所干扰)</li>
<li>协调多个进程对资源请求的冲突</li>
</ul>
<h4 id="3-从资源管理的角度—五大基本功能"><a href="#3-从资源管理的角度—五大基本功能" class="headerlink" title="(3)从资源管理的角度—五大基本功能"></a>(3)从资源管理的角度—五大基本功能</h4><ul>
<li><p>进程/线程管理(CPU管理)</p>
<blockquote>
<p>进程线程状态、控制、同步互斥、通信、调度、……</p>
</blockquote>
</li>
<li><p>存储管理</p>
<blockquote>
<p>分配/回收、地址转换、存储保护、内存扩充、……</p>
</blockquote>
</li>
<li><p>文件管理</p>
<blockquote>
<p>文件目录、文件操作、磁盘空间、文件存取控制、……</p>
</blockquote>
</li>
<li><p>设备管理</p>
<blockquote>
<p>设备驱动、分配回收、缓冲技术、……</p>
</blockquote>
</li>
<li><p>用户接口</p>
<blockquote>
<p>系统命令、编程接口</p>
</blockquote>
</li>
</ul>
<h4 id="4-操作系统是各种服务的提供者"><a href="#4-操作系统是各种服务的提供者" class="headerlink" title="(4)操作系统是各种服务的提供者"></a>(4)操作系统是各种服务的提供者</h4><ul>
<li><p><strong>在操作系统之上，从用户角度来看:</strong></p>
<blockquote>
<p>操作系统为用户提供了一组功能强大、方便易用的<font color="red">命令</font>或<font color="red">系统调用</font></p>
</blockquote>
</li>
<li><p><strong>典型的服务：</strong></p>
<blockquote>
<p>进程的创建、执行;文件和目录的操作;I/O设备 的使用;各类统计信息; ……</p>
</blockquote>
</li>
</ul>
<h4 id="5-操作系统是硬件之上的第一层软件"><a href="#5-操作系统是硬件之上的第一层软件" class="headerlink" title="(5).操作系统是硬件之上的第一层软件"></a>(5).操作系统是硬件之上的第一层软件</h4><p><img src="/Users/zhangyongbin/Blog/zybTree/source/_posts/操作系统概述/3.png" style="zoom:30%;"></p>
<h4 id="6-操作系统在硬件机器的扩展"><a href="#6-操作系统在硬件机器的扩展" class="headerlink" title="(6).操作系统在硬件机器的扩展"></a>(6).操作系统在硬件机器的扩展</h4><p>操作系统在应用程序与硬件之间建立了一个等价的扩展机器(虚拟机)，对硬件抽象，提高可移植性;比底层硬件更容易 编程。</p>
<p><img src="//ZYBO_o.github.io/2020/07/15/操作系统概述/4.png" style="zoom:30%;"></p>
<hr>
<h2 id="三-操作系统的特征"><a href="#三-操作系统的特征" class="headerlink" title="三.操作系统的特征"></a>三.操作系统的特征</h2><p><img src="//ZYBO_o.github.io/2020/07/15/操作系统概述/5.png" style="zoom:25%;"></p>
<h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><p><strong>并发(concurrency):</strong> 指处理多个同时性活动的能力。</p>
<blockquote>
<p>由于并发将会引发很多的问题:  活动切换、保护、相互依赖的活动间的同步.</p>
</blockquote>
<p>在计算机系统中同时存在多个程序运行，单CPU上 </p>
<p>​    <strong>宏观上：</strong>这些程序同时在执行。</p>
<p>​    <strong>微观上：</strong>任何时刻只有一个程序真正在执行，即这些程序在CPU上是轮流执行的。</p>
<p><strong>并行(parallel)：</strong>与并发相似，但多指不同程序同时在多 个硬件部件上执行</p>
<blockquote>
<p><strong>有趣的例子记忆：</strong></p>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
</blockquote>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><p><strong>共享：</strong>操作系统与多个用户的程序共同使用计算机系统中的资源(共享有限的系统资源)。</p>
<p>操作系统要对系统资源进行合理分配和使用，使得这些资源在一个时间段内交替被多个进程所用。</p>
<p>共享分为：</p>
<ul>
<li><p><strong>互斥共享</strong>(如打印机)</p>
</li>
<li><p><strong>同时共享</strong>(如可重入代码、磁盘文件)</p>
</li>
</ul>
<p>正是这些功能，所以又有了复杂的问题:  <strong>资源分配难以达到最优化，如何保护资源？</strong></p>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p><strong>虚拟(Virtual) : </strong>一个物理实体映射为若干个对应的逻辑实体——<strong>分时</strong>或<strong>分空间</strong>。虚拟是操作系统管理系统资源的重要手段，可提高资源利用率。</p>
<blockquote>
<p><strong>典型的例子：</strong></p>
<ul>
<li>CPU——每个进程的”虚处理机”</li>
<li>存储器——每个进程都有独立的虚拟地址空间(代码+数据+堆栈)</li>
<li>显示设备——多窗口或虚拟终端</li>
</ul>
</blockquote>
<h3 id="4-随机"><a href="#4-随机" class="headerlink" title="4.随机"></a>4.随机</h3><p>随机：操作系统必须随时对<font color="blue">以不可预测的次序</font>发生的事件进行响应并处理。</p>
<blockquote>
<p><strong>因为随机性带来的例子：</strong></p>
<p>进程的运行速度不可预知：多个进程并发执行，“走走停停”，无法预知每个进程的运行推进的快慢。</p>
</blockquote>
<p><strong>带来的问题：</strong>难以重现系统在某个时刻的状态(包括重现运行中的错误)。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统概述</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p>
<blockquote>
<p><strong>性质：</strong></p>
<ul>
<li>线性表中的数据元素之间是有顺序的。</li>
<li>线性表中的数据元素个数是有限的。</li>
<li>线性表中的数据元素的类型必须相同。</li>
</ul>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/1.png" style="zoom:50%;"></p>
<p>&lt;/br&gt;</p>
<h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/2.png" style="zoom:45%;">. </p>
<p><strong>在C中用一维数组来实现顺序存储结构：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>创建</li>
<li>分配内存</li>
<li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li>
<li>返回表的地址</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/6.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>直接通过数组下标的方式获取元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>把最后一个元素到插入位置的元素后移一个位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/3.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">		pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">		List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断删除位置是否合法</li>
<li>将元素取出</li>
<li>将删除位置后的元素分别向前移动一个位置</li>
<li>线性表长度减1</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/4.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//3.将元素取出</span></span><br><span class="line">		ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line">		<span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//5.线性表长度减1</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-顺序存储的优缺点"><a href="#3-顺序存储的优缺点" class="headerlink" title="(3).顺序存储的优缺点"></a>(3).顺序存储的优缺点</h3><p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/7.png" style="zoom:40%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/8.png" style="zoom:50%;"></p>
<p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/9.png" style="zoom:30%;"></p>
<p><strong>链表的基本概念:</strong></p>
<ul>
<li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li>
<li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li>
<li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/10.png" style="zoom:40%;"></p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/11.png" style="zoom:60%;"></p>
<p><strong>C语言用结构体来定义链表中的结点：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/13.png" style="zoom:45%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li><p>判断线性表是否合法</p>
</li>
<li><p>判断插入位置是否合法</p>
</li>
<li>获取第pos个元素</li>
<li>将第pos个元素从链表中删除</li>
<li>线性表长度减1</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/12.png" style="zoom:45%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">		LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">		<span class="comment">//3.获取第pos个元素</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">		&#123;</span><br><span class="line">				current = current-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">		ret = current-&gt;next;</span><br><span class="line">		current-&gt;next = ret-&gt;next;</span><br><span class="line">		<span class="comment">//5.线性表长度减1</span></span><br><span class="line">		sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-单链表结构与顺序存储结构优缺点"><a href="#3-单链表结构与顺序存储结构优缺点" class="headerlink" title="(3).单链表结构与顺序存储结构优缺点"></a>(3).单链表结构与顺序存储结构优缺点</h3><p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/15.png" style="zoom:50%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。</p>
<ul>
<li>顺序表数组中的元素由两个数据域组成:data和cur</li>
<li>data域用于存储数据</li>
<li>cur域用于存储下一个元素在数组中的下标</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/17.png" style="zoom:60%;"></p>
<p>把未被使用的数组元素称为<strong>备用链表。</strong>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；</p>
<p><strong>数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。</p>
<p><strong>在C中用一维数组来实现顺序存储结构：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">    <span class="comment">//Cursor,为0时表示无指向 </span></span><br><span class="line">	<span class="keyword">int</span> Cur; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>申请MAXSIZE大小的空间</li>
<li>给游标赋值，最后一个游标赋为0</li>
<li>返回链表指针</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="built_in">list</span> = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*MAXSIZE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">list</span>[i].Cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="built_in">list</span>[MAXSIZE - <span class="number">1</span>].Cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">	sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li><font color="red">在数组中查找空闲位置index</font></li>
<li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>获取第pos个元素</li>
<li>将第pos个元素从链表中删除</li>
<li>线性表长度减1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-静态链表优缺点"><a href="#3-静态链表优缺点" class="headerlink" title="(3).静态链表优缺点"></a>(3).静态链表优缺点</h3><p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/18.png" style="zoom:50%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p>
<p><img src="//ZYBO_o.github.io/2020/04/12/数据结构Ⅱ线性表/19.png" style="zoom:50%;"></p>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p>
<ul>
<li>创建链表</li>
<li>销毁链表</li>
<li>获取链表长度</li>
<li>清空链表</li>
<li>获取第pos个元素操作</li>
<li>插入元素到位置pos</li>
<li>删除位置pos处的元素</li>
</ul>
<p>&lt;/br&gt;</p>
<h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2><h3 id="1-结构分析-4"><a href="#1-结构分析-4" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2020/08/30/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-死锁的基本概念"><a href="#一-死锁的基本概念" class="headerlink" title="一.死锁的基本概念"></a>一.死锁的基本概念</h1><h2 id="1-死锁的定义"><a href="#1-死锁的定义" class="headerlink" title="1.死锁的定义"></a>1.死锁的定义</h2><ul>
<li><strong>一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为<font color="red">进程死锁</font>，这一组进程就称为<font color="red">死锁进程</font></strong></li>
<li><strong>如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃</strong></li>
</ul>
<blockquote>
<p>推论：</p>
<ul>
<li>参与死锁的所有进程都在等待资源 </li>
<li>参与死锁的进程是当前系统中所有进程的子集</li>
</ul>
</blockquote>
<h2 id="2-死锁的现象"><a href="#2-死锁的现象" class="headerlink" title="2.死锁的现象"></a>2.死锁的现象</h2><p><img src="//ZYBO_o.github.io/2020/08/30/死锁/1png.png" style="zoom:20%;"><img src="/Users/zhangyongbin/Blog/zybTree/source/_posts/死锁/2.png" style="zoom:20%;"></p>
<h2 id="3-出现死锁的原因"><a href="#3-出现死锁的原因" class="headerlink" title="3.出现死锁的原因"></a>3.出现死锁的原因</h2><p>原因：<strong>资源数量有限、锁和信号量错误使用</strong>，导致了死锁的出现。</p>
<p>资源的使用方式:  <strong>“申请—分配—使用—释放”</strong>模式。</p>
<p>资源的分类：</p>
<p><strong>可重用资源：可被多个进程多次使用</strong></p>
<ul>
<li>可抢占资源与不可抢占资源</li>
<li>处理器、I/O部件、内存、文件、数据库、信号量</li>
</ul>
<p><strong>可消耗资源：只可使用一次、可创建和销毁的资源</strong></p>
<ul>
<li>信号、中断、消息</li>
</ul>
<h3 id="1-进程竞争可重用资源"><a href="#1-进程竞争可重用资源" class="headerlink" title="(1).进程竞争可重用资源"></a>(1).进程竞争可重用资源</h3><p><img src="//ZYBO_o.github.io/2020/08/30/死锁/3.png" style="zoom:30%;"></p>
<h3 id="2-进程竞争可消耗资源"><a href="#2-进程竞争可消耗资源" class="headerlink" title="(2).进程竞争可消耗资源"></a>(2).进程竞争可消耗资源</h3><p><img src="//ZYBO_o.github.io/2020/08/30/死锁/4.png" style="zoom:33%;"></p>
<h2 id="4-活锁和饥饿"><a href="#4-活锁和饥饿" class="headerlink" title="4.活锁和饥饿"></a>4.活锁和饥饿</h2><p><img src="//ZYBO_o.github.io/2020/08/30/死锁/5.png" style="zoom:30%;"></p>
<p>活锁</p>
<ul>
<li><p>先加锁</p>
</li>
<li><p>再轮询</p>
<blockquote>
<p>既无进展也没有阻塞</p>
</blockquote>
</li>
</ul>
<p>饥饿</p>
<ul>
<li>资源分配策略决定</li>
</ul>
<h2 id="5-产生死锁的必要条件"><a href="#5-产生死锁的必要条件" class="headerlink" title="5.产生死锁的必要条件"></a>5.产生死锁的必要条件</h2><ul>
<li><p><strong>互斥使用(资源独占)</strong> </p>
<ul>
<li>一个资源每次<strong>只能给一个进程使用</strong></li>
</ul>
</li>
<li><p><strong>占有且等待(请求和保持，部分分配)</strong> </p>
<ul>
<li>进程在申请新的资源的<strong>同时保持对原有资源的占有</strong></li>
</ul>
</li>
<li><p><strong>不可抢占(不可剥夺)</strong> </p>
<ul>
<li>资源申请者<strong>不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</strong></li>
</ul>
</li>
<li><p><strong>循环等待</strong></p>
<ul>
<li>存在一个进程等待队列 {P1 , P2 , … , Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源, … , Pn等待P1占有的资源，<strong>形成一个进程等待环路</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-资源分配图"><a href="#二-资源分配图" class="headerlink" title="二.资源分配图"></a>二.资源分配图</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>为了解决死锁的问题，用有向图描述系统资源和进程的状态。</strong></p>
<p>二元组G=(V，E)</p>
<ul>
<li><p>V：结点的集合，分为P(进程)，R(资源)两部分</p>
<ul>
<li>P = {P1, P2, … , Pn}</li>
<li>R = {R1, R2, … , Rm} </li>
</ul>
</li>
<li><p>E：有向边的集合，其元素为有序二元组(Pi, Rj) 或 (Rj, Pi)</p>
</li>
</ul>
<h2 id="2-资源分配图画法说明"><a href="#2-资源分配图画法说明" class="headerlink" title="2.资源分配图画法说明"></a>2.资源分配图画法说明</h2><p>系统由若干类资源构成，一类资源称为一个资源类; 每个资源类中包含若干个同种资源，称为资源实例。</p>
<ul>
<li>资源类:用方框表示</li>
<li>资源实例:用方框中的黑圆点表示</li>
<li>进程:用圆圈中加进程名表示</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/6.png" style="zoom:33%;"></p>
<p>分配边：资源实例——&gt;进程 </p>
<p>申请边：进程 ——&gt;资源类</p>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/7.png" style="zoom:33%;"></p>
<p>例子：</p>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/8.png" style="zoom:30%;"></p>
<h2 id="3-死锁定理"><a href="#3-死锁定理" class="headerlink" title="3.死锁定理"></a>3.死锁定理</h2><ul>
<li><p>如果资源分配图中没有环路，则系统中没有死锁， 如果图中存在环路则系统中可能存在死锁</p>
</li>
<li><p>如果<strong>每个资源类中只包含一个资源实例</strong>，则环路是死锁存在的充分必要条件</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/9.png" style="zoom:33%;"></p>
<h2 id="4-资源分配的化简"><a href="#4-资源分配的化简" class="headerlink" title="4.资源分配的化简"></a>4.资源分配的化简</h2><p>化简步骤:</p>
<ol>
<li><p>找一个非孤立、且只有分配边的进程结点 去掉分配边，将其变为孤立结点</p>
</li>
<li><p>再把相应的资源分配给一个等待该资源的进程 即将该进程的申请边变为分配边</p>
</li>
<li>重复1，2</li>
</ol>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/10.png" style="zoom:30%;"></p>
<p>这张图最后能够完全被化简掉，所以没有死锁。</p>
<hr>
<h1 id="三-死锁预防"><a href="#三-死锁预防" class="headerlink" title="三.死锁预防"></a>三.死锁预防</h1><p>四种方法来解决死锁问题：</p>
<ul>
<li><p><strong>不考虑此问题(鸵鸟算法)</strong> </p>
</li>
<li><p>不让死锁发生</p>
<ul>
<li><p><strong>死锁预防</strong> </p>
<ul>
<li>静态策略：设计合适的资源分配算法，不让死锁发生</li>
</ul>
</li>
<li><p><strong>死锁避免</strong> </p>
<ul>
<li>动态策略:以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>让死锁发生</strong></p>
<ul>
<li>死锁检测与解除</li>
</ul>
</li>
</ul>
<h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li>在设计系统时，通过确定资源分配算法，排除发生死锁的可能性</li>
<li>具体的做法是：<strong>防止产生死锁的四个必要条件中任何一个条件发生</strong></li>
</ul>
<blockquote>
<p>破坏产生死锁的四 个必要条件之一</p>
</blockquote>
<h3 id="2-破坏“互斥使用-资源独占”条件"><a href="#2-破坏“互斥使用-资源独占”条件" class="headerlink" title="(2).破坏“互斥使用/资源独占”条件"></a>(2).破坏“互斥使用/资源独占”条件</h3><ul>
<li><p>资源转换技术:把独占资源变为共享资源</p>
</li>
<li><p>SPOOLing技术的引入</p>
<ul>
<li>解决不允许任何进程直接占有打印机的问题</li>
<li>设计一个“守护进程/线程”负责管理打印机， 进程需要打印时，将请求发给该daemon，由它完成 打印任务</li>
</ul>
</li>
</ul>
<h3 id="3-破坏“占有且等待”条件"><a href="#3-破坏“占有且等待”条件" class="headerlink" title="(3).破坏“占有且等待”条件"></a>(3).破坏“占有且等待”条件</h3><ul>
<li><p>实现方案1:要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配</p>
<ul>
<li>问题:资源利用率低;“饥饿”现象</li>
</ul>
</li>
<li><p>实现方案2:在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足 而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请</p>
</li>
</ul>
<h3 id="4-破坏“不可抢占”条件"><a href="#4-破坏“不可抢占”条件" class="headerlink" title="(4).破坏“不可抢占”条件"></a>(4).破坏“不可抢占”条件</h3><ul>
<li><p>实现方案:</p>
<ul>
<li>当一个进程申请的资源被其他进程占用时，可以 通过操作系统抢占这一资源(两个进程优先级不同)</li>
</ul>
</li>
<li><p>局限性:</p>
<ul>
<li>适用于状态易于保存和恢复的资源 CPU、内存</li>
</ul>
</li>
</ul>
<h3 id="5-破坏“循环等待”条件"><a href="#5-破坏“循环等待”条件" class="headerlink" title="(5).破坏“循环等待”条件"></a>(5).破坏“循环等待”条件</h3><ul>
<li>通过定义资源类型的线性顺序实现</li>
<li><p>实施方案：<strong>资源有序分配法</strong> </p>
<ul>
<li>把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配</li>
</ul>
</li>
<li><p>实现时要考虑什么问题呢? </p>
<ul>
<li>例子:解决哲学家就餐问题</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四-死锁避免"><a href="#四-死锁避免" class="headerlink" title="四.死锁避免"></a>四.死锁避免</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>在系统运行过程中，对进程发出的每一个系统 能够满足的资源申请进行动态检查，并根据检 查结果决定是否分配资源，若分配后系统发生 死锁或可能发生死锁，则不予分配，否则予以分配。</p>
<blockquote>
<p>安全状态：如果系统中存在一个由所有进程构成的安全序列P1 ,…, Pn，则称系统处于安全状态。</p>
</blockquote>
<h2 id="2-安全序列"><a href="#2-安全序列" class="headerlink" title="2.安全序列"></a>2.安全序列</h2><p>一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程$Pi(1≤i≤n):$ 它以后还需要的资源量不超过系统当前剩余资 源量与所有进程Pj (j &lt; i )当前占有资源量之和，则称系统处于安全状态。</p>
<blockquote>
<p><strong>安全状态一定没有死锁发生.</strong></p>
</blockquote>
<h2 id="3-安全状态与不安全状态"><a href="#3-安全状态与不安全状态" class="headerlink" title="3.安全状态与不安全状态"></a>3.安全状态与不安全状态</h2><p>不安全状态：系统中不存在一个安全序列 </p>
<p>不安全状态一定导致死锁</p>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/11.png" style="zoom:30%;"></p>
<hr>
<h1 id="五-死活避免——银行家算法"><a href="#五-死活避免——银行家算法" class="headerlink" title="五.死活避免——银行家算法"></a>五.死活避免——银行家算法</h1><h2 id="1-应用条件"><a href="#1-应用条件" class="headerlink" title="1.应用条件"></a>1.应用条件</h2><p>应用条件:</p>
<ol>
<li><p>在固定数量的进程中共享数量固定的资源</p>
</li>
<li><p>每个进程预先指定完成工作所需的最大资源数量</p>
</li>
<li><p>进程不能申请比系统中可用资源总数还多的资源</p>
</li>
<li><p>进程等待资源的时间是有限的</p>
</li>
<li><p>如果系统满足了进程对资源的最大需求，那么， 进程应该在有限的时间内使用资源，然后归还给系统</p>
</li>
</ol>
<h2 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h2><p>n:系统中进程数量 </p>
<p>m:资源类数量</p>
<p>Available: ARRAY[1..m] of integer;//可以分配的资源</p>
<p>Max: ARRAY[1..n,1..m] of integer; //最大需求</p>
<p>Allocation: ARRAY[1..n,1..m] of integer; //当前拥有的资源</p>
<p>Need: ARRAY[1..n,1..m] of integer; //还需要的资源</p>
<p>Request: ARRAY[1..n,1..m] of integer;//本次对资源的申请</p>
<p>当进程Pi提出资源申请时，系统执行下列步骤:</p>
<p>(1)若Request[i] ≤ Need[i]，转(2);否则，报错返回;</p>
<p>(2)若Request[i] ≤ Available，转(3); 否则，进程等待;</p>
<p>(3)假设系统分配了资源，则有</p>
<p>​    Available = Available - Request[i];</p>
<p>​    Allocation[i] = Allocation[i] + Request[i]; </p>
<p>​    Need[i] = Need[i] - Request[i];</p>
<blockquote>
<p>若系统新状态是安全的，则分配完成 </p>
<p>若系统新状态是不安全的，则恢复原来状态，进程等待</p>
</blockquote>
<p><strong>如何判断是否安全：</strong></p>
<p>为进行安全性检查，定义数据结构:</p>
<p>Work: ARRAY[1..m] of integer; </p>
<p>Finish: ARRAY[1..n] of Boolean;</p>
<p>安全性检查的步骤:</p>
<p>(1) Work = Available; Finish = false;</p>
<p>(2) 寻找满足条件的i: </p>
<p>​    a. Finish[i]==false;<br>​    b. Need[i]≤Work; 如果不存在，则转(4)</p>
<p>(3) Work = Work + Allocation[i]; Finish[i] = true;转(2)</p>
<p>(4) 若对所有i，Finish[i]==true， 则系统处于安全状态，否则系统处于不安全状态</p>
<hr>
<h1 id="六-死锁检测与解除"><a href="#六-死锁检测与解除" class="headerlink" title="六.死锁检测与解除"></a>六.死锁检测与解除</h1><h2 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>死锁检测:</p>
<ul>
<li><p>允许死锁发生，但是操作系统会不断监视系统进 展情况，判断死锁是否真的发生</p>
</li>
<li><p>一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行</p>
</li>
</ul>
<p>检测时机:</p>
<ul>
<li><p>当进程由于资源请求不满足而等待时检测死锁</p>
<ul>
<li>缺点:系统开销大</li>
</ul>
</li>
<li><p>定时检测</p>
</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
<h2 id="2-一个简单的死锁检测算法"><a href="#2-一个简单的死锁检测算法" class="headerlink" title="2.一个简单的死锁检测算法"></a>2.一个简单的死锁检测算法</h2><ul>
<li><p>每个进程、每个资源指定唯一编号</p>
</li>
<li><p>设置一张资源分配表记录各进程与其占用资源之间的关系</p>
</li>
<li>设置一张进程等待表记录各进程与要申请资源之间的关系</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/12.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/30/死锁/13.png" style="zoom:30%;"></p>
<h2 id="3-死锁的解除"><a href="#3-死锁的解除" class="headerlink" title="3.死锁的解除"></a>3.死锁的解除</h2><p><strong>重要的是以最小的代价恢复系统的运行</strong>。</p>
<p>方法如下</p>
<ul>
<li>撤消所有死锁进程</li>
<li>进程回退(Rollback)再启动</li>
<li>按照某种原则逐一撤消死锁进程，直到…</li>
<li>按照某种原则逐一抢占资源(资源被抢占的进程 必须回退到之前的对应状态)，直到…</li>
</ul>
<hr>
<h1 id="七-哲学家就餐问题"><a href="#七-哲学家就餐问题" class="headerlink" title="七.哲学家就餐问题"></a>七.哲学家就餐问题</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><ul>
<li>有五个哲学家围坐在一圆桌旁， 桌中央有一盘通心粉，每人面前有一只空盘子，每两人之间放一只筷子</li>
<li>每个哲学家的行为是思考，感到饥饿，然后吃通心粉</li>
<li>为了吃通心粉，每个哲学家必 须拿到两只筷子，并且每个人只能直接从自己的左边或右边去取筷子(筷子的互斥使用、 不能出现死锁现象)</li>
</ul>
<p>问题模型：应用程序中并发线程 执行时，协调处理共享资源。</p>
<h2 id="2-第一种解法"><a href="#2-第一种解法" class="headerlink" title="2.第一种解法"></a>2.第一种解法</h2><p>把筷子当做信号量来进行处理</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fork [<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;; <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		think();</span><br><span class="line">		P (fork[i]);</span><br><span class="line">		P (fork [(i+<span class="number">1</span>) mod <span class="number">5</span>]); eat();</span><br><span class="line">		V (fork [(i+<span class="number">1</span>) mod <span class="number">5</span>]); V (fork[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	parbegin (philosopher (<span class="number">0</span>), philosopher (<span class="number">1</span>),philosopher (<span class="number">2</span>), philosopher (<span class="number">3</span>),philosopher (<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-为了防止死锁发生可采取的措施"><a href="#3-为了防止死锁发生可采取的措施" class="headerlink" title="3.为了防止死锁发生可采取的措施"></a>3.为了防止死锁发生可采取的措施</h3><ul>
<li>最多允许4个哲学家同时坐在桌子周围</li>
<li>仅当一个哲学家左右两边的筷子都可用时，才允许他拿筷子</li>
<li>给所有哲学家编号，奇数号的哲学家必须首先 拿左边的筷子，偶数号的哲学家则反之</li>
</ul>
<h2 id="4-第二种解法"><a href="#4-第二种解法" class="headerlink" title="4.第二种解法"></a>4.第二种解法</h2><p>增加了room变量</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">semaphore fork[<span class="number">5</span>] = &#123;<span class="number">1</span>&#125;; semaphore room = &#123;<span class="number">4</span>&#125;; <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		think();</span><br><span class="line">		P (room);</span><br><span class="line">		P (fork[i]);</span><br><span class="line">		P (fork [(i+<span class="number">1</span>) mod <span class="number">5</span>]); eat();</span><br><span class="line">		V (fork [(i+<span class="number">1</span>) mod <span class="number">5</span>]); V (fork[i]);</span><br><span class="line">		V (room);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  parbegin ( philosopher (<span class="number">0</span>), philosopher (<span class="number">1</span>),philosopher (<span class="number">2</span>), philosopher(<span class="number">3</span>),philosopher (<span class="number">4</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="5-第三种解法"><a href="#5-第三种解法" class="headerlink" title="5.第三种解法"></a>5.第三种解法</h2><p>使用管程解决哲学家就餐问题</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> philosopher[k=<span class="number">0</span> to <span class="number">4</span>]</span><br><span class="line"><span class="comment">/* the five philosopher clients */</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	&lt;think&gt;;</span><br><span class="line">	get_forks(k); <span class="comment">/* client requests two forks via monitor */</span> &lt;eat spaghetti&gt;;</span><br><span class="line">	release_forks(k); <span class="comment">/* client releases forks via the monitor */</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">monitor dining_controller; </span><br><span class="line">cond ForkReady[<span class="number">5</span>]; </span><br><span class="line">boolean fork[<span class="number">5</span>] = &#123;<span class="literal">true</span>&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_forks</span><span class="params">(<span class="keyword">int</span> pid)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = pid;</span><br><span class="line">	<span class="keyword">int</span> right = (++pid) % <span class="number">5</span>;</span><br><span class="line">  <span class="comment">/*grant the left fork*/</span> </span><br><span class="line">  <span class="keyword">if</span> (!fork(left)</span><br><span class="line">		cwait(ForkReady[left]);</span><br><span class="line">	<span class="comment">/* queue on condition variable */</span></span><br><span class="line">	fork(left) = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">/*grant the right fork*/</span></span><br><span class="line">	<span class="keyword">if</span> (!fork(right) </span><br><span class="line">      cwait(ForkReady(right);</span><br><span class="line">	<span class="comment">/* queue on condition variable */</span></span><br><span class="line">	fork(right) = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> release_forks(<span class="keyword">int</span> pid) &#123;</span><br><span class="line">	<span class="keyword">int</span> left = pid;</span><br><span class="line">	<span class="keyword">int</span> right = (++pid) % <span class="number">5</span>; </span><br><span class="line">  <span class="comment">/*release the left fork*/</span></span><br><span class="line">	<span class="keyword">if</span> (empty(ForkReady[left])</span><br><span class="line">		<span class="comment">/*no one is waiting for this fork */</span></span><br><span class="line">		fork(left) = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* awaken a process waiting on this fork */</span></span><br><span class="line">		csignal(ForkReady[left]);</span><br><span class="line">	<span class="comment">/*release the right fork*/</span></span><br><span class="line">	<span class="keyword">if</span> (empty(ForkReady[right])</span><br><span class="line">		<span class="comment">/*no one is waiting for this fork */</span></span><br><span class="line">		fork(right) = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* awaken a process waiting on this fork */</span></span><br><span class="line">		csignal(ForkReady[right]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="6-第四种解法"><a href="#6-第四种解法" class="headerlink" title="6.第四种解法"></a>6.第四种解法</h2><p>为了避免死锁，把哲学家分为三种状态，思考，饥饿，进食，并且一次拿到两只筷 子，否则不拿。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2 </span></span><br><span class="line"><span class="meta">#typedef int semaphore; </span></span><br><span class="line"><span class="keyword">int</span> state[N];</span><br><span class="line">semaphore mutex=<span class="number">1</span>; </span><br><span class="line">semaphore s[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">    思考;</span><br><span class="line">		P(&amp;mutex);</span><br><span class="line">		state[i] = HUNGRY;</span><br><span class="line">		test(i);</span><br><span class="line">		V(&amp;mutex);</span><br><span class="line">    P(&amp;s[i]);</span><br><span class="line"> 		拿左筷子;</span><br><span class="line">  	拿右筷子;</span><br><span class="line">  	进食;</span><br><span class="line">    放左筷子;</span><br><span class="line">		放右筷子;</span><br><span class="line">		P(&amp;mutex)</span><br><span class="line">		state[ i ] = THINKING; </span><br><span class="line">    test([i<span class="number">-1</span>] % <span class="number">5</span>); </span><br><span class="line">    test([i+<span class="number">1</span>] % <span class="number">5</span>); </span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">state[ i ] = THINKING; </span><br><span class="line">s[i]=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state[ i ] == HUNGRY)&amp;&amp; (state [(i<span class="number">-1</span>) % <span class="number">5</span>] != EATING) &amp;&amp; (state [(i+<span class="number">1</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">	state[ i ] = EATING;</span><br><span class="line">	V(&amp;s[ i ]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统运行环境与运行机制</title>
    <url>/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-操作系统的主要工作"><a href="#一-操作系统的主要工作" class="headerlink" title="一.操作系统的主要工作"></a>一.操作系统的主要工作</h2><ul>
<li><p>程序的执行</p>
<blockquote>
<p>启动程序，执行程序以及程序的结束工作</p>
</blockquote>
</li>
<li><p><strong>完成体系结构相关的工作</strong>(操作系统与其他软件所不同的地方，与硬件打交道)</p>
</li>
<li><p><strong>完成应用程序所需的共性任务</strong>(读盘，申请内存，打印文件)</p>
<blockquote>
<p>提供各种基本服务</p>
</blockquote>
</li>
<li><p>性能，安全，健壮等问题</p>
</li>
</ul>
<p>用下图来明确操作系统的的地位：</p>
<p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/1.png" style="zoom:30%;"></p>
<blockquote>
<p>从图中我们可以看出操作系统是在硬件基础上的第一层扩展。 </p>
<p>它底下是硬件， 这个硬件都做了什么工作呢？ 怎么样去了解底下的硬件呢？<strong>这就是本讲的一个内容之一：操作系统运行环境。</strong> 和硬件相关的很多的工作实际上是和操作系统的各个功能相结合的，<strong>这里介绍最基本的 CPU 状态： 中断与异常机制。</strong> 其他的像虚拟页式存储管理的机制， 设备等等的，会在后面跟操作系统功能结合起来讲。 </p>
<p>操作系统完成应用程序当中的一些共性的工作， 向应用程序提供一些基本服务，这是本讲另外一方面的内容：操作系统运行机制,这里重点介绍系统调用机制。</p>
</blockquote>
<hr>
<h2 id="二-处理机的状态"><a href="#二-处理机的状态" class="headerlink" title="二.处理机的状态"></a>二.处理机的状态</h2><p>处理器由<strong>运算器</strong>、<strong>控制器</strong>、一系列的<strong>寄存器</strong>以及<strong>高速缓存</strong>构成。<br>寄存器主要分为两类：</p>
<ul>
<li><strong>用户可见寄存器</strong>：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数。</li>
<li><strong>控制和状态寄存器</strong>：用于控制处理器的操作通常由操作系统代码使用。</li>
</ul>
<blockquote>
<p>对于用户可见寄存器，高级语言编译器通过优化算法分配这些寄存器，并且使用这些寄存器的主要的目的是为了减少访问内存的次数， 来提高程序的运行效率。 </p>
<p>操作系统设计者更加关注的是控制和状态寄存器。 而控制处理器的操作，那么通常只能由操作系统代码来使用。</p>
</blockquote>
<h3 id="1-控制和状态寄存器"><a href="#1-控制和状态寄存器" class="headerlink" title="1.控制和状态寄存器"></a>1.控制和状态寄存器</h3><p>控制和状态寄存器用于控制处理器的操作，只能在某种特权级别下可以访问、修改。</p>
<p>常见的控制和状态寄存器：</p>
<ul>
<li>程序计数器(PC:ProgramCounter)，记录将要取出的指令的地址。</li>
<li>指令寄存器(IR:InstructionRegister)，记录最近取出的指令。</li>
<li>程序状态字(PSW:Program Status Word)，记录 处理器的运行状态如条件码、模式、控制位等信息。</li>
</ul>
<h3 id="2-操作系统的需求——保护"><a href="#2-操作系统的需求——保护" class="headerlink" title="2.操作系统的需求——保护"></a>2.操作系统的需求——保护</h3><blockquote>
<p> 下面来探讨一下操作系统对硬件的需求，其中一个非常重要的需求就是保护。</p>
</blockquote>
<p>因为操作系统运行在一个多进程的这样一个环境下，为了支持这些进程的运行。 因此得从操作系统的特征来考虑：<strong>并发、 共享</strong>。 </p>
<p>操作系统为多个程序的执行提供了这样一个并发的环境，而多个进程之间又共享操作系统所管理的各种资源。 那么这样一个并发、 共享的计算环境就要求保护 。</p>
<p>其中保护是的：</p>
<ul>
<li>用户程序与用户程序之间互不干扰</li>
<li>用户程序不对操作系统干扰</li>
</ul>
<p>这就从操作系统的角度给硬件提出了实现保护、 实现保护控制这个需求。 </p>
<p>通常，希望硬件提供一个基本运行机制：<strong>CPU 具有一个特权级别，在不同的特权级下可以运行不同的指令集合。</strong> 这样把指令分成不同的集合，供操作系统和用户程序分别使用。 通过保护又使得操作系统与用户能够相隔离。 比如说当要访问操作系统空间的时候，那么用户程序是不能够访问的，但是操作系统可以访问用户程序空间， 因此通过一个保护机制达到操作系统与用户的隔离。 </p>
<p>有了这样一个需求之后，<strong>现代处理器通常把CPU 的状态设计为两种、 三种、 或者是四种。</strong> 但是这样在CPU 上时而运行操作系统、时而运行用户程序，CPU 如何知道是运行哪一种状态呢？ 这样就有赖于一些寄存器的某些位的设置：通常是在<font color="red">程序状态字寄存器 PSW</font>中专门设置一位或是两位，根据运行程序对资源和指令的权限不同，设置不同的 CPU 状态。 </p>
<p>这样不同的程序对资源和指令的使用要求是不同的。</p>
<p>以X86 处理器当中的典型的一个标志寄存器 EFLAGS，EFLAGS 寄存器为例：</p>
<p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/2.png" style="zoom:50%;"> </p>
<p>其中就有一位<code>IOPL</code> 是 IO 的权限级别。 这个级别用两位来表示四个状态。 除了这个寄存器以外，还有一些 描述符设置了权限级别。 这是硬件提供的各种不同的CPU状态 。</p>
<h3 id="3-特权指令和非特权指令"><a href="#3-特权指令和非特权指令" class="headerlink" title="3.特权指令和非特权指令"></a>3.特权指令和非特权指令</h3><p>操作系统需要两种 CPU状态：</p>
<ul>
<li><strong>内核态(Kernel Mode)</strong>：运行操作系统程序。</li>
<li><strong>用户态(User Mode)</strong>：运行用户程序。</li>
</ul>
<p>因为操作系统只需要两个状态，而这两个状态可以指向不同的指令集合。因此把指令的集合也划分成两类：</p>
<ul>
<li><strong>特权(privilege)指令</strong>：只能由操作系统使用、用 户程序不能使用的指令。</li>
<li><strong>非特权指令</strong>：用户程序可以使用的指令。</li>
</ul>
<blockquote>
<p>其实整个指令系统操作系统是都可以使用的，它既可以使用特权指令，也可以使用非特权指令。而用户只能使用这个指令系统当中的一个子集，那么这个子集就是非特权指令。</p>
</blockquote>
<h3 id="4-实例：X86系列处理器"><a href="#4-实例：X86系列处理器" class="headerlink" title="4.实例：X86系列处理器"></a>4.实例：X86系列处理器</h3><p>X86支持4个处理器特权级别。特权环：R0、R1、R2和R3。</p>
<ul>
<li>从R0到R3，特权能力由高到低。</li>
<li>R0相当于内核态；R3相当于用户态；R1和R2则介于两者之间。</li>
<li>不同级别能够运行的指令集合不同。</li>
</ul>
<h3 id="5-CPU状态之间的转换"><a href="#5-CPU状态之间的转换" class="headerlink" title="5.CPU状态之间的转换"></a>5.CPU状态之间的转换</h3><blockquote>
<p>有了不同的特权级别，那么就需要让<strong>用户程序</strong>和<strong>操作系统</strong>之间能有转换。</p>
</blockquote>
<p><strong>用户态——&gt; 内核态</strong>：<font color="red">中断/异常/陷入机制</font></p>
<p><strong>内核态 ——&gt; 用户态</strong>：设置程序状态字PSW</p>
<p>实际上<font color="red">用户程序在执行的过程中如果需要操作系统的服务，它就要从用户态能够陷入，进入内核态。而从用户态进入内核态的一个唯一的途径就是中断/异常/陷入机制 。</font>这也是下一个非常重要的主题。</p>
<p>而从内核态返回到用户态则比较简单啊，只是通过设置程序状态字寄存器就可以了。</p>
<blockquote>
<p>上面所提到的特殊的指令：陷入指令(访管指令)。它的作用是提供给用户程序的一个接口，用这个接口使用户程序可以向操作系统提出各种服务请求。</p>
<p>之所以叫访管指令， 是因为有的时候内核态也被称为一个supervisor mode管理态。 所以在这种情况下，从用户态进入了管理态，相当于访问管理态，所以叫访管指令。 </p>
<p>而这条特殊的指令在不同的计算机系统当中实际上是用不同的指令的。 比如 int 指令，trap 指令，syscall，sysenter/sysexit。 这些指令都是不同的计算机体系结构提供的这种特殊的指令，用于陷入(用于访管)。所以这是关于CPU状态之间的转换需要的不同的条件。</p>
</blockquote>
<hr>
<h2 id="三-中断与异常机制"><a href="#三-中断与异常机制" class="headerlink" title="三.中断与异常机制"></a>三.中断与异常机制</h2><blockquote>
<p>操作系统当中的中断和异常机制就好比是汽车中的发动机，或者是飞机引擎。靠它来驱动操作系统的运行。 有的时候是可以这么说，操作系统是由中断驱动/事件驱动的。有了这个机制，操作系统就可以做很多的事情。</p>
</blockquote>
<p><strong>主要作用：</strong></p>
<ul>
<li>及时处理设备发来的中断请求</li>
<li>可使OS捕获用户程序提出的服务请求  </li>
<li>防止用户程序执行过程中的破坏性活动 </li>
<li>……</li>
</ul>
<h3 id="1-中断与异常的概念"><a href="#1-中断与异常的概念" class="headerlink" title="1.中断与异常的概念"></a>1.中断与异常的概念</h3><p>所谓中断与异常，实际上是 CPU 对系统发生的某个事件的一种反应。当这个事件发生的时候，通过对这个事件的处理实际上是改变了一个控制流。我们通常说事件的发生改变了 CPU 的一个控制流。</p>
<p><strong>过程：</strong></p>
<ul>
<li>CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序</li>
<li>处理完成后返回断点， 继续执行被打断的程序</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>是随机发生的</li>
<li>是自动处理的</li>
<li>是可恢复的</li>
</ul>
<h3 id="2-引入中断与异常的原因"><a href="#2-引入中断与异常的原因" class="headerlink" title="2.引入中断与异常的原因"></a>2.引入中断与异常的原因</h3><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><strong>原因：中断的引入实际上是为了支持CPU与<font color="red">外部设备</font>的一个并行操作</strong></p>
<p>早期的计算机系统，如果没有中断机制的话 那么 CPU 要负责对设备的所有工作的管理。但是有了中断机制之后就可以这样来工作了。 </p>
<blockquote>
<p>比如：CPU 会去启动 输入输出设备的工作。 启动做完了之后设备本身就可以独立自己进行工作了 。而 CPU 这个时候呢可以转去处理一些和这次输入输出没有关系的事情。当设备完成了它的任务之后，它通过通过了中断向 CPU 报告这次输入输出的结果。让 CPU 来决策下面该做什么事情。 </p>
</blockquote>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p><strong>原因：表示CPU执行指令时<font color="red">本身</font>出现的问题</strong></p>
<blockquote>
<p>如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令” 等，这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用。</p>
</blockquote>
<h3 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h3><p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/3.png" style="zoom:30%;"></p>
<blockquote>
<p>中断是外部事件在CPU 之外产生的事件打断了 CPU 。这些事件是正在运行的程序所不期望的。</p>
<p>异常是由正在执行的指令而引发的 。</p>
</blockquote>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/4.png" style="zoom:50%;"></p>
<h2 id="四-中断与异常机制的工作原理"><a href="#四-中断与异常机制的工作原理" class="headerlink" title="四.中断与异常机制的工作原理"></a>四.中断与异常机制的工作原理</h2><p>中断/异常机制实际上是现代计算机系统中的核心机制之一。它的主要工作是硬件和软件相互配合来完成的通过软硬件的配合，来使计算机的能力得到充分地发挥。中断/异常机制的工作原理主要是从硬件与软件两个方面分析。</p>
<p><strong>硬件：</strong>捕获中断源发出的各种中断/异常的请求 ，以某一种方式来响应，通过把控制权转交给特定的处理程序来完成这个过程，而这个过程就是中断 。异常的响应，响应中断，响应异常这是硬件完成的工作。</p>
<p><strong>软件：</strong>识别中断， 异常类型完成对应的处理，<strong>实际上就是处理程序</strong>，把它称之为中断/异常处理程序。</p>
<h3 id="1-中断响应"><a href="#1-中断响应" class="headerlink" title="1.中断响应"></a>1.中断响应</h3><p>中断响应是发现中断、接收中断的过程，这部分由中断硬件部件完成。处理器控制部件中设有<strong>中断寄存器</strong>，其中保存了各种中断信号。</p>
<p><strong>CPU响应中断过程示意：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/5.png" style="zoom:50%;"></p>
<blockquote>
<p>中断向量表是个非常重要的软硬件结合的这么一个数据结构。 每一行呢实际上是一个中断向量 。中断向量表是由若干中断向量组成。</p>
<p>每一个中断向量其实就是一个<strong>内存单元</strong>。它是存放了中断处理程序的这个入口地址，以及这个程序，在运行的时候所需要的一个处理机的状态字。</p>
</blockquote>
<p><strong>中断响应示意：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/6.png" style="zoom:50%;"></p>
<h3 id="2-中断处理程序"><a href="#2-中断处理程序" class="headerlink" title="2.中断处理程序"></a>2.中断处理程序</h3><p>设计操作系统时，为每一类中断/异常事件编好相 应的处理程序，并设置好中断向量表。系统运行时若响应中断，中断硬件部件将CPU控 制权转给中断处理程序。</p>
<p><strong>中断处理程序主要做的工作：</strong></p>
<ul>
<li>保存相关寄存器信息(硬件部件会保存关键寄存器的信息。其他的一些寄存器的信息还要再做进一步地保存)</li>
<li>分析中断/异常的具体原因</li>
<li>执行对应的处理功能</li>
<li>恢复现场，返回被事件打断的程序</li>
</ul>
<h3 id="3-中断异常机制小节"><a href="#3-中断异常机制小节" class="headerlink" title="3.中断异常机制小节"></a>3.中断异常机制小节</h3><p>以设备输入输出中断为例:</p>
<ul>
<li>打印机给CPU发中断信号 </li>
<li>CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号</li>
<li>CPU开始为软件处理中断做准备：<ul>
<li>处理器状态被切换到内核态</li>
<li>在系统栈中保存被中断程序的重要上下文环境，主要是程序计数器PC、程 序状态字PSW</li>
</ul>
</li>
<li>CPU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序</li>
<li>中断处理程序开始工作：<font color="red">(软件工作)</font><ul>
<li>在系统栈中保存现场信息</li>
<li>检查I/O设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等</li>
</ul>
</li>
<li>中断处理结束时，CPU检测到中断返回指令，从系统 栈中恢复被中断程序的上下文环境 ，CPU状态恢复成 原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期。</li>
</ul>
<h2 id="五-系统调用机制"><a href="#五-系统调用机制" class="headerlink" title="五.系统调用机制"></a>五.系统调用机制</h2><h3 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1.系统调用"></a>1.系统调用</h3><h4 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h4><p>系统调用是用户在编程时可以调用的操作系统功能。系统调用全称应该是操作系统功能调用，简称系统调用 。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>系统调用是操作系统给编程人员提供的唯一接口。 通过系统调用使得 CPU 的状态从用户态陷入了内核态。</p>
<h3 id="2-系统调用，库函数，API，内核函数之间的关系"><a href="#2-系统调用，库函数，API，内核函数之间的关系" class="headerlink" title="2.系统调用，库函数，API，内核函数之间的关系"></a>2.系统调用，库函数，API，内核函数之间的关系</h3><p><img src="//ZYBO_o.github.io/2020/07/21/操作系统运行环境与运行机制/7.png" style="zoom:40%;"></p>
<blockquote>
<ul>
<li>应用程序可以直接调系统调用。但是通常情况下，应用程序都是通过了 C 函数库或者是 API 的接口来间接地调用系统调用。</li>
<li>在操作系统内核当中，提供了很多的内核函数。这些内核函数经过了封装把它提供到了 C 函数库，或者是 API 接口 。所以系统调用对于内核而言，内核函数就是这个系统调用的处理程序，而这些处理程序通过封装在 C 函数库或者 API 接口呢提供给用户来使用。</li>
<li>但是 C 函数库里头或者是 API 接口里头还有一些函数不是系统调用，它们就是一些普通的函数在完成一些功能。</li>
<li>有一些函数通过系统调用对应到了多个内核函数，也可能是某一个函数通过系统调用对应内核的一个函数。都是不太一样的。 </li>
<li>内核函数当中 也有一些函数呢是不开放给用户使用的 </li>
</ul>
</blockquote>
<p>应用程序大部分情况下是通过调用函数。 函数执行过程中再去变成系统调用来进入内核来完成。</p>
<h3 id="3-系统调用机制的设计"><a href="#3-系统调用机制的设计" class="headerlink" title="3.系统调用机制的设计"></a>3.系统调用机制的设计</h3><ol>
<li><p>首先利用硬件给我们提供的支持(就是中断异常机制)。通过这个机制实现系统调用服务。 </p>
</li>
<li><p>然后选择一条特殊的指令即<strong>陷入指令，也称之为访管指令</strong> 通过这条指令的执行引发一个异常完成从用户态到内核态的切换工作。看到只有一条指令。也就是说所有的系统调用，都是通过这条指令来进入内核的。</p>
<blockquote>
<p>在中断向量表或中断描述符表当中有一行专门用于系统调用。</p>
</blockquote>
</li>
<li><p>然后操作系统呢要为每一个系统调用事先确定一个编号(系统调用号)，因为要确定是哪一个系统调用。所以要通过编号来区分。而且每个系统调用其实还有不同的参数 ，所以呢我们还要设计相应的参数。这些工作除了操作系统的设计之外，还需要编译器来帮忙，编译器会把这个封装的系统调用把它展开 ，在过程中生成这条特殊的陷入指令，以及这些参数的推送寄存器的这些指令。</p>
</li>
<li><p>每一个系统调用其实都有一段内核函数，或者是一段代码来对应。 找到对应的内核函数就需要设计一张系统调用表，这张表就把系统调用的各项服务的入口地址填在这张表里头，那这张表也是在这个初始化的时候设置好了。</p>
</li>
</ol>
<h3 id="4-参数传递过程问题"><a href="#4-参数传递过程问题" class="headerlink" title="4.参数传递过程问题"></a>4.参数传递过程问题</h3><p>实现用户程序的参数传递给内核常用以下3种实现方法:</p>
<ul>
<li><font color="red">由陷入指令自带参数</font> : 陷入指令的长度有限，且 还要携带系统调用功能号，只能自带有限的参数</li>
<li><font color="red">通过通用寄存器传递参数</font> : 这些寄存器是操作系 统和用户程序都能访问的，但寄存器的个数会限制传递参数的数量</li>
<li><font color="red">在内存中开辟专用堆栈区</font>来传递参数</li>
</ul>
<h3 id="5-系统调用的执行过程"><a href="#5-系统调用的执行过程" class="headerlink" title="5.系统调用的执行过程"></a>5.系统调用的执行过程</h3><p>当CPU执行到特殊的陷入指令时:</p>
<ul>
<li><font color="red">中断/异常机制 </font>:硬件保护现场;通过查中断向量表把控制权转给系统调用总入口程序</li>
<li><font color="red">系统调用总入口程序 </font>:保存现场;将参数保存在内核堆 栈里;通过查系统调用表把控制权转给相应的系统调用 处理例程或内核函数</li>
<li><font color="red">执行系统调用例程</font></li>
<li><font color="red">恢复现场，返回用户程序</font></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title>台湾清华彭明辉教授的研究生手册收获</title>
    <url>/2019/11/11/%E5%8F%B0%E6%B9%BE%E6%B8%85%E5%8D%8E%E5%BD%AD%E6%98%8E%E8%BE%89%E6%95%99%E6%8E%88%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E6%89%8B%E5%86%8C%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文的要求"><a href="#论文的要求" class="headerlink" title="论文的要求"></a>论文的要求</h1><ul>
<li><p>论文的主要内容，是叙述一套<font color="red">方法</font>在特定<font color="red">场合</font>中的应用。</p>
</li>
<li><p>这套方法必须要有所<font color="red">创新或突破</font>，并因而对<font color="red">学术界有所贡献</font>。它或者是解决既有问题的<font color="red">新方法</font>，或者是既有方法的<font color="red">新应用</font>， 或者是以一个新的方法开启一整片新的应用领域。 </p>
</li>
<li><p>在论文中，你必须要有能力<font color="red">提出足够的证据</font>来让读者信服说：针对这个应用场合，你所提出来的方法确实有比文献中一切既有方法更优越之处。 </p>
</li>
<li><p>此外，你必须要能清楚指出这个方法在应用上的限制，并且提出充分证据来说服读者：任何应用场合，只要能够满足你所提出来的<font color="red">假设（前提）条件</font>，你的方法就一定适用，而且你所描述的优点就一定会存在。</p>
</li>
<li><p>你还必须要在论文中清楚指出这个方法的<font color="red">限制和可能的缺点</font>（相对于其它文献上的既有方法，或者在其它应用场合里）。假如这个方法有任何重大缺点，在口试时才会被口试委员会指出来，其后果可能是论文无法通过。</p>
</li>
<li><p>行文风格上，它是一篇论证严谨，逻辑关系清晰，而且结构有条理的专业论述。也就是说，在叙述你的方法的过程，你必须要清清楚楚地交代这个方法的应用程序以及所有仿真或实验结果的过程，<font color="red">使得这个专业领域内的任何读者，都有办法根据你的描述，在他的实验室下复制出你的研究成果</font>，以便确定你的结论确实是可以「在任何时间、任何地点、任何人」都具有可重复性（可重复性是「科学」的根本要求）。 </p>
</li>
<li><p>而且，你对这个方法的<font color="red">每一个步骤都必须要提供充分的理由说明</font>「为什么非如此不可」。 </p>
</li>
<li><p>最后，你的论文必须要在适当位置清楚<font color="red">注明所有和你所研究之题目相关的文献</font>。而且，你必须要记得：只要是和你所研究的问题相关的学术文献（尤其是学术期刊论文），你都有必要全部找出来（如果漏掉就是你的过失），仔细读过。<font color="red">假如你在学位论文口试时，有口试委员指出有一篇既有文献，在你所讨论的问题中处理得比你的方法还好，这就构成你论文无法及格的充分理由。 </font></p>
</li>
<li><p>第（2）款所谓「对学术界的贡献」，指的是：把你的所有研究成果扣除掉学术界已经发表过的所有成果（不管你实际上有没有参考过，没有参考过也算是你的重大过失），剩下的就是你的贡献。<font color="red">假如这个贡献太少，也构成你论文无法及格的充分理由。 </font></p>
</li>
</ul>
<p>　　</p>
<blockquote>
<p>上面所叙述的九款要件中，除第（2）款之外，通通都是必须要做到的，因此没有好坏之分。一篇硕士论文的好坏（以及成绩的评定标准），主要是看第（2）款所谓「对学术界的贡献」的多寡与重要性而定。假如你要申请国外的博士班，最重要的也是看你的硕士论文有什么「贡献」而定（这往往比TOFEL，GRE，GPA还重要）。</p>
</blockquote>
<p>&lt;/br&gt;</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="完成硕士论文所需要的能力"><a href="#完成硕士论文所需要的能力" class="headerlink" title="完成硕士论文所需要的能力"></a>完成硕士论文所需要的能力</h1><blockquote>
<p> 从前面的叙述可以归纳出来，完成硕士论文所需要的能力包括以下数项，依它们的培养先后次序逐项讨论。  </p>
</blockquote>
<ul>
<li><font color="red"><strong>数据检索的能力：</strong></font>在给定（或自己拟定）的题目范围内，你必须有能力利用文资料索引系统，查出所有相关的论文，而无任何遗漏（否则你可能在论文口试时才发现同一个题目已经有人发表过了）。<font color="red">你到底要用什么样的关键词和查所程序去保证你已经找出所有相关的文献？这是第一个大的挑战。</font>每一组关键词（包含联集与交集）代表一个论文所构成的集合，假如你用的关键词不恰当，你可能找到的集合太小，没有涵盖所有的相关文献；假如你用的关键词太一般化（譬如「image」），通常你找到的集合会太大，除了所有相关文献之外还加上好几十倍的毫不相关的文献。 </li>
</ul>
<ul>
<li><font color="red"><strong>资料筛选的能力</strong></font>：即使你使用了恰当的搜寻策略，通常找到的文献集合都还是明显地比你所需要的集合大，而且通常文献比数大概在一两百篇或数百篇之间，而其中会和你的的研究子题直接且密切相关的论文，通常只有廿、卅篇左右。你如何可以<font color="red">只读论文的题目、摘要、简介和结论</font>，而还没有完全看懂内文，就准确地判断出这篇论文中是否有值得你进一步参考的内容，以便快速地把需要仔细读完的论文从数百篇降低到廿、卅篇？这考验着你从事资料筛选的能力。</li>
</ul>
<ul>
<li><font color="red">**期刊论文的阅读能力**</font>：期刊论文和大学部的课本截然不同。大学部的课本是寻次渐进地从最基本的知识背景逐步交代出整套有系统的知识，中间没有任何的跳跃，只要你逐页读下去，就可以整本都读懂，不需要在去别的地方找参考资料。但是期刊论文是没头没尾的十几页文献，只交代最核心的创意，并援引许多其它论文的研究成果（但只注明文献出处，而完全没有交代其内容）。因此，要读懂一篇论文，一定要同时读懂数篇或十数篇被援引的其它论文。偏偏，这十几篇被援引的论文又各自援引十数篇其它论文。**因此，相对于大学部的教科书而言，期刊论文是一个极端没有系统的知识，必须要靠读者自己从几十篇论文中撷取出相关的片段，自己组织成一个有系统的知识，然后才有办法开始阅读与吸收。**<font color="red">要培养出这种自己组织知识的能力，需要在学校靠着大量而持续的时间去摸索、体会，而不可能只利用业余的零星时间去培养。</font>因此，一个大学毕业后就不再念研究所的学生，不管他在大学有多优秀，都很难在工业界利用业余的时间去培养这种能力。所以，<font color="red">**硕士毕业生和大学毕业生最大的差别，就是：学士只学习过吸收系统知识的能力（也就是读别人整理、组织好的知识，典型的就是课本）；但硕士则学习过自己从无组织的知识中检索、筛选、组织知识的能力。 **</font>



</li>
</ul>
<ul>
<li><font color="red">**期刊论文的分析能力**</font>：**为了确定你的学位论文研究成果确实比所有相关的学术期刊论文都更适合处理你所拟定的应用场域，首先你必须要有能力逐篇分析出所有相关期刊论文的优点与缺点，以及自己的研究成果的优点与缺点，然后再拿他们来做比较，总结出你的论文的优点和缺点（限制）。**但是，好的期刊论文往往是国外著名学府的名师和一流的博士生共同的研究成果，假如你要在锁定的应用场域上「打败」他们，突出自己的优点，这基本上是一个极端困难的挑战。即使只是要找出他们的缺点，都已经是一个相当困难的工作了。一个大学毕业生，四年下来都是假定「课本是对的」这样地学下来的，从来没有学习如何分析课本知识的优缺点，也就是<font color="red">「只有理解的能力，而没有批判的能力」。硕士生则必须要有「对一切既有进行精确批判」的能力。</font>但是，这个批判并非个人好恶或情绪化的批判，而是真的找得到充分理由去支持的批判。这个批判的能力，让你有能力自己找到自己的优、缺点，因此也有机会自己精益求精。所以，一个大学毕业生在业界做事的时候，需要有人指导他（从事批判性检验），帮他找出缺点和建议改进的可能性。但是，<font color="red">一个严格训练过的合格硕士，他做事的时候应该是不需要有人在背后替他做检证，他自己就应该要有能力分析自己的优、缺点，主动向上级或平行单位要求支持。其实，至少要能够完成这个能力，才勉强可以说你是有「独立自主的判断能力」。 </font>



</li>
</ul>
<ul>
<li><font color="red"><strong>创新的能力</strong></font>：许多大学毕业的工程师也能创新，但是硕士的创新是和全世界同一个学术团体内所有的名师和博士生挑战。因此，两者是站在不同的比较基础上在进行的：前者往往是一个企业内部的「闭门造车」，后者是一个全球的开放性竞争。其次，工程师的创新往往是无法加以明确证明其适用条件，但是学术的创新却必须要能够在创新的同时厘清这个创新的有效条件。因此，<font color="red">大学毕业生的主要能力是吸收既有知识，但硕士毕业生却应该要有能力创造知识。</font>此外，台湾历年来工业产品的价位偏低，这一部分是因为国际大厂的打压以及国际消费者的信任不易建立。但是，另一方面，这是因为台湾的产品在品质上无法控制，因此只好被当作最粗糙的商品来贩卖。台湾的产品之所以无法有稳定的品质，背后的技术原因就是：各种创新都是只凭一时偶然的巧思，却没有办法进一步有系统地厘清这些巧思背后可以成立的条件。但是，创新其实是可以有一套「有迹可寻」的程序的，这是我最得意的心得，也是我最想教的。 </li>
</ul>
<p>&lt;/br&gt;</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="为什么要坚持培养阅读与分析期刊论文的能力"><a href="#为什么要坚持培养阅读与分析期刊论文的能力" class="headerlink" title="为什么要坚持培养阅读与分析期刊论文的能力"></a>为什么要坚持培养阅读与分析期刊论文的能力</h1><p>​    只要能够充分掌握阅读与分析期刊论文的技巧，就可以水到渠成地轻松进行「创新」的工作。所以，<font color="red"><strong>只要深入掌握到阅读与分析期刊论文的技巧</strong></font>，<font color="blue">就可以掌握到大学生不曾研习过的三种能力</font>：<font color="red">（1）自己从无组织的知识中检索、筛选、组织知识的能力、（2）对一切既有进行精确批判的独立自主判断能力、（3）创造新知识的能力。  </font></p>
<p>&lt;/br&gt;</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="期刊论文的分析技巧和程序"><a href="#期刊论文的分析技巧和程序" class="headerlink" title="期刊论文的分析技巧和程序"></a>期刊论文的分析技巧和程序</h1><blockquote>
<p> 一般来讲，好的期刊论文有较多的创意。虽然读起来较累，但收获较多而深入，因此比较值得花心思去分析。读论文之前，参考SCI Impact Factor 及学长的意见是必要的。  </p>
</blockquote>
<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>​    说明这篇论文的主要贡献、方法特色与主要内容。最慢硕二上学期必须要学会只看 Abstract 和Introduction便可以判断出这篇论文的重点和你的研究有没有直接关连，从而决定要不要把它给读完。<font color="red">假如你有能力每三十篇论文只根据摘要和简介便能筛选出其中最密切相关的五篇论文，你就比别人的效率高五倍以上。以后不管是做事或做学术研究，都比别人有能力从更广泛的文献中挑出最值得参考的资料。  </font></p>
<h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>​    Introduction 的功能是介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的未解问题，以及在这个背景下这篇论文的想解决的问题和它的重要性。对初学的学生而言，从这里可以了解以前研究的概况。<strong>通常我会建议初学的学生，对你的题目不熟时，先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这三个问题：</strong><font color="red">（2A）在这领域内最常被引述的方法有哪些？（2B）这些方法可以分成哪些主要派别？（2C）每个派别的主要特色（含优点和缺点）是什么？</font></p>
<p>　　问题是，你怎么去找到这最初的30～40篇论文？有一种期刊论文叫做「review paper」，专门在一个题目下面整理出所有相关的论文，并且做简单的回顾。你可以在搜寻 Compendex 时在 keywords 中加一个「review」而筛选出这类论文。然后从相关的数篇review paper 开始，从中根据 title 与 Abstract 找出你认为跟你研究题目较相关的30～40篇论文。 </p>
<p>　　通常只要你反复读过该领域内30～40篇论文的Abstract 和 Introduction，你就应该可以从Introduction的评论中回答（2A）和（2B）这两个问题。<strong>尤其要记得，当你阅读的目的是要回答（2A）和（2B）这两个问题时，你一定要先挑那些 Introduction写得比较有观念的论文念（很多论文的Introduction 写得像流水帐，没有观念，这种论文刚开始时不要去读它）。</strong>假如你读过假如30～40篇论文的 Abstract 和 Introduction之后，还是回答不了（2C），先做下述的工作。 </p>
<p>　　你先根据（2A）的答案，把这领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，你每次只重新读一派的 Abstract 和 Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读 ，读的时候只企图回答一个问题：<font color="red">这一派的创意与主要诉求是什么？</font>这样，你逐派逐派地把每一派的Abstract 和 Introduction 给读完，总结出这一派主要的诉求 、方法特色和优点（每一篇论文都会说出自己的优点，仔细读就不会漏掉）。 </p>
<p>　　其次，你再把这些论文拿出来，但是只读Introduction，认真回答下述问题：<font color="red">「每篇论文对其它派别有什么批评？」然后你把读到的重点逐一记录到各派别的「缺点」栏内。 </font></p>
<p>　　通过以上程序，你就应该可以掌握到（2A）、（2B）、和（2C）三个问题的答案。这时你对该领域内主要方法、文献之间的关系算是相当熟捻了，但是你还是只仔细 读完Abstract 和 Introduction而已，内文则只是笼统读过。<br>　　这时候，你已经掌握到这领域主要的论文，你可以用这些论文测试看看你用来搜寻这领域论文的 keywords 到底恰不恰当，并且用修正过的 keywords 再搜寻一次论文，把这领域的主要文献补齐，也把原来30～40篇论文中后来发现关系较远的论文给筛选掉，只保留大概20篇左右确定跟你关系较近的文献。如果有把握，可以甚至删除一两个你不想用的派别（要有充分的理由），只保留两、三个派别（也要有充分的理由）继续做完以下工作。 </p>
<p>　　然后你应该利用（2C）的答案，再进一步回答一个问题<font color="red">（2D）：「这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？」</font>然后，你就可以整理出这个领域（研究题目）主要的应用场合，以及这些应用场合上该注意的事项。 </p>
<p>　　最后，<strong>在你真正开始念论文的 main body 之前，你应该要先根据（2A）和（2C的答案，把各派别内的论文整理在同一个档案夹里，并照时间先后次序排好。然后依照这些派别与你的研究方向的关系远近，一个派别一个派别地逐一把各派一次念完一派的 main bodies。 </strong></p>
<h2 id="3-Main-body（含simulation-and-or-experimental-examples）："><a href="#3-Main-body（含simulation-and-or-experimental-examples）：" class="headerlink" title="3. Main body（含simulation and/or experimental examples）："></a>3. Main body（含simulation and/or experimental examples）：</h2><p>　　在你第一次有系统地念某派别的论文 main bodies 时，你只需要念懂：</p>
<ul>
<li><font color="red">（3A）这篇论文的主要假设是什么（在什么条件下它是有效的），并且评估一下这些假设在现实条件下有多容易（或多难）成立。愈难成立的假设，愈不好用，参考价值也愈低。</font>
</li>
<li><font color="red">（3B）在这些假设下，这篇论文主要有什么好处。</font>
</li>
<li><font color="red">（3C）这些好处主要表现在哪些公式的哪些项目的简化上。</font>

<p>​    至于整篇论文详细的推导过程，你不需要懂。除了三、五个关键的公式（最后在应用上要使用的公式，你可以从这里评估出这个方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性）之外，其它公式都不懂也没关系，公式之间的恒等式推导过程可以完全略过去。<font color="red">假如你要看公式，重点是看公式推导过程中引入的假设条件，而不是恒等式的转换。</font> </p>
</li>
</ul>
<p>​    但是，在你开始根据前述问题念论文之前，你应该先把这派别所有的论文都拿出来，逐篇粗略地浏览过去（不要勉强自己每篇或每行都弄到懂，而是轻松地读，能懂就懂，不懂就不懂），从中挑出容易念懂的 papers，以及经常被引述的论文。然后把这些论文照时间先后次序依序念下去。记得：你念的时候只要回答（3A）、（ 3B）、（3C）三个问题就好，不要念太细。<br>　　这样念完以后，你应该把这一派的主要发展过程，主要假设、主要理论依据、以及主要的成果做一个完整的整理。其次，你还要在根据（2D）的答案以及这一派的主要假设，进一步回答下一个问题：<font color="red">（3D）这一派主要的缺点有哪些。</font>最后，根据（ 3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。 </p>
<p>　　<font color="red">记住：回答完这些问题时，你还是不应该知道恒等式是怎么导出来的！ </font></p>
<p>　　当你是生手的时候，你要评估一个方法的优缺点时，往往必须要参考它Examples。但是，要记得：老练的论文写作高手会故意只 present 成功的案例而遮掩失败的案例。所以，simulation examples and/or experiments 很棒不一定表示这方法真的很好。你必须要回到这个方法的基本假设上去，以及他在应用时所使用的主要公式（resultant equations）去，凭自己的思考能力， 并且参考（2C）和（2D）的答案，自己问问看：当某某假设在某些实用场合上无法成立时，这个方法会不会出什么状况？猜一猜，预测一下这个方法应该会在哪些条件下（应用场合）表现优异，又会在哪些条件下（应用场合）出状况？根据这个猜测再检验一次simulation examples and/or experiments，看它的长处与短处是不是确实在这些examples 中充分被检验，且充分表现出来。 </p>
<p>　　<font color="red">那么，你什么时候才需要弄懂一篇论文所有的恒等式推导过程，或者把整篇论文细细读完？NEVER！你只需要把确定会用到的部分给完全搞懂就好，</font>不确定会不会用到的部分，只需要了解它主要的点子就够了。 </p>
<p>　　硕士生和大学生最主要的差别：大学生读什么都必须要从头到尾都懂，硕士生只需要懂他用得着的部分就好了！大学生因为面对的知识是有固定的范围，所以他那样念。硕士生面对的知识是没有范围的，因此他只需要懂他所需要的细腻度就够了。<font color="red">硕士生必须学会选择性的阅读，而且必须锻炼出他选择时的准确度以及选择的速度，不要浪费时间在学用不着的细节知识！多吸收「点子」比较重要，而不是细部的知识。 </font></p>
<p><img src="//ZYBO_o.github.io/2019/11/11/台湾清华彭明辉教授的研究生手册收获/1.png" alt><img src="//ZYBO_o.github.io/2019/11/11/台湾清华彭明辉教授的研究生手册收获/2.png" alt></p>
<p>&lt;/br&gt;</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="论文阅读的补充说明"><a href="#论文阅读的补充说明" class="headerlink" title="论文阅读的补充说明"></a>论文阅读的补充说明</h1><p>​       硕士生开始学读期刊论文时，就容易犯的毛病就是戒除不掉大学部的习惯：<font color="red">（1）老是想逐行读懂，有一行读不懂就受不了。（2）不敢发挥自己的想象，读论文像在读教科书，论文没写的就不会，瘫痪在那里；被我逼着去自己猜测或想象时，老怕弄错作者的意思，神经绷紧，脑筋根本动不了。 </font></p>
<p>　　大学毕业后（不管是念硕、博士或工作），可以参考的资料都没有秩序地交错成一团，而且永远都读不完。用大学生的心态读书，结果一定时间永远不够用。<strong>因此，每次读论文都一定要带着问题去读，每次读的时候都只是图回答你要回答的问题。因此，一定是选择性地阅读，一定要逐渐由粗而细地一层一层去了解。上面所规划的读论文的次序，就是由粗而细，每读完一轮，你对这问题的知识就增加一层。根据这一层知识就可以问出下一层更细致的问题，再根据这些更细致的问题去重读，就可以理解到更多的内容。</strong><font color="red">因此，一定是一整批一起读懂到某个层次，而不是逐篇逐篇地整篇一次读懂。 </font></p>
<p>　　这样读还有一个好处：<strong>第一轮读完后，可以根据第一轮所获得的知识判断出哪些论文与你的议题不相关，不相关的就不需要再读下去了。</strong>这样才可以从广泛的论文里逐层准确地筛选出你真正非懂不可的部分。<font color="red">不要读不会用到的东西，白费的力气必须被极小化！其实，绝大部分论文都只需要了解它的主要观念（这往往比较容易），而不需要了解它的详细推导过程（这反而比较费时）。 </font></p>
<p>　　其次，一整批一起读还有一个好处：同一派的观念，有的作者说得较易懂，有的说得不清楚。<font color="red">整批读略过一次之后，就可以规划出一个你以为比较容易懂的阅读次序，而不要硬碰硬地在那里撞墙壁。你可以从甲论文帮你弄懂以论文的一个段落，没人说读懂甲论文只能靠甲论文的信息。所以，整批阅读很像在玩跳棋，你要去规划出你自己阅读时的「最省力路径」。 </font></p>
<p>　　大学部学生读东西一定要循规蹈矩，你还没修过机械视觉相关课程之前可能也只好循规蹈矩地逐行去念。但是一旦修过机械视觉相关课程，许多论文中没被交代的段落你也已经可以有一些属于你的想象（虽然有可能猜错，尤其刚开始时经常猜错，但没关系，下面详述）。这些想象往往补足论文跳跃处最快速的解决方案。其实，一个大学毕业生所学已经很多了，对许多是都可以有一个不太离谱的想象能力。但是大部分学生却根本不敢去想象。<font color="red">我读论文远比学生快，分析远比学生深入，主要的是我敢想象与猜测，而且多年训练下来想象与猜测的准确度很高。所以，许多论文我根本不是「读懂」的，而是「猜对」了！ </font></p>
<p>　　假如猜错了怎么办？不用怕！猜完一后要根据你的猜测在论文里找证据，用以判断你的猜测对不对。猜对了，就用你的猜测（其实是你的推理架构）去吸收作者的资讯与创意（这会比从头硬生生地去迁就作者的思路轻松而容易）；猜错了，论文理会有一些信息告诉你说你错了，而且因为猜错所以你读到对的答案时反而印象更深刻。 </p>
<p>&lt;/br&gt;</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="论文报告的要求与技巧"><a href="#论文报告的要求与技巧" class="headerlink" title="论文报告的要求与技巧"></a>论文报告的要求与技巧</h1><p>报告一篇论文，我要求做到以下部分（依报告次序排列）： </p>
<ul>
<li><p>投影片第一页必须列出论文的题目、作者、论文出处与年份。 </p>
</li>
<li><p>以下每一页投影片只能讲一个观念，不可以在 一张投影片里讲两个观念。 </p>
</li>
<li><p>说明这篇论文所研究的问题的重点，以及这个问题可能和工业界的哪些应用相关。 </p>
</li>
<li><p>清楚交代这篇论文的主要假设，主要公式，与主要应用方式（以及应用上可能的解题流程）。 </p>
</li>
<li><p>说明这篇论文的范例（simulation examples and/or experiments），预测这个方法在不同场合时可能会有的准确度或好用的程度.</p>
</li>
<li><p>你个人的分析、评价与批评，包括：<font color="red">（6A）这篇论文最主要的创意是什么？（6B）这些创意在应用上有什么好处？（6C）这些创意和应用上的好处是在     哪些条件下才能成立？（6D）这篇论文最主要的缺点或局限是什么？（6E）这些缺点或局限在应用上有什么坏处？（6F）这些缺点和应用上的坏处是因为哪些因素而引入的？（6G）你建议学长学弟什么时候参考这篇论文的哪些部分（点子）？ </font></p>
<p>​     一般来讲，刚开始报告论文（硕一上学期）时只要做到能把前四项要素说清楚就好了，但是硕一结束后（暑假开始）必须要设法做到六项要素都能触及。硕二下学期开始的时候，必须要做到六项都能说清楚。 </p>
<p>​     注意：读论文和报告论文时，最重要的是它的创意和观念架构，而不是数学上恒等式推导过程的细节（顶多只要抓出关键的 equation 去弩懂以及说明清楚即可）。你报告观念与分析创意，别人容易听懂又觉得有趣；你讲恒等式，大家不耐烦又浪费时间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>研究生学习</category>
      </categories>
      <tags>
        <tag>论文积累与想法</tag>
      </tags>
  </entry>
  <entry>
    <title>同步机制</title>
    <url>/2020/08/12/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-进程的并发执行"><a href="#一-进程的并发执行" class="headerlink" title="一.进程的并发执行"></a>一.进程的并发执行</h1><blockquote>
<p> <strong>问题的提出：</strong>这一讲的问题都是由于并发所引起的.并发是所有问题产生的基础，并发也是操作系统设计的一个基础。</p>
</blockquote>
<h2 id="1-进程特征所带来的问题"><a href="#1-进程特征所带来的问题" class="headerlink" title="1.进程特征所带来的问题"></a>1.进程特征所带来的问题</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="(1).并发"></a>(1).并发</h3><ul>
<li><strong>进程的执行是间断性的。</strong></li>
</ul>
<blockquote>
<p> 每个进程在它的生命周期期间一会儿上CPU执行，一会儿由于某种原因暂停执行，所以每个进程的执行是间断性的 </p>
</blockquote>
<ul>
<li><strong>进程的相对执行速度是不可预测</strong></li>
</ul>
<blockquote>
<p> 进程执行的间断性使得进程的相对执行速度是不可预测的。由于有进程调度，有其他事件的发生，每个进程上CPU执行可能执行一段时间停止，然后再接着执行，所以整个执行的时间是不可预测的。</p>
</blockquote>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="(2).共享"></a>(2).共享</h3><ul>
<li><strong>进程/线程之间的制约性</strong></li>
</ul>
<blockquote>
<p>在一个并发环境下多个进程或者线程之间会共享某些资源，在这些资源的使用过程中会产生进程之间的一种制约性。比如当一个进程享用打印机这个资源，另外一个进程在第一个进程没有释放这个资源的前提之下就得不到这个资源，那就得等待。因此在一个并发环境下多个进程的执行会带来一种制约。</p>
</blockquote>
<h3 id="3-不确定性"><a href="#3-不确定性" class="headerlink" title="(3).不确定性"></a>(3).不确定性</h3><ul>
<li><strong>进程执行的结果与其执行的相对速度有关</strong>，是不确定的</li>
</ul>
<blockquote>
<p>进程执行的结果和它的相对执行速度是有关系的，因此在不同的执行顺序的情况下，进程的执行结果也是不确定的。</p>
</blockquote>
<h2 id="2-与时间相关的错误例子"><a href="#2-与时间相关的错误例子" class="headerlink" title="2.与时间相关的错误例子"></a>2.与时间相关的错误例子</h2><p>场景是 get、copy和put 三个进程并发执行：</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/1.png" style="zoom:35%;"></p>
<h3 id="1-并发执行过程的分析"><a href="#1-并发执行过程的分析" class="headerlink" title="(1).并发执行过程的分析"></a>(1).并发执行过程的分析</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/2.png" style="zoom:25%;"></p>
<p>假设 g,c,p 分别为 get,copy 和 put 的一次循环过程。因此从当前状态出发能得到正确的结果。 </p>
<p><img src="/Users/zhangyongbin/Blog/zybTree/source/_posts/同步机制/3.png" style="zoom:25%;"></p>
<p>所以如果不满足进程的制约关系，调度的顺序不正确，那就会带来这些错误的结果。</p>
<h3 id="2-进程前趋图"><a href="#2-进程前趋图" class="headerlink" title="(2).进程前趋图"></a>(2).进程前趋图</h3><p>三个进程的制约关系如下：</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/4.png" style="zoom:30%;"></p>
<blockquote>
<ul>
<li><p>当get执行完第一个循环之后，只能够copy执行它的第一个循环。 </p>
</li>
<li><p>当copy执行完第一个循环之后可以 是put执行第一个循环，也可以是get执行第二个循环。</p>
</li>
<li><p>以上两个都执行完了，才能够去执行copy的第二个循环。</p>
</li>
</ul>
</blockquote>
<p>因此这三个进程之间的制约关系应该满足这样一个前趋图才能保证不出错误。</p>
<hr>
<h1 id="二-进程互斥"><a href="#二-进程互斥" class="headerlink" title="二.进程互斥"></a>二.进程互斥</h1><h2 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1.竞争条件"></a>1.竞争条件</h2><p>竞争条件定义：<strong>两个或多个进程读写某些共享数据， 而最后的结果取决于进程运行的精确时序。</strong></p>
<blockquote>
<p> 和时间是相关的 这就是带来了竞争条件。</p>
<p>竞争条件是由于有一个共享的资源，而多个进程都对这个数据进行相应的操作，所以会带来竞争条件这个概念，比如打印机。</p>
</blockquote>
<h2 id="2-进程互斥的概念"><a href="#2-进程互斥的概念" class="headerlink" title="2.进程互斥的概念"></a>2.进程互斥的概念</h2><p><strong>进程互斥的概念:</strong>由于各进程要求使用共享资源(变量、文件等)， 而这些资源需要<strong>排他性使用</strong>，各<strong><font color="red">进程之间竞争使用这些资源</font></strong>，这一关系称为进程互斥。</p>
<p><strong>临界资源 (critical resource)</strong>：系统中<strong><font color="red">某些资源一次只允许一个进程使用</font></strong>，称这样的资源为<strong>临界资源</strong>或<strong>互斥资源</strong>或<strong>共享变量</strong>。</p>
<blockquote>
<p>进程互斥所使用的共享资源是一个核心，这个共享资源就是临界资源。</p>
</blockquote>
<p><strong>临界区(互斥区) [critical section(region)]</strong>： 各个进程中对某个临界资源(共享变量)实施操作的程序片段。</p>
<blockquote>
<p>当多个进程都要使用同一个共享资源时，它的代码里就会有相应的操作。而这些代码就是临界区。 </p>
<p>这些程序片段，分散在不同的进程里，它们的共同的特点是对同一个共享变量进行一些操作。这一段代码，和另外一个进程的这一段代码<strong>互为临界区，互为互斥区</strong>。</p>
</blockquote>
<h2 id="3-临界区的使用原则"><a href="#3-临界区的使用原则" class="headerlink" title="3.临界区的使用原则"></a>3.临界区的使用原则</h2><p>如下图所示，A进程在临界区里还没有出临界区，如果B进程上CPU之后也想进临界区，应该不能够让它进去，如果B进程也进临界区，就会出现关键活动的交叉，带来前面所介绍的各种各样的错误。因此当B进程想要进临界区时，由于A进程还在临界区里，所以 B 进程只能够被阻塞。</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/6.png" style="zoom:36%;"></p>
<blockquote>
<p> 回顾上一章优先级反转问题。 有一个低优先级的进程进入了临界区，因为它优先级比较低，有更高优先级进程就绪时就会抢占它的CPU ，可低优先级进程已经在临界区里，所以更高优先级的进程也上不了CPU运行，因为上CPU运行也进不了临界区。所以就被阻塞。</p>
<p>而在高优先级和低优先级之间又会有中级优先级且非常耗时的一些进程在执行，使得低优先级的进程上不了CPU ，也就不能够让高优先级的进程尽快上 CPU。</p>
</blockquote>
<p>给出临界区的使用原则：</p>
<ul>
<li><strong>没有进程在临界区时，想进入临界区的进程可进入</strong></li>
<li><strong>不允许两个进程同时处于其临界区中</strong></li>
<li><strong>临界区外运行的进程不得阻塞其他进程进入临界区</strong> </li>
<li><strong>不得使进程无限期等待进入临界区</strong></li>
</ul>
<h2 id="4-实现进程互斥的方案"><a href="#4-实现进程互斥的方案" class="headerlink" title="4.实现进程互斥的方案"></a>4.实现进程互斥的方案</h2><h3 id="1-软件方案"><a href="#1-软件方案" class="headerlink" title="(1).软件方案"></a>(1).软件方案</h3><h4 id="软件解法1"><a href="#软件解法1" class="headerlink" title="软件解法1"></a>软件解法1</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/7.png" style="zoom:28%;"></p>
<p>假设 P先上的CPU，free的初值是 false ，所以循环结束。 </p>
<p>如果这时进程P被切换下CPU，而上CPU的正好又是进程 Q，那么进程Q也要判断free是不是false，由于进程P还没有来得及改变它的值，因此Q检测的结果free也等于false ，继续往下执行把 free 变成 true ，然后进入了临界区。 如果Q进入临界区之后又一次被切换下去了。假设正好又是P上CPU了，把 free 变成 true ，然后进入临界区。结果在临界区里两个进程，不满足原则。这就是一个错误的解法。 </p>
<p>解决方案： </p>
<p><strong>把两条语句写成一个lock函数，如果把lock函数设计成一个原语</strong>，在执行过程中不容许被中断，那么这个操作就是正确的了。 </p>
<h4 id="软件解法2"><a href="#软件解法2" class="headerlink" title="软件解法2"></a>软件解法2</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/8.png" style="zoom:28%;"></p>
<p>如果P进程想进临界区，而turn等于false ，所以它一直在等待进入临界区。可是如果Q进程始终没有进过临界区，也不想进临界区，那么 P进程就进不了临界区，尽管临界区里没有进程。也就是说，在临界区外的进程Q阻止了P进程进临界区。这也是不允许的。</p>
<h4 id="软件解法3"><a href="#软件解法3" class="headerlink" title="软件解法3"></a>软件解法3</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/9.png" style="zoom:28%;"></p>
<p>如果当pturn设置为true之后，紧跟着qturn也是true，这就会导致两个进程都进不了临界区，都在”谦让”。而这，就是<code>After you</code>问题。</p>
<h4 id="软件解法4——DEKKER算法"><a href="#软件解法4——DEKKER算法" class="headerlink" title="软件解法4——DEKKER算法"></a>软件解法4——DEKKER算法</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/10.png" style="zoom:28%;"></p>
<p>在解法三的基础上引入turn，让turn值来决定是哪一个进程进入临界区，但是这个算法会出现<code>忙等待 busy waiting</code>问题，浪费了时间。</p>
<h4 id="软件解法5——PETERSON算法"><a href="#软件解法5——PETERSON算法" class="headerlink" title="软件解法5——PETERSON算法"></a>软件解法5——PETERSON算法</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/11.png" style="zoom:28%;"></p>
<p>当任何一个进程想进临界区时，它只需要调用<code>enter_region</code>函数，查看能发安全地进入临界区，如果能安全地进入临界区，那么就是相当于这个函数执行结束，可以进临界区。如果不能够安全地进入临界区，就会在这个函数当中去等待进入临界区。 </p>
<p>调用这个函数是用进程号，当进程使用完临界区的相关资源之后，出临界区时就调用<code>leave_region</code>函数，就可以让其他的进程进入临界区。</p>
<h3 id="2-硬件方案"><a href="#2-硬件方案" class="headerlink" title="(2).硬件方案"></a>(2).硬件方案</h3><h4 id="硬件解法1——中断屏蔽法"><a href="#硬件解法1——中断屏蔽法" class="headerlink" title="硬件解法1——中断屏蔽法"></a>硬件解法1——中断屏蔽法</h4><p>利用开关中断指令，<strong>是一条允许中断或禁止中断的指令</strong>。</p>
<p>操作就是在<strong>进临界区之前先把中断关闭，然后进入临界区做相应的操作，出临界区时再把中断打开，允许中断。</strong>这实际上就是<strong>原语操作。</strong></p>
<p>特点：</p>
<ul>
<li>简单，高效</li>
<li>代价高，限制CPU并发能力(临界区大小) </li>
<li>不适用于多处理器</li>
<li>适用于操作系统本身，不适于用户进程</li>
</ul>
<h4 id="硬件解法2——“测试并加锁”指令"><a href="#硬件解法2——“测试并加锁”指令" class="headerlink" title="硬件解法2——“测试并加锁”指令"></a>硬件解法2——“测试并加锁”指令</h4><p>用测试并加锁这条指令去操作， 这一条指令做了两个事情，一是先读内存单元内容，读到寄存器，然后再去写，把内存单元的内容写上某个值。</p>
<p><strong>TSL指令：TEST AND SET LOCK</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/12.png" style="zoom:40%;"></p>
<h4 id="硬件解法3——“交换”指令"><a href="#硬件解法3——“交换”指令" class="headerlink" title="硬件解法3——“交换”指令"></a>硬件解法3——“交换”指令</h4><p>交换指令的作用<strong>是把两个位置，可能是寄存器或内存单元，在一条指令结束的时把两个位置的内容进行一个交换。</strong></p>
<p><strong>XCHG指令：EXCHANGE</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/13.png" style="zoom:40%;"></p>
<hr>
<h1 id="三-进程同步"><a href="#三-进程同步" class="headerlink" title="三.进程同步"></a>三.进程同步</h1><blockquote>
<p>进程互斥指进程之间具有一种竞争关系，而进程同步指多个进程之间的协作关系 。</p>
</blockquote>
<p><strong>进程同步 (synchronization)：指系统中多个进程中发生的事件存在<font color="red">某种时序关系</font>，需要相互合作，共同 完成一项任务。</strong>具体地说，一个进程运行到某一点时， 要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态， 获得消息后被唤醒进入就绪态。</p>
<h2 id="1-生产者与消费者问题"><a href="#1-生产者与消费者问题" class="headerlink" title="1.生产者与消费者问题"></a>1.生产者与消费者问题</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/14.png" style="zoom:32%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/15.png" style="zoom:32%;"></p>
<blockquote>
<p>来看一个场景 ：</p>
<p>消费者判断count是否等于 0，如果在它判断count = 0还没有去调用sleep之前消费者被切换下CPU。那么这个时候count是0，假设生产者又生产了一个数据上CPU，可以看到就不断地去生产放到缓冲区，count也不等于 N ，刚才是0，现在生产者生产了一个数据加完 1 之后count就等于1。这时生产者知道count 等于 1，所以会做一个wakeup。但是由于刚才的消费者还没有sleep，所以做的这个wakeup实际上做了一个空操作，因为没有进程在睡眠，所以就继续接着执行，生产者继续生产。如果生产者被切换下CPU，消费者一上来肯定首先要做sleep，但是这个sleep的进程刚才wakeup已经做完了，所以就不会再被唤醒了。所以没有做到完全解决生产者/消费者问题。</p>
</blockquote>
<hr>
<h1 id="四-信号量及PV操作"><a href="#四-信号量及PV操作" class="headerlink" title="四.信号量及PV操作"></a>四.信号量及PV操作</h1><blockquote>
<p>之所以叫同步机制是因为通常把进程的互斥看成是一种特殊的同步。它既解决同步的问题，也能解决互斥的问题。这种典型的进程同步机制就称为信号量及PV 操作。</p>
</blockquote>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-信号量"><a href="#1-信号量" class="headerlink" title="(1).信号量"></a>(1).信号量</h3><p><strong>信号量：</strong>是一个特殊变量，用于进程间传递信息的一个整数值。</p>
<p>定义如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">struc semaphore &#123;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  queueType <span class="built_in">queue</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由一个值和一个队列组成，<code>int值</code>传递信息的整数值，队列允许进程挂到上面。 </p>
<ul>
<li><p>声明一个信号量：<code>semaphore s;</code></p>
</li>
<li><p>对信号量可以实施的操作: <strong>初始化、P和V</strong> (P、V分别 是荷兰语的test(proberen)和increment(verhogen))</p>
</li>
</ul>
<h3 id="2-PV操作定义"><a href="#2-PV操作定义" class="headerlink" title="(2).PV操作定义"></a>(2).PV操作定义</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/16.png" style="zoom:34%;"></p>
<ul>
<li><p>P、V操作为<strong>原语操作</strong> (primitive or atomic action)</p>
</li>
<li><p>在信号量上定义了三个操作: <strong>初始化(非负数)、P操作、V操作</strong></p>
</li>
<li><p>最初提出的是二元信号量(解决互斥)</p>
<blockquote>
<p>之后，推广到一般信号量(多值)或计数信号量(解决同步)</p>
</blockquote>
</li>
</ul>
<h2 id="2-用PV操作解决进程间互斥问题"><a href="#2-用PV操作解决进程间互斥问题" class="headerlink" title="2.用PV操作解决进程间互斥问题"></a>2.用PV操作解决进程间互斥问题</h2><h3 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="(1).基本步骤"></a>(1).基本步骤</h3><ul>
<li><strong>分析并发进程的关键活动，划定临界区</strong></li>
</ul>
<ul>
<li><strong>设置信号量 mutex，初值为1</strong></li>
<li><strong>在临界区前实施 P(mutex)</strong></li>
<li><strong>在临界区之后实施 V(mutex)</strong></li>
</ul>
<h3 id="2-例子"><a href="#2-例子" class="headerlink" title="(2).例子"></a>(2).例子</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/17.png" style="zoom:35%;"></p>
<p>假定有三个进程 P1、 P2、 P3，它们都对同一个临界资源进行相应的操作，设定了一个信号量 mutex ，初值是 1。在临界区的前和后把 P、V操作加上。</p>
<ul>
<li>假设P1先上CPU，它在做P操作时把 mutex减1，mutex=0 。0不小于0，所以P1进程就可以进入临界区。</li>
<li>如果P1进程在临界区的期间被中断了，那么P2进程正好上CPU。它也想进临界区，也做 P(mutex)，而mutex-1 = -1。 因此P2进程就等在mutex队列上。</li>
<li><p>让出 CPU 之后，假设 P3进程又上CPU。它也要进临界区。mutex -1 = 2。因此P3 进程也等在这个信号量上，等在P2后面，让出CPU。 </p>
</li>
<li><p>假设P1又上CPU， 然后它在临界区里完成了工作后出临界区。，接着会执行一个 V(mutex) ，mutex + 1 = -1，这个时候信号量的值还是小于等于 0，因此V操作就会到队列里找到进程P2并把它送到就绪队列，然后P1接着做别的事情。 </p>
</li>
<li><p>如果P2上CPU了，它就下一个就进入临界区。P操作执行完后，它接着就进临界区，当它出临界区又做一次 V 操作，mutex +1 = 0，还是小于等于 0 ，所以V操作就会把队列里等的P3进入就绪，就是这样一个过程。</p>
</li>
</ul>
<h2 id="3-用信号量解决生产者-消费者问题"><a href="#3-用信号量解决生产者-消费者问题" class="headerlink" title="3.用信号量解决生产者/消费者问题"></a>3.用信号量解决生产者/消费者问题</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/19.png" style="zoom:40%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/18.png" style="zoom:35%;"></p>
<p>如果把消费者的P(&amp;full)和P(&amp;mutex)互换，当出现缓冲区个数为0的时候，执行P(&amp;mutex)和P(&amp;full)之后，mutex=-1，此时如果生产者执行P(&amp;emputy)和P(&amp;mutex)会<strong>出现死锁</strong>。</p>
<p>两个V 操作的顺序可以颠倒，因为V操作只是把信号量的值加一。然后查看有无进程等在队列里，如果有就把它释放。 因此V操作不会使得调用V操作的这个进程进入等待状态，所以这两个的顺序是可以颠倒的。 颠倒的结果可能会带来其他的一些问题，比如说，临界区里头会多一点点指令，其他的进程想进临界区可能会稍微晚一点。但是代码中的是最理想的。</p>
<h2 id="4-用信号量解决读者-写者问题"><a href="#4-用信号量解决读者-写者问题" class="headerlink" title="4.用信号量解决读者/写者问题"></a>4.用信号量解决读者/写者问题</h2><p>问题描述:</p>
<p>多个进程共享一个数据区，这些进程分为两组: </p>
<ul>
<li><strong>读者进程:</strong>只读数据区中的数据 </li>
<li><strong>写者进程:</strong>只往数据区写数据</li>
</ul>
<p>要求满足条件:</p>
<ul>
<li>允许多个读者同时执行读操作 </li>
<li>不允许多个写者同时操作</li>
<li>不允许读者、写者同时操作</li>
</ul>
<h3 id="1-第一类读者写者问题：读者优先"><a href="#1-第一类读者写者问题：读者优先" class="headerlink" title="(1).第一类读者写者问题：读者优先"></a>(1).第一类读者写者问题：读者优先</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果读者执行:</p>
<ul>
<li><strong>无其他读者、写者，该读者可以读</strong></li>
<li><strong>若已有写者等，但有其他读者正在读，则该读者也可以读</strong></li>
<li><strong>若有写者正在写，该读者必须等</strong></li>
</ul>
<p>如果写者执行:</p>
<ul>
<li><strong>无其他读者、写者，该写者可以写</strong> </li>
<li><strong>若有读者正在读，该写者等待</strong></li>
<li><strong>若有其他写者正在写，该写者等待</strong></li>
</ul>
<blockquote>
<p>写者是和其他写者是互斥的，和读者也是互斥的。 所以读者写者问题本质上是一个互斥的问题。</p>
</blockquote>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/20.png" style="zoom:35%;"></p>
<p>第一类读者写者问题实际上是要解决的是多个读者可以同时读，因此不需要每个读者都去做P(w)或做V(w) 操作。</p>
<p>经过分析发现第一个读者 到来时如果没有其他的读者和写者，他可以去读。它在读之前首先要把临界区保护起来，所以第一个读者做P(w)。只要前面有读者在读，那么后续来的读者都可以去读。 当所有的读者都读完就会把临界区还回来，所以最后一个读者去做V(w)操作。 </p>
<p>在代码中的读者里引入一个计数器rc，它用来记录现在有几个读者。进来一个读者之后通过 <code>rc ＋ 1</code> 判断是不是第一个读者，如果<code>rc = 1</code>，表示是第一个读者，那就去做P(w)的工作。每个读者离开都要去 <code>rc- 1</code> ，当最后一个读者做完 <code>rc - 1</code>， rc就等于0了,最后一个读者去做V(w)操作。</p>
<p>因为多个读者都对rc进行相应的操作，所以rc就成为了一个新的临界资源。<code>rc = rc + 1</code> 判断 rc，或者 <code>rc = rc - 1</code> 判断 rc 都是一个临界区。 因此还要针对这样一个临界区再增加一个互斥的信号量，对rc这段代码进行保护。</p>
<h3 id="2-Linux提供的读写锁"><a href="#2-Linux提供的读写锁" class="headerlink" title="(2).Linux提供的读写锁"></a>(2).Linux提供的读写锁</h3><p>应用场景:</p>
<p>如果<strong>每个执行实体对临界区的访问或者是读或者是写共享变量</strong>，但是它们都不会既读又写时，读写锁是最好的选择。</p>
<p>实例:</p>
<p>Linux的IPX路由代码中使用了读-写锁，用 ipx_routes_lock的读-写锁保护IPX路由表的并发访问</p>
<blockquote>
<p>要通过查找路由表实现包转发的程序需要请求读锁；需要添加和删除路由表中入口的程序必须获取写锁(由于通过读路由表的情况比更新路由表的情况多得 多，使用读-写锁提高了性能)</p>
</blockquote>
<hr>
<h1 id="五-管程-MONITOR"><a href="#五-管程-MONITOR" class="headerlink" title="五.管程 MONITOR"></a>五.管程 MONITOR</h1><h2 id="1-管程的基本概念"><a href="#1-管程的基本概念" class="headerlink" title="1.管程的基本概念"></a>1.管程的基本概念</h2><h3 id="1-为什么引入管程"><a href="#1-为什么引入管程" class="headerlink" title="(1).为什么引入管程"></a>(1).为什么引入管程</h3><p>信号量机制具有一些缺点，比如<strong>用信号量及PV操作解决问题的时程序编写需要很高的技巧</strong>。 如果没有合理地安排PV操作的位置，就会导致一些出错的结果比如说出现死锁等问题。 所以有人提出一种新的同步机制就是管程。 它实际上是<strong>在程序设计语言中引入的一个成分</strong>，称之为高级同步机制。</p>
<h3 id="2-管程的定义"><a href="#2-管程的定义" class="headerlink" title="(2).管程的定义"></a>(2).管程的定义</h3><p>管程是一种<strong>特殊的模块</strong>，<strong>每个管程都有一个名字</strong>。<strong>管程主要是管理共享资源所对应的数据结构</strong>，所以管程在管理共享资源的同时也提供了在这个共享资源之上需要的各种各样的操作，也就是由一组操作的过程来组成。 </p>
<p>示例:</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/21.png" style="zoom:35%;"></p>
<p><strong>进程与管程的关系:</strong></p>
<p>作为进程，它只能<strong>通过调用管程给提供的各种过程来间接地来使用管程当中的数据结构</strong>。</p>
<h3 id="3-管程的要求"><a href="#3-管程的要求" class="headerlink" title="(3).管程的要求"></a>(3).管程的要求</h3><p>作为一种同步机制，管程要解决两个问题：</p>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul>
<li><strong>管程是互斥进入的。</strong></li>
<li>互斥是<strong>为了保证管程中数据结构的数据完整性</strong></li>
<li><strong>管程的互斥性是<font color="red">由编译器负责保证的</font></strong></li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><ul>
<li><p><strong>管程中设置<font color="red">条件变量及等待/唤醒操作</font>以解决同步问题</strong></p>
</li>
<li><p>作用<strong>可以让一个进程或线程在条件变量上等待(<font color="red">此时，应先释放管程的使用权</font>)，也可以通过发送信号将等待在条件变量上的进程或线程唤醒</strong></p>
</li>
</ul>
<h3 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="(4).遇到的问题"></a>(4).遇到的问题</h3><p>场景：</p>
<p>当一个进入管程的进程 执行等待操作时，它应当释放管程的互斥权。当后面进入管程的进程执行唤醒操作时(例如后进的P唤醒前面的Q)，管程中便存在两个同时处于活动状态的进程。</p>
<p>解决方法：</p>
<ul>
<li><strong>P等待Q执行</strong></li>
<li><strong>Q等待P继续执行</strong></li>
<li><strong>规定唤醒操作为管程中最后一个可执行 的操作</strong></li>
</ul>
<h2 id="2-HOARE管程"><a href="#2-HOARE管程" class="headerlink" title="2.HOARE管程"></a>2.HOARE管程</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/22.png" style="zoom:35%;"></p>
<ul>
<li>因为管程是互斥进入的，所以<strong>当一个进程试图进入 一个已被占用的管程时，应当在管程的入口处等待</strong><ul>
<li>为此，管程的入口处设置一个进程等待队列，称作<strong>入口等待队列</strong></li>
</ul>
</li>
<li>如果进程P唤醒进程Q，则P等待Q执行;如果进程Q执行中又唤醒进程R，则Q等待R执行;……，如此，在管程内部可能会出现多个等待进程<ul>
<li><strong>在管程内需要设置一个进程等待队列，称为紧急等待队列，紧急等待队列的优先级高于入口等待队列 的优先级</strong></li>
</ul>
</li>
</ul>
<h3 id="2-条件变量的实现"><a href="#2-条件变量的实现" class="headerlink" title="(2).条件变量的实现"></a>(2).条件变量的实现</h3><blockquote>
<p> 因为管程的互斥是由编译器保证的，是语言机制。 所以这里头只考虑怎么样解决同步问题，同步问题是通过条件变量和条件变量上实施的wait和signal这两个操作来完成的。</p>
</blockquote>
<p><strong>条件变量——在管程内部说明和使用的一种特殊类型的变量。</strong>对于条件变量，可以执行<strong>wait和signal操作</strong></p>
<p><strong>wait(c):</strong> </p>
<p><strong>如果紧急等待队列非空，</strong>则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入 c(条件变量) 链末尾。</p>
<p><strong>signal(c):</strong></p>
<p>如果 c 链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，<strong>执行此操作的进程进入紧急等待队列的末尾。</strong></p>
<h2 id="3-管程的应用"><a href="#3-管程的应用" class="headerlink" title="3.管程的应用"></a>3.管程的应用</h2><h3 id="1-管程的实现"><a href="#1-管程的实现" class="headerlink" title="(1).管程的实现"></a>(1).管程的实现</h3><p>管程实现的两个主要途径:</p>
<ul>
<li><p><strong>直接构造——效率高</strong> </p>
<blockquote>
<p>因为它是语言机制，所以可以在某个语言当中加入这样一个管程成分，然后去编写相应的编译器</p>
</blockquote>
</li>
<li><p><strong>间接构造——用某种已经实现的同步机制去构造</strong></p>
<blockquote>
<p>比如可以用信号量及 PV 操作来构造一个管程 </p>
</blockquote>
</li>
</ul>
<h3 id="2-用管程解决生产者消费者问题"><a href="#2-用管程解决生产者消费者问题" class="headerlink" title="(2).用管程解决生产者消费者问题"></a>(2).用管程解决生产者消费者问题</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/23.png" style="zoom:35%;"></p>
<h2 id="4-MESA管程"><a href="#4-MESA管程" class="headerlink" title="4.MESA管程"></a>4.MESA管程</h2><p>引入MESA的原因：</p>
<ul>
<li><p>Hoare管程的一个缺点：<strong>两次额外的进程切换</strong></p>
</li>
<li><p>解决方式：解决:</p>
<ul>
<li>把 <code>signal</code> 改成 <code>notify</code></li>
<li>notify：当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行</li>
</ul>
</li>
</ul>
<h3 id="1-使用NOTIFY要注意的问题"><a href="#1-使用NOTIFY要注意的问题" class="headerlink" title="(1).使用NOTIFY要注意的问题"></a>(1).使用NOTIFY要注意的问题</h3><ul>
<li><p><strong>notify的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行</strong></p>
</li>
<li><p>由于不能保证在它之前没有其他进程进入管程， 因而这个<strong>进程必须重新检查条件</strong></p>
<blockquote>
<p><strong>用while循环取代if语句</strong></p>
</blockquote>
</li>
<li><p><strong>导致对条件变量至少多一次额外的检测</strong>(但不再有额外的进程切换)，并且对等待进程在notify 之后何时运行没有任何限制</p>
</li>
</ul>
<h3 id="2-MEAS管程：生产者—消费者问题"><a href="#2-MEAS管程：生产者—消费者问题" class="headerlink" title="(2).MEAS管程：生产者—消费者问题"></a>(2).MEAS管程：生产者—消费者问题</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/24.png" style="zoom:40%;"></p>
<h3 id="3-改进NOTIFY"><a href="#3-改进NOTIFY" class="headerlink" title="(3).改进NOTIFY"></a>(3).改进NOTIFY</h3><ul>
<li><p>对notify的一个很有用的改进</p>
<ul>
<li>给每个条件原语关联一个监视计时器，<strong>不论是否被通知，一个等待时间超时的进程将被设为就绪态</strong></li>
<li>当该进程被调度执行时，会再次检查相关条件， 如果条件满足则继续执行</li>
</ul>
</li>
<li><p>超时可以防止如下情况的发生: </p>
<ul>
<li>当某些进程在产生相关条件的信号之前失败时，等待该条件的进程就会被无限制地推迟执行而处于饥饿状态</li>
</ul>
</li>
</ul>
<h3 id="4-引入BROADCAST"><a href="#4-引入BROADCAST" class="headerlink" title="(4).引入BROADCAST"></a>(4).引入BROADCAST</h3><p><strong>broadcast：使所有在该条件上等待的进程都被释放并进入就绪队列</strong></p>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>当一个进程不知道有多少进程将被激活时，这种方式是非常方便的</strong></li>
</ul>
<blockquote>
<p>例子:生产者/消费者问题中，假设insert和remove 函数都适用于可变长度的字符块，此时，如果一个 生产者往缓冲区中添加了一批字符，它不需要知道 每个正在等待的消费者准备消耗多少字符，而仅仅 执行一个broadcast，所有正在等待的进程都得到通 知并再次尝试运行</p>
</blockquote>
<ul>
<li><strong>当一个进程难以准确判定将激活哪个进程时，也可使用广播</strong></li>
</ul>
<h2 id="5-HOARE管程与MESA管程的比较"><a href="#5-HOARE管程与MESA管程的比较" class="headerlink" title="5.HOARE管程与MESA管程的比较"></a>5.HOARE管程与MESA管程的比较</h2><ul>
<li><p><strong>Mesa管程优于Hoare管程之处在于Mesa管程错误比较少</strong></p>
</li>
<li><p>在Mesa管程中，由于每个过程在收到信号后都重新检查管程变量，并且由于使用了while结构，一个进程不正确的broadcast广播或发信号notify，不会导致收到信号的程序出错</p>
<blockquote>
<p>收到信号的程序将检查相关的变量，如果期望的条件没有满足，它会重新继续等待</p>
</blockquote>
</li>
</ul>
<h2 id="6-管程小结"><a href="#6-管程小结" class="headerlink" title="6.管程小结"></a>6.管程小结</h2><p><strong>管程：</strong>抽象数据类型 有一个明确定义的操作集合，通过它且只有通过它才能操纵该数据类型的实例</p>
<p><strong>实现管程结构必须保证下面几点：</strong></p>
<ul>
<li>只能通过管程的某个过程才能访问资源; </li>
<li>管程是互斥的，某个时刻只能有一个进程或线程调用管程中的过程</li>
</ul>
<p><strong>条件变量:</strong>为提供进程与其他进程通信或同步而引入</p>
<blockquote>
<p>wait/signal 或 wait/notify 或 wait/broadcast</p>
</blockquote>
<hr>
<h1 id="六-PTHREAD中的同步机制"><a href="#六-PTHREAD中的同步机制" class="headerlink" title="六.PTHREAD中的同步机制"></a>六.PTHREAD中的同步机制</h1><p>Pthread解决互斥的问题：<strong>在Pthread 中使用一个互斥量，通过对互斥量提供相应的操作来保护临界区。</strong> </p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/25.png" style="zoom:35%;"></p>
<p>Pthread解决同步问题：<strong>在Pthread 中使用条件变量，以及在条件变量上的各种操作</strong> </p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/26.png" style="zoom:35%;"></p>
<h2 id="1-用PTHREAD解决生产者消费者问题"><a href="#1-用PTHREAD解决生产者消费者问题" class="headerlink" title="1.用PTHREAD解决生产者消费者问题"></a>1.用PTHREAD解决生产者消费者问题</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/27.png" style="zoom:30%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/28.png" style="zoom:40%;"></p>
<h2 id="2-讨论：PTHREAD-COND-WAIT"><a href="#2-讨论：PTHREAD-COND-WAIT" class="headerlink" title="2.讨论：PTHREAD_COND_WAIT"></a>2.讨论：PTHREAD_COND_WAIT</h2><p>pthread_cond_wait的执行分解为三个主要动作: </p>
<p><strong>1、解锁</strong></p>
<p><strong>2、等待</strong></p>
<blockquote>
<p>当收到一个解除等待的信号 (pthread_cond_signal或者 pthread_cond_broad_cast)之后， pthread_cond_wait马上需要做的动作是:</p>
</blockquote>
<p><strong>3、上锁</strong></p>
<h1 id="七-进程间通信机制"><a href="#七-进程间通信机制" class="headerlink" title="七.进程间通信机制"></a>七.进程间通信机制</h1><h2 id="1-为什么需要通信机制"><a href="#1-为什么需要通信机制" class="headerlink" title="1.为什么需要通信机制"></a>1.为什么需要通信机制</h2><ul>
<li><p><strong>信号量和管程只能传递很简单的信息，不能传递大量的信息</strong> </p>
<blockquote>
<p> 比如要把一个大的数组传送给另外一 进程，那么信号量和管程在这一方面是做不到的。 </p>
</blockquote>
</li>
<li><p><strong>管程不适合于用于多处理器的情况</strong> </p>
</li>
</ul>
<p>因此在传递大量信息的时候需要引入新的通信机制，这个通信机制就是进程间通信机制。</p>
<blockquote>
<p>非常典型的形式就是消息传递 ，实际上就是由send和receive提供这样的原语操作。当一个进程要把消息发送给另外一个进程时就去调用send； 当另外一个进程想接收消息时就去调用receive操作。</p>
</blockquote>
<p>使用情况：<strong>分布式系统、基于共享内存的多处理机系统、单处理机系统。<font color="red">可以解决进程间的同步 问题、通信问题</font></strong></p>
<h2 id="2-基本通信方式"><a href="#2-基本通信方式" class="headerlink" title="2.基本通信方式"></a>2.基本通信方式</h2><h3 id="1-消息传递"><a href="#1-消息传递" class="headerlink" title="(1).消息传递"></a>(1).消息传递</h3><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/29.png" style="zoom:30%;"></p>
<p><strong>发送消息：发送进程只是把消息准备好，调用send 操作，然后操作系统做相应的复制消息的内容，挂接的内容。</strong></p>
<p><strong>接收消息：接收进程接收消息时把请求提交给操作系统，操作系统完成把消息复制到接收进程空间的工作。</strong></p>
<p>所以操作系统要提供这样一个通信机制，来完成进程之间的信息传送。</p>
<h4 id="用PV操作实现SEND操作"><a href="#用PV操作实现SEND操作" class="headerlink" title="用PV操作实现SEND操作"></a>用PV操作实现SEND操作</h4><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/31.png" style="zoom:35%;"></p>
<h2 id="2-共享内存"><a href="#2-共享内存" class="headerlink" title="2.共享内存"></a>2.共享内存</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/32.png" style="zoom:35%;"></p>
<p>该通信模式需要解决两个问题：</p>
<p>第一个问题：需要在物理内存里建一个大家能够共享的一块内存空间。<strong>通过相应的映射能把这个物理内存空间映射到了两个进程相应的地址空间里。</strong>  </p>
<p>第二个问题：其实就是读者写者问题，因为共享内存不能同时去写，可以同时去读。 所以可以利用控制读写者问题的这个方法来解决互斥问题。</p>
<h2 id="3-管道通信方式-PIPE"><a href="#3-管道通信方式-PIPE" class="headerlink" title="3.管道通信方式 PIPE"></a>3.管道通信方式 PIPE</h2><p>利用一个缓冲传输介质——内存或文件连接两个相互通信的进程。</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/33.png" style="zoom:35%;"></p>
<ul>
<li><strong>用字符流方式写入读出</strong></li>
<li><strong>先进先出顺序</strong></li>
<li><strong>管道通信机制必须提供的协调能力</strong><ul>
<li><strong>互斥、同步、判断对方进程是否存在</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="八-典型操作系统中的IPC机制"><a href="#八-典型操作系统中的IPC机制" class="headerlink" title="八.典型操作系统中的IPC机制"></a>八.典型操作系统中的IPC机制</h1><h2 id="1-进程同步-通信实例"><a href="#1-进程同步-通信实例" class="headerlink" title="1.进程同步/通信实例"></a>1.进程同步/通信实例</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/34.png" style="zoom:33%;"></p>
<h2 id="2-LINUX的进程通信机制"><a href="#2-LINUX的进程通信机制" class="headerlink" title="2.LINUX的进程通信机制"></a>2.LINUX的进程通信机制</h2><p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/35.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/36.png" style="zoom:33%;"></p>
<p>Linux提供了很多种工具，根据需要挑选合适的一种。</p>
<h2 id="3-原子操作"><a href="#3-原子操作" class="headerlink" title="3.原子操作"></a>3.原子操作</h2><p>原子操作是不可分割，在执行完之前不会被其他任务或事件中断。它常用于实现资源的引用计数。</p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/37.png" style="zoom:33%;"></p>
<p>例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">atomic_t</span> v = atomic_init(<span class="number">0</span>);</span><br><span class="line">atomic_set(&amp;v, <span class="number">4</span>); </span><br><span class="line">atomic_add(<span class="number">2</span>, &amp;v); </span><br><span class="line">atomic_inc(&amp;v);</span><br><span class="line">printk(“%d\n”, atomic_read(&amp;v);</span><br><span class="line"><span class="keyword">int</span> atomic_dec_and_test(<span class="keyword">atomic_t</span> *v)</span><br></pre></td></tr></table></figure></div>
<h2 id="4-屏障"><a href="#4-屏障" class="headerlink" title="4.屏障"></a>4.屏障</h2><p><strong>屏障主要是用于对一组线程进行协调的。</strong></p>
<p>应用场景：</p>
<p><strong>一组线程协同完成一项任务，需要所有线程都到达一个汇合点后再一起向前推进。</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/12/同步机制/38.png" style="zoom:33%;"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>同步机制</tag>
      </tags>
  </entry>
  <entry>
    <title>处理器调度</title>
    <url>/2020/08/11/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-CPU调度的相关概念"><a href="#一-CPU调度的相关概念" class="headerlink" title="一.CPU调度的相关概念"></a>一.CPU调度的相关概念</h1><h2 id="1-CPU调度"><a href="#1-CPU调度" class="headerlink" title="1.CPU调度"></a>1.CPU调度</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1).定义"></a>(1).定义</h3><p><strong>CPU调度的任务是控制、 协调多个进程对CPU的竞争。</strong><font color="red">即按照一定的调度算法，从就绪队列中选择一个进程，然后把CPU的控制权交给被选中的进程。如果就绪队列没有其它的进程，那么系统会安排一个空闲进程(idle 进程)上 CPU 运行。</font></p>
<h3 id="2-系统场景"><a href="#2-系统场景" class="headerlink" title="(2).系统场景"></a>(2).系统场景</h3><p>CPU调度所面临的场景：</p>
<ul>
<li>系统有N 个进程，它们就绪等待上 CPU 运行</li>
<li>而系统有M个 CPU，M $\geq$ 1 </li>
<li>操作系统调度模块需要要决策给哪个进程分配哪一个CPU</li>
</ul>
<h2 id="2-CPU调度要解决的三个问题"><a href="#2-CPU调度要解决的三个问题" class="headerlink" title="2.CPU调度要解决的三个问题"></a>2.CPU调度要解决的三个问题</h2><ul>
<li><p><strong>WHAT：按什么原则选择下一个要执行的进程</strong> </p>
<p>— 调度算法</p>
</li>
<li><p><strong>WHEN：何时选择</strong> </p>
<p>— 调度时机</p>
</li>
<li><p><strong>HOW：如何让被选中的进程上CPU运行</strong></p>
<p>— 调度过程(主要内容是：进程的上下文切换)</p>
</li>
</ul>
<h2 id="3-CPU调度的时机"><a href="#3-CPU调度的时机" class="headerlink" title="3.CPU调度的时机"></a>3.CPU调度的时机</h2><blockquote>
<p> 系统运行时，会发生很多的事件。比如说，一些进程的操作：I/O 中断，时间中断。 这些事件发生以后系统要做相应的处理。 这是第二讲的主要内容。 </p>
</blockquote>
<p><strong>事件发生 → 当前运行的进程暂停运行 → 硬件机制响应 后 → 进入操作系统，处理相应的事件 → 结束处理后:</strong> </p>
<p>事件处理完后某些进程的状态发生了变化，也可能创建出了一些新的进程。这就导致了就绪队列的改变，而这就需要进程调度。<strong>按照事先预定的算法从就绪队列中重新选择一个进程 ，这就是调度的时机。 <font color="red">即就绪队列的改变引发了重新调度</font>。</strong> </p>
<p>进程调度的时机有4个:</p>
<ul>
<li>进程正常终止 或 由于某种错误而终止 </li>
<li>新进程创建 或 一个等待进程变成就绪 </li>
<li>当一个进程从运行态进入阻塞态</li>
<li>当一个进程从运行态变为就绪态</li>
</ul>
<blockquote>
<p>总而言之什么时候重新调度？</p>
<p>往往是内核对中断,陷入,系统调用等处理之后，返回到用户态，这个时候要重新调度。这就是CPU 调度的时机。</p>
</blockquote>
<h2 id="4-CPU调度的过程—进程切换"><a href="#4-CPU调度的过程—进程切换" class="headerlink" title="4.CPU调度的过程—进程切换"></a>4.CPU调度的过程—进程切换</h2><h3 id="1-进程切换的概念"><a href="#1-进程切换的概念" class="headerlink" title="(1).进程切换的概念"></a>(1).进程切换的概念</h3><blockquote>
<p>当有一个新的进程被选中之后 ，这个进程可以是刚刚被暂停执行的进程，也可以是一个新的进程。 如果是一个新的进程，那就要发生一个进程切换。</p>
</blockquote>
<p><strong>进程切换就指的是一个进程让出CPU，另外一个进程占用CPU的一个过程。</strong></p>
<p>进程切换主要包括两部分工作：</p>
<ul>
<li><p>先切换全局页目录，以此来加载一个新的地址空间 </p>
<blockquote>
<p>因为新的进程上CPU ，那么它要用自己的地址空间 </p>
</blockquote>
</li>
<li><p>是切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如 CPU相关寄存器</p>
</li>
</ul>
<p>因此，进程切换实际上包括了<strong>对原有进程的各种状态的保存</strong>，以及<strong>对新的进程的状态的恢复</strong>，这样一个过程。</p>
<h3 id="2-上下文切换的具体步骤"><a href="#2-上下文切换的具体步骤" class="headerlink" title="(2).上下文切换的具体步骤"></a>(2).上下文切换的具体步骤</h3><blockquote>
<p>例子：如果进程A下CPU，进程B上CPU ，那么进程切换主要做的工作呢？</p>
</blockquote>
<ol>
<li><p><strong>保存进程A的上下文环境</strong> (程序计数器、程序状态字、其他寄存器……)</p>
</li>
<li><p><strong>用新状态和其他相关信息更新进程A的PCB</strong></p>
</li>
<li><p><strong>把进程A移至合适的队列</strong> (就绪、阻塞……)</p>
</li>
<li><p><strong>将进程B的状态设置为运行态</strong></p>
</li>
<li><p><strong>从进程B的PCB中恢复上下文</strong>(程序计数器、程 序状态字、其他寄存器……)</p>
</li>
</ol>
<p>做完了这些事情，进程B就上CPU运行， 而进程A的所有信息保存好之后，以后它还可以继续上CPU接着执行。 </p>
<h3 id="3-上下文切换的开销"><a href="#3-上下文切换的开销" class="headerlink" title="(3).上下文切换的开销"></a>(3).上下文切换的开销</h3><p>上下文切换的开销包括两部分： </p>
<ul>
<li><p><strong>直接开销：</strong>内核完成上下文切换所花费CPU的时间 </p>
<blockquote>
<p>这些时间用于：</p>
<ul>
<li>保存和恢复寄存器</li>
<li>用于切换地址空间 (切换地址空间的指令比较昂贵) </li>
</ul>
</blockquote>
</li>
<li><p><strong>间接开销</strong></p>
<blockquote>
<p>高速缓存(Cache)、缓冲区缓存(BufferCache) 和 TLB快表(Translation Look-aside Buffer)失效</p>
<p>高速缓存中存放了刚才执行的这些进程中的一些指令和数据， TLB快表中存放了进程的一些页表表项。当新的进程上CPU之后，原来的这些内容都都失效了。还要把新的进程所需要的指令数据，送入高速缓存或者是把新的进程的页表表项送入TLB快表里。这又需要花一些时间，这些都是间接开销。 </p>
</blockquote>
</li>
</ul>
<h2 id="5-CPU调度算法的设计"><a href="#5-CPU调度算法的设计" class="headerlink" title="5.CPU调度算法的设计"></a>5.CPU调度算法的设计</h2><p>从操作系统发展的角度来看调度算法的一些演变：</p>
<p>批处理系统 → 多道程序设计系统 → 批处理与分时的混合系统 → 个人计算机 → 网络服务器</p>
<blockquote>
<ul>
<li>早期的批处理对调度算法的要求不高，也比较简单，那么因为它是一个程序执行完了以后接着执行下一个程序 </li>
<li>有了多道程序设计系统之后，多个程序都要想进内存，去上CPU，此时调度算法就要去选择让哪些进程早一点上CPU了 </li>
<li>到了批处理与分时系统混合系统中，调度算法既要照顾到前台的进程也要照顾到那些后台的进程，需要合理地安排调度的顺序，让不同的进程都能有机会上CPU执行 </li>
<li>个人计算机刚开始时调度算法非常简单，后来慢慢慢慢演化到现在桌面操作系统里头调度算法变得非常复杂 </li>
<li>网络服务器由于有多个客户端同时向它提出服务请求，所以要在调度算法上下一些功夫 </li>
</ul>
</blockquote>
<p>从用户角度和系统角度对调度算法的要求不一样，下图描述了性能方面的不同要求： </p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/1.png" style="zoom:35%;"></p>
<blockquote>
<p>从上图可以看到，用户的角度和系统的角度对于调度算法有不同的要求。 而这些要求有时候是相互矛盾的。 因此在设计调度算法的时候是要在各种因素中折中权衡。</p>
</blockquote>
<h2 id="6-调度算法衡量指标"><a href="#6-调度算法衡量指标" class="headerlink" title="6.调度算法衡量指标"></a>6.调度算法衡量指标</h2><ul>
<li><p><strong>吞吐量 Throughput</strong> </p>
<blockquote>
<p>每单位时间完成的进程数目</p>
</blockquote>
</li>
<li><p><strong>周转时间TT (Turnaround Time)</strong></p>
<blockquote>
<p>每个进程从提出请求到运行完成的时间</p>
</blockquote>
</li>
<li><p><strong>响应时间RT (Response Time)</strong> </p>
<blockquote>
<p>从提出请求到第一次回应的时间</p>
</blockquote>
</li>
<li><p><strong>其他</strong></p>
<ul>
<li><p><strong>CPU 利用率 (CPU Utilization)</strong></p>
<blockquote>
<p>CPU做有效工作的时间比例</p>
</blockquote>
</li>
<li><p><strong>等待时间 (Waitingtime)</strong></p>
<blockquote>
<p>每个进程在就绪队列 (ready queue) 中等待的时间</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-设计调度算法时需要考虑的问题"><a href="#二-设计调度算法时需要考虑的问题" class="headerlink" title="二.设计调度算法时需要考虑的问题"></a>二.设计调度算法时需要考虑的问题</h1><p>设计调度算法时要考虑以下几个问题: </p>
<ul>
<li><p>进程控制块PCB中</p>
<blockquote>
<p>需要记录哪些与CPU调度有关的信息</p>
</blockquote>
</li>
<li><p>进程优先级及就绪队列的组织 </p>
</li>
<li>抢占式调度与非抢占式调度 </li>
<li>I/O密集型与CPU密集型进程 </li>
<li>时间片</li>
</ul>
<h2 id="1-进程优先级-数"><a href="#1-进程优先级-数" class="headerlink" title="1.进程优先级(数)"></a>1.进程优先级(数)</h2><p>优先级和优先数是两个不同的概念。</p>
<p><strong>优先级是表现进程的重要性和紧迫性</strong>。 优先数是一个<strong>数值，它反映了某一个优先级</strong>。 </p>
<blockquote>
<p>有些系统像 UNIX 优先数小的优先级高，但是不能完全根据数的大小来决定优先级的高低。</p>
</blockquote>
<p>根据优先级是否能改变分为静态优先级和动态优先级。</p>
<p>静态优先指在进程创建时，<strong>指定优先级之后在进程运行的过程中，这个优先级不再发生改变。</strong> </p>
<p>动态优先级是在<strong>进程运行过程中，优先级的级别还会不断地调整。</strong> </p>
<blockquote>
<p>有的时候需要动态优先级，比如当一个进程在就绪队列当中等待的时间很长的时候，要提升它的优先级，让它尽快有机会得到CPU去运行。</p>
</blockquote>
<h2 id="2-进程就绪队列组织"><a href="#2-进程就绪队列组织" class="headerlink" title="2.进程就绪队列组织"></a>2.进程就绪队列组织</h2><p><strong>按照优先级来排队 ：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/2.png" style="zoom:35%;"></p>
<p>可以按照优先级来组织就绪队列。当创建一个新的进程的时候，根据它的优先级排不同的就绪队列，在这里设定n个就绪队列优先级，不同的优先级进入不同的就绪队列。 就绪队列 1 的优先级是最高的，当调度程序选择进程的时候，首先应该从高优先级的队列来选择进程 。如果高优先级队列没有进程了，再从次高就绪队列来选择进程。</p>
<p><strong>另一种排队方式：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/3.png" style="zoom:35%;"></p>
<p>所有的进程第一次创建之后都进到第一级就绪队列，随着进程的运行可能会降低某些进程的优先级。比如当一个进程分配给它的时间片用完了，那么它就会降一级，降到第二级就绪队列。 如果它经常地用完时间片，慢慢的这个进程就会降低到最后一级就绪队列。进程调度首先在第一级队列里选，说明第一级就绪队列的优先级比较高。如果这个队列是空的，那么调度就会从其他的就绪队列里头选择进程。如果进程已经进到了最后一级队列，那么它的优先级就越来越低，它被调度上 CPU 的机会就会变得很小。</p>
<h2 id="3-占用CPU的方式—抢占与非抢占"><a href="#3-占用CPU的方式—抢占与非抢占" class="headerlink" title="3.占用CPU的方式—抢占与非抢占"></a>3.占用CPU的方式—抢占与非抢占</h2><p>指占用CPU的方式:</p>
<ul>
<li><strong>可抢占式Preemptive(可剥夺式)</strong>：</li>
</ul>
<p>当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用。</p>
<ul>
<li><strong>不可抢占式Non-preemptive(不可剥夺式)</strong>：</li>
</ul>
<p>某一进程被调度运行后，除非由于它自身的原因不能运行，否则一直运行下去</p>
<h2 id="4-I-O密集型与CPU密集型进程"><a href="#4-I-O密集型与CPU密集型进程" class="headerlink" title="4.I/O密集型与CPU密集型进程"></a>4.I/O密集型与CPU密集型进程</h2><p>按进程执行过程中的行为划分:</p>
<ul>
<li><p><strong>I/O密集型或I/O型(I/O-bound)</strong></p>
<blockquote>
<p>频繁的进行I/O，通常会花费很多时间等待I/O操作的完成</p>
</blockquote>
</li>
<li><p><strong>CPU密集型或CPU型或计算密集型(CPU-bound)</strong> </p>
<blockquote>
<p>需要大量的CPU时间进行计算</p>
</blockquote>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/4.png" style="zoom:40%;"></p>
<blockquote>
<p>在设计调度算法时，通常会对I/O型的进程会有一些友好，希望更多的I/O型进程早一点上CPU运行。</p>
<p>因为这些进程上CPU 之后只用了很短的一下，CPU时间就让出CPU，因为它要去做其它的输入输出操作。因此对于一般的调度程序，都会对I/O型进程更偏好一些。 </p>
</blockquote>
<h2 id="5-时间片"><a href="#5-时间片" class="headerlink" title="5.时间片"></a>5.时间片</h2><p>时间片指的是一个时间段，<strong>指分配给调度上CPU的进程，允许这个进程在CPU上执行多长时间，它是一个时间的长度。</strong></p>
<p>那么如何选择时间片呢？ 应该考虑很多的因素： </p>
<ul>
<li><p><strong>进程切换的开销有多大</strong></p>
</li>
<li><p><strong>进程对响应时间的要求</strong> </p>
</li>
<li><p><strong>系统当中有多少进程处于就绪</strong> </p>
</li>
<li><p><strong>CPU的能力有多大</strong></p>
</li>
<li><p><strong>进程的行为</strong>(不同进程可能区别对待)</p>
<p>因此在设计时间片大小的时候要考虑到这些因素。 具体分配时间片的方式会在时间片轮转算法时进行介绍。</p>
</li>
</ul>
<hr>
<h1 id="三-批处理系统中采用的调度算法"><a href="#三-批处理系统中采用的调度算法" class="headerlink" title="三.批处理系统中采用的调度算法"></a>三.批处理系统中采用的调度算法</h1><p>介绍批处理系统中的常用的调度算法：</p>
<ul>
<li><strong>先来先服务 (FCFS-First Come First Serve)</strong></li>
<li><strong>最短作业优先 (SJF-Shortest Job First) </strong></li>
<li><strong>最短剩余时间优先 (SRTN-Shortest Remaining Time Next) </strong> </li>
<li><strong>最高相应比优先 (HRRN-Highest Response Ratio Next)</strong></li>
</ul>
<blockquote>
<p>在批处理操作系统中对于算法的要求往往是看它的带来的 <strong>吞吐量大小，周转时间，CPU 利用率</strong>，<strong>公平和平衡</strong> 这几个因素。 </p>
</blockquote>
<h2 id="1-先来先服务FCFS"><a href="#1-先来先服务FCFS" class="headerlink" title="1.先来先服务FCFS"></a>1.先来先服务FCFS</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1).概念"></a>(1).概念</h3><p>先来先服务调度算法也称为先进先出。指的是<font color="red"><strong>按照进程就绪的先后顺序来使用 CPU。</strong></font>先进先出调用算法是一个<strong>非抢占式</strong>的调度算法。 </p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>公平</strong> (谁先就绪谁先上CPU) </li>
<li><strong>实现简单</strong> (维护一个队列就可以了) </li>
</ul>
<blockquote>
<p>选择进程时从队首选择， 新就绪的进程排在队尾。 </p>
</blockquote>
<p><strong>缺点:</strong> </p>
<ul>
<li><strong>长进程后面的短进程需要等很长时间，不利于用户体验</strong></li>
</ul>
<blockquote>
<p>如果有一个短的进程排在了一个长时间运行进程的后面， 它需要等待的时间比较长， 这样使得用户体验不够友好。</p>
</blockquote>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2).举例"></a>(2).举例</h3><p>假设有三个进程，按照P1、P2、P3就绪。 P1进程需要运行24秒，P2和P3分别需要3秒计算。 </p>
<p>采用先来先服务的调度算法调度：</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/5.png" style="zoom:34%;"></p>
<p>同样还是这个例子， 改变调度的顺序：</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/6.png" style="zoom:34%;"></p>
<blockquote>
<p>可以看到平均周转时间降低到了13秒。 </p>
</blockquote>
<p>所以可以看到改变调度的顺序，也就是<strong>调度算法的改变会改善平均周转时间， 进而可能改善了响应时间这些指标。</strong> </p>
<h2 id="2-短作业优先SJF"><a href="#2-短作业优先SJF" class="headerlink" title="2.短作业优先SJF"></a>2.短作业优先SJF</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="(1).概念"></a>(1).概念</h3><p><strong><font color="red">短作业优先</font></strong>指的是具有<strong>最短完成时间的进程优先执行</strong>。 </p>
<ul>
<li><strong>非抢占式</strong></li>
</ul>
<p>如果短作业优先调度算法再改进一下： 加抢占模式，变成了抢占式的版本。这就是<font color="red"><strong>最短剩余时间优先调度算法</strong></font>。 </p>
<ul>
<li><strong>抢占式</strong></li>
</ul>
<p>所谓最短剩余时间就是当 <strong>一个新就绪的进程</strong> 比 <strong>正在当前运行的进程它的 剩余的运行时间短</strong>的时候， <strong>系统就会去抢占当前的进程，然后把CPU交给这个运行时间更短的进程</strong>。 </p>
<blockquote>
<p>因为在一个短作业运行的过程中，可能有一个新的进程创建出来，或者一个进程从等待变成就绪，那么它剩余的时间比当前正在运行的这个进程剩余的这个运行时间还短， 就要抢占了。</p>
</blockquote>
<h3 id="2-举例-1"><a href="#2-举例-1" class="headerlink" title="(2).举例"></a>(2).举例</h3><p>有四个进程到达时刻不是同时到达的，有不同的时刻：</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/7.png" style="zoom:33%;"></p>
<h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="(3).优缺点"></a>(3).优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>源源不断的短任务到来，可能使长的任务长时间得不到运行 → <strong>产生 “饥饿”现象 (starvation)</strong></li>
</ul>
<h2 id="3-最高相应比优先-HRRN"><a href="#3-最高相应比优先-HRRN" class="headerlink" title="3.最高相应比优先 HRRN"></a>3.最高相应比优先 HRRN</h2><blockquote>
<p> 既有先来先服务的优点，又有短作业优点,，这是操作系统当中的一个常用的手段——<strong>折衷权衡。</strong> 这种调度算法其中之一就是<strong>最高响应比优先</strong>。 </p>
</blockquote>
<p>基本思想是这样的： </p>
<p><strong>调度时，首先计算每个进程的响应比R；之后，总是选择R最高的进程执行。</strong></p>
<p>其中一种方案：</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/8.png" style="zoom:35%;"> </p>
<blockquote>
<p>很明显地看到，如果处理时间短，也就是短作业，那么分母小，整个的值就大，因此响应比就大。 </p>
<p>如果很早就绪了，在就绪队列中等的时间非常长，那等待时间就变得越来越大， 最后响应比变得非常大，被调度上 CPU。 </p>
</blockquote>
<hr>
<h1 id="四-交互式系统的调度算法"><a href="#四-交互式系统的调度算法" class="headerlink" title="四.交互式系统的调度算法"></a>四.交互式系统的调度算法</h1><p>介绍交互式系统中所采用的一些调度算法：</p>
<ul>
<li><strong>轮转调度 (RR-Round Robin)</strong></li>
<li><strong>最高优先级调度 (HPF—Highest Priority First)</strong></li>
<li><strong>多级反馈队列 (Multiple feedback queue)</strong></li>
<li><strong>最短进程优先 (Shortest Process Next)</strong></li>
</ul>
<p>追求的指标主要是<strong>响应时间，公平，资源的平衡使用。</strong>最短进程优先调度算法呢短作业优先调度算法差不多，就不再介绍。</p>
<h2 id="1-时间片轮转算法"><a href="#1-时间片轮转算法" class="headerlink" title="1.时间片轮转算法"></a>1.时间片轮转算法</h2><h3 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="(1).概念"></a>(1).概念</h3><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/9.png" style="zoom:35%;"></p>
<p>左图看到当前正在运行的是B进程，排在它后面的是F进程。当B进程用完它的时间片之后就回到队列的末位，调度就会选择下一个进程，所以右图当前运行进程F上CPU。这就是一个时间片轮转，然后F运行完它的时间片后就继续去排队。队列里面的每一个进程都有机会轮流上CPU。</p>
<p><strong>目标：</strong></p>
<ul>
<li><strong>改善短作业(短任务)的平均响应时间。</strong></li>
</ul>
<p><strong>具体做法：</strong></p>
<ul>
<li><p><strong>周期性地切换</strong> </p>
</li>
<li><p><strong>每个进程分配一个时间片</strong></p>
</li>
<li><strong>通过了时钟中断引发轮换</strong></li>
</ul>
<p>以此来达到改善短作业的平均响应时间的目标。 </p>
<h3 id="2-如何选择合适的时间片"><a href="#2-如何选择合适的时间片" class="headerlink" title="(2).如何选择合适的时间片"></a>(2).如何选择合适的时间片</h3><h4 id="如果选择的时间片太长："><a href="#如果选择的时间片太长：" class="headerlink" title="如果选择的时间片太长："></a><strong>如果选择的时间片太长：</strong></h4><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/10.png" style="zoom:40%;"></p>
<p>上图可以看到这个进程开始运行后，给它一个时间片，在没有用完时间片的前提下就已经完成了一个响应。<strong>如果系统中绝大部分进程都不到一个时间片就可以完成响应的话，那么时间片轮转算法实际上已经退化成了一个先来先服务的这种算法。</strong>另外如果时间片过长会延长某些进程的响应时间。</p>
<h4 id="如果选择的时间片过短："><a href="#如果选择的时间片过短：" class="headerlink" title="如果选择的时间片过短："></a><strong>如果选择的时间片过短：</strong></h4><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/11.png" style="zoom:35%;"></p>
<p>如果时间片太短，响应时间也会变长，<strong>频繁地去切换，那切换这个行为本身会带来开销。</strong>前面已经讲过上下文切换是有开销的，所以切换也就浪费了CPU的时间。</p>
<h3 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="(3).优缺点"></a>(3).优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p><strong>公平</strong> (进程轮流上CPU)</p>
</li>
<li><p><strong>有利于交互式计算，响应时间快</strong></p>
</li>
<li><p><strong>对于不同大小的进程是有利的</strong></p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p><strong>由于进程切换，时间片轮转算法要花费较高的开销</strong> (得让切换所带来的开销对于时间片来说能做到忽略不计)</p>
</li>
<li><p><strong>对于大小相同的进程是不利的</strong></p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/12.png" style="zoom:30%;"></p>
<h3 id="4-虚拟轮转法-VIRTUAL-RR"><a href="#4-虚拟轮转法-VIRTUAL-RR" class="headerlink" title="(4).虚拟轮转法 VIRTUAL RR"></a>(4).虚拟轮转法 VIRTUAL RR</h3><p>时间片轮转算法往往不区分I/O型进程与CPU型进程。这样会给I/O型进程带来一定的不公平。</p>
<blockquote>
<p>因为当一个CPU型进程被调度上CPU之后，用完它的时间片就会去重新排队，下一次再调度上CPU又用会完一个完整时间片。而I/O型进程被调度上CPU之后，运行完它的时间片，可能运行的很短就完成了它的任务，然后就去等待I/O，进入等待队列。一旦等待的结果到来，又变成一个就绪再次上 CPU，它又没有用完分配给它的时间片就结束了任务。所以CPU型的进程总是用完给它的时间片。 所以它占用了更多的 CPU 时间而I/O型进程总是用不完它的时间片，所以这个调度算法对它有些不公平。</p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/13.png" style="zoom:33%;"></p>
<p>上图是设计的虚拟轮转法： </p>
<p>当一个I/O型进程让出 CPU进到等待队列，从等待队列又重新回到就绪状态的时候。不去进入原来的就绪队列，会单独为它设置一个队列，<strong>叫做辅助队列</strong>。也就是所有I/O型的进程从等待变成就绪的时会进到这个队列。调度算法在选择进程的时候首先从这个辅助队列里去选择I/O 型进程。I/O 型进程上CPU之后，又很快地放弃了CPU进入等待直到辅助队列为空。实践表明这个方案改善了这个对I/O型进程的一种不公平性。</p>
<h2 id="2-最高优先级调度算法"><a href="#2-最高优先级调度算法" class="headerlink" title="2.最高优先级调度算法"></a>2.最高优先级调度算法</h2><h3 id="1-概念-3"><a href="#1-概念-3" class="headerlink" title="(1).概念"></a>(1).概念</h3><p>最高优先级调度算法思想比较简单，总是选择优先级最高去执行。</p>
<p>通常情况下：</p>
<ul>
<li>系统进程优先级 <font color="blue">高于</font> 用户进程 </li>
<li>前台进程优先级 <font color="blue">高于</font> 后台进程</li>
<li>操作系统更偏好 I/O型进程</li>
</ul>
<p>优先级可以是静态不变的，也可以动态调整。优先数可以决定优先级。就绪队列可以按照优先级组织</p>
<p><strong>特点：</strong></p>
<ul>
<li><strong>实现简单</strong></li>
<li><strong>不公平</strong> (出现饥饿现象)</li>
</ul>
<h3 id="2-优先级反转问题"><a href="#2-优先级反转问题" class="headerlink" title="(2).优先级反转问题"></a>(2).优先级反转问题</h3><p><strong>如果是基于优先级的抢占式调度算法，就会出现一个优先级反转问题。</strong></p>
<blockquote>
<p>优先级反转又称:优先级反置、翻转、倒挂</p>
</blockquote>
<p><strong>现象：</strong></p>
<p>一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行。</p>
<p>例子:</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/14.png" style="zoom:33%;"></p>
<p><strong>影响:</strong></p>
<ul>
<li><strong>系统错误</strong></li>
<li><strong>高优先级进程停滞不前，导致系统性能降低</strong></li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><p><strong>设置优先级上限</strong> </p>
<blockquote>
<p>凡是进入临界区的进程优先级都是最高的。 不在临界区的进程优先级都会比这个进入临界区的这进程优先级要低。这样的话就可以执行完成，然后把临界区还回去。</p>
</blockquote>
</li>
<li><p><strong>优先级继承</strong></p>
<blockquote>
<p>如果一个低优先级的进程阻碍了一个高优先级进程执行，它可以<strong>临时地继承这个高优先级的这个进程的优先级，</strong>一下子把自己优先级继承到这个高优先级的这个程度。那么就可以去运行，然后把临界区还回去。 </p>
</blockquote>
</li>
<li><p><strong>使用中断禁止</strong></p>
<blockquote>
<p> 凡是进入临界区的进程，那么就不再响应中断的。 直到出临界区才响应中断，这样就保护了这个进程，让它继续去执行。</p>
</blockquote>
</li>
</ul>
<h2 id="3-多级反馈队列调度算法"><a href="#3-多级反馈队列调度算法" class="headerlink" title="3.多级反馈队列调度算法"></a>3.多级反馈队列调度算法</h2><blockquote>
<p>多级反馈队列调度算法是UNIX 的一个分支，是BSD5.3版所采用的调度算法。它是在前面各种调度算法的基础之上提出的一个<strong>综合的调度算法</strong>，是在考虑了各种因素之后进行折中权衡的一个结果。</p>
</blockquote>
<p>多级反馈队列调度算法的基本思想：</p>
<ol>
<li><p><strong>设置多个就绪队列，第一级队列优先级最高</strong></p>
</li>
<li><p><strong>给不同就绪队列中的进程分配长度不同的时间片，第一级队列优先级最高但时间片最小;随着队列优先级别的降低，时间片增大</strong></p>
</li>
<li><p><strong>在进行调度时，先从优先级高的进行。当第一级队列为空时，在第二级队列调度，以此类推</strong></p>
</li>
<li><p><strong>各级队列按照<font color="red">时间片轮转</font>方式进行调度</strong></p>
</li>
<li><p><strong>当一个新创建进程就绪后，进入第一级队列</strong></p>
</li>
<li><p><strong>进程用完时间片而放弃CPU，进入下一级就绪队列</strong></p>
</li>
<li><p><strong>由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列</strong></p>
<blockquote>
<p>可以根据不同的情况来设计不同的方案以体现系统对这一类进程的偏好程度。</p>
<p>比如说进程是回到原来一级就绪队列的队首还是队尾？如果回到队首，说明系统对这类进程更加友好 </p>
<p>另外当进程再度被调度上 CPU 之后是让它运行完剩余的时间片还是重新给它分配一个完整的时间片让它去运行？ 也体现了系统对这类进程的偏好程度。</p>
</blockquote>
</li>
</ol>
<p>以上为<strong>非抢占式</strong>的。</p>
<p><strong>若允许抢占：</strong></p>
<p>当有一个更高优先级的进程就绪的时候可以抢占正在运行进程的CPU，那么被抢占的进程会回到原来一级就绪队列的末尾。</p>
<blockquote>
<p>当然也可以有不同的设计方案比如说回到原来一级就绪队列的队首。 </p>
</blockquote>
<p>当这个进程再度被调度上CPU时可以运行完它刚才剩余的时间片，也可以重新给它一个完整的新的时间片让它运行。因此又派生出不同的设计方案 。</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/15.png" style="zoom:40%;"></p>
<p>上图反映了一个进程在队列里头的一些迁移活动。</p>
<p>当创建一个新的进程时，所有的进程都进入第一级队列。</p>
<p><strong>如果是 I/O 型的进程，</strong>那么它可能被调度上 CPU 之后很短时间就去等待I/O，<font color="red">当它从等待队列又回到就绪队列的时候，<strong>让它回到原来一级就绪队列，所以优先级没有降低，被调度上 CPU 的机会很多。</strong> </font></p>
<p><strong>但是对于CPU 型的进程</strong>，它被调度上CPU用完了一个时间片之后就会回到下一级队列。<font color="red">如果<strong>每次都用完了它的时间片，它就会降级。</strong>可能一个CPU 型的进程就慢慢降到了优先级最低的这个队列里。</font></p>
<p>因此可以看到这个调度算法可以慢慢地区分出来哪些进程是CPU型进程，哪些进程是I/O型进程，很显然多级反馈队列调度算法对I/O型进程更偏好一点，对CPU型进程呢不太有利。但是它也做了一些弥补，比如说优先级高的队列时间片短，而优先级低的队列时间片会很大，所以当低优先级的CPU型进程被调度上CPU之后，它可以运行更长的时间。这里也是一种平衡的结果。</p>
<h2 id="4-各种调度算法的比较"><a href="#4-各种调度算法的比较" class="headerlink" title="4.各种调度算法的比较"></a>4.各种调度算法的比较</h2><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/16.png" style="zoom:40%;"></p>
<h2 id="5-多处理器调度算法需要考虑到的问题"><a href="#5-多处理器调度算法需要考虑到的问题" class="headerlink" title="5.多处理器调度算法需要考虑到的问题"></a>5.多处理器调度算法需要考虑到的问题</h2><ul>
<li><p><strong>不仅要决定选择哪一个进程执行</strong> </p>
<blockquote>
<p>还需要<font color="red">决定在哪一个CPU上执行</font></p>
</blockquote>
</li>
<li><p><strong>要考虑进程在多个CPU之间迁移时的开销</strong></p>
<ul>
<li><p><strong>高速缓存失效、TLB失效</strong></p>
</li>
<li><p><strong>尽可能使进程总是在同一个CPU上执行</strong></p>
<blockquote>
<p>如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本次被调度到CPU2，则会增加高速缓存失效、TLB失效;如果每个进程尽量调度到指定的CPU上，各种失效就会减少</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>考虑负载均衡问题</strong></p>
</li>
</ul>
<hr>
<h1 id="五-典型操作系统的调度算法"><a href="#五-典型操作系统的调度算法" class="headerlink" title="五.典型操作系统的调度算法"></a>五.典型操作系统的调度算法</h1><ul>
<li><strong>UNIX —— 动态优先数法</strong></li>
<li><strong>5.3BSD —— 多级反馈队列法</strong></li>
<li><strong>Linux —— 抢占式调度</strong></li>
<li><strong>Windows —— 基于优先级的抢占式多任务调度</strong> </li>
<li><strong>Solaris —— 综合调度算法</strong></li>
</ul>
<h2 id="1-Linux调度算法的发展过程"><a href="#1-Linux调度算法的发展过程" class="headerlink" title="1.Linux调度算法的发展过程"></a>1.Linux调度算法的发展过程</h2><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/20.png" style="zoom:30%;"></p>
<h2 id="2-Windows线程调度"><a href="#2-Windows线程调度" class="headerlink" title="2.Windows线程调度"></a>2.Windows线程调度</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>由于Windows操作系统<strong>支持内核级线程</strong>，所以<strong>CPU的调度单位是线程</strong>。 </p>
<p>Windows的线程调度采用的是<strong>基于动态优先级的，抢占式调度，同时结合了时间配额的调整</strong>。</p>
<p>基本思想：</p>
<ul>
<li><strong>就绪线程按优先级进入相应队列</strong></li>
<li><strong>系统总是选择优先级最高的就绪线程运行</strong></li>
<li><strong>同一优先级的各线程按时间片轮转进行调度</strong></li>
<li><strong>多CPU系统中允许多个线程并行运行</strong></li>
</ul>
<p><strong>引发线程调度的条件：</strong></p>
<ul>
<li><strong>线程正常终止或由于某种错误而终止</strong> </li>
<li><strong>新线程创建或一个等待线程变成就绪</strong> </li>
<li><strong>当一个线程从运行态进入阻塞态</strong></li>
<li><strong>当一个线程从运行态变为就绪态</strong></li>
</ul>
<blockquote>
<p> 然后再此基础上又添加了两个条件：</p>
</blockquote>
<ul>
<li><strong>一个线程的优先级改变了</strong></li>
<li><strong>一个线程改变了它的亲和(Affinity)处理机集合</strong></li>
</ul>
<blockquote>
<p><strong>线程的亲和处理机集合</strong>：有这样一个处理机的集合，允许线程在这个处理机集合上执行，<strong>除了处理机集合之外的其他处理机空闲，这个线程也不能执行。这个集合就是这个线程的亲和处理机集合。</strong></p>
<p>如果这个集合改变了，比如增加了一个新的处理机在这个集合当中，那么就可以引发新的线程调度。</p>
</blockquote>
<h3 id="2-线程优先级"><a href="#2-线程优先级" class="headerlink" title="(2).线程优先级"></a>(2).线程优先级</h3><p>Windows把线程分成了32 个优先级分成了三类：</p>
<p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/21.png" style="zoom:30%;"></p>
<p><strong>实时优先级的线程：</strong>一旦确定了优先级，就不会再改变了。</p>
<p><strong>可变优先级的线程：</strong>它的优先级可以在一定的范围内提升或者是降低。 </p>
<blockquote>
<p> 对于可变优先级的线程，可以区分为 <strong>基本优先级</strong> 和 <strong>当前优先级</strong>。  </p>
</blockquote>
<p>通常系统会安排一个<strong>零页线程</strong>，即给物理内存清零的线程，把它的级别安排在零集，那么当没有其他进程运行的时候，有一个线程可以做这样的工作。</p>
<h3 id="3-线程的时间配额"><a href="#3-线程的时间配额" class="headerlink" title="(3).线程的时间配额"></a>(3).线程的时间配额</h3><p>时间配额<strong>不是一个时间长度值而是一个称为配额单位(quantum unit)的一个整数。</strong>一个线程用完了自己的时间配额时，如果没有其他相 同优先级的线程，<strong>Windows将重新<font color="red">给该线程分配一个新的时间配额</font></strong>，让它继续运行。</p>
<p>时间配额的特殊作用：</p>
<ul>
<li><p>假设用户首先启动了一个运行时间很长的电子表格计算程序，然后切换到一个游戏程序(需要复杂图形计算并显示，CPU型)</p>
</li>
<li><p>如果前台的游戏进程提高它的优先级，则后台的电子表格计算进程就几乎得不到CPU时间了</p>
</li>
<li><p>所以增加游戏进程的时间配额，则不会停止执行电子表格计算， 也能给游戏进程的CPU时间多一些。</p>
</li>
</ul>
<h3 id="4-调度策略"><a href="#4-调度策略" class="headerlink" title="(4).调度策略"></a>(4).调度策略</h3><h4 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h4><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/17.png" style="zoom:30%;"></p>
<blockquote>
<p> 有一个正在运行的线程，优先级是20。在运行过程中，由于需要等待输入输出的结果，那么这个线程就转到了阻塞态让出了 CPU。 调度程序会去选择一个新的线程上CPU运行。</p>
</blockquote>
<h4 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h4><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/18.png" style="zoom:30%;"></p>
<blockquote>
<p> 如果刚才被阻塞的线程被唤醒了，由于它的优先级高，它会去抢占CPU去运行，那么被抢占的这个线程就回到了就绪队列。</p>
</blockquote>
<p>当线程被抢占时，它被放回相应优先级的就绪队列的队首</p>
<ul>
<li><p><strong>处于实时优先级的线程在被抢占时，时间配额被重置为一个完整的时间配额</strong></p>
</li>
<li><p><strong>处于可变优先级的线程在被抢占时，时间配额不变，重新得到CPU后将运行剩余的时间配额</strong></p>
</li>
</ul>
<h4 id="时间配额用完"><a href="#时间配额用完" class="headerlink" title="时间配额用完"></a>时间配额用完</h4><p><img src="//ZYBO_o.github.io/2020/08/11/处理器调度/19.png" style="zoom:40%;"></p>
<p>假设线程A的时间配额用完</p>
<ul>
<li>A的优先级没有降低<ul>
<li>如果队列中有其他就绪线程，选择下一个线程执行，A回到原来就绪队列末尾</li>
<li>如果队列中没有其他就绪线程，系统给线程A分配一个新的时间配额，让它继续运行</li>
</ul>
</li>
<li>A的优先级降低了<ul>
<li>Windows 将选择一个更高优先级的线程</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么一个线程用完了它的时间配额后，优先级会被降低？</p>
<p>那是因为这个线程在此之前，优先级被提升过。</p>
</blockquote>
<h4 id="线程优先级提升和与时间配额挑整"><a href="#线程优先级提升和与时间配额挑整" class="headerlink" title="线程优先级提升和与时间配额挑整"></a>线程优先级提升和与时间配额挑整</h4><p><strong>Windows的调度策略</strong></p>
<ul>
<li><strong>如何体现对某类线程具有倾向性?</strong></li>
<li><strong>如何解决由于调度策略中潜在的不公平性而带来饥饿现象?</strong></li>
<li><strong>如何改善系统吞吐量、响应时间等整体特征?</strong></li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>提升线程的优先级</strong></li>
<li><strong>给线程分配一个很大的时间配额</strong></li>
</ul>
<h4 id="线程优先级提升"><a href="#线程优先级提升" class="headerlink" title="线程优先级提升"></a>线程优先级提升</h4><p>下列5种情况，Windows会提升线程的当前优先级:</p>
<ul>
<li><strong>I/O操作完成</strong></li>
<li><strong>信号量或事件等待结束</strong></li>
<li><strong>前台进程中的线程完成一个等待操作</strong></li>
<li><strong>由于窗口活动而唤醒窗口线程</strong></li>
<li><strong>线程处于就绪态超过了一定的时间还没有运行 ——  “饥饿”现象</strong></li>
</ul>
<blockquote>
<p> 线程优先级的提升是针对可变优先级范围内(1至15)的线程优先级。</p>
</blockquote>
<p><strong>例子：</strong></p>
<ol>
<li><strong>I/O操作完成后的线程优先级提升：</strong></li>
</ol>
<ul>
<li>在完成I/O操作后，Windows将临时提升等待该操作 线程的优先级，保证该线程能更快上CPU运行进行数据处理</li>
<li>优先级的提升值由设备驱动程序决定，提升建议值保存在系统文件<code>Wdm.h</code>或<code>Ntddk.h</code>中</li>
<li>优先级的提升幅度与对I/O请求的响应时间要求是一 致的，响应时间要求越高，优先级提升幅度越大</li>
<li>设备驱动程序在完成I/O请求时通过内核函数<code>IoCompleteRequest</code>来指定优先级提升的幅度</li>
<li>为避免不公平，在I/O操作完成唤醒等待线程时会将该线程的时间配额减1</li>
</ul>
<ol>
<li><strong>“饥饿”线程的优先级提升</strong></li>
</ol>
<ul>
<li><p>系统线程<code>平衡集管理器(balance set manager)</code>每秒钟扫描一次就绪队列，发现是否存在等待时间超过300个时钟中断间隔的线程</p>
</li>
<li><p>如果存在，平衡集管理器将这些线程的优先级提升到15 (最高)，并分配给它一个长度为正常值4倍的时间配额</p>
</li>
<li><p>因此当被提升的线程用完它的时间配额后，立即衰 减到它原来的基本优先级</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>处理器调度</tag>
      </tags>
  </entry>
  <entry>
    <title>进程&amp;线程模型</title>
    <url>/2020/08/10/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-进程基本概念"><a href="#一-进程基本概念" class="headerlink" title="一.进程基本概念"></a>一.进程基本概念</h1><blockquote>
<p>以多道程序设计技术为切点。多道程序设计技术是操作系统最早引入的软件技术。它的基本思想是允许<font color="red">多个程序同时进入内存</font>并运行。主要是<strong>为了提高 CPU的利用率,进而提高整个系统的效率。</strong></p>
</blockquote>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/1.png" style="zoom:40%;"></p>
<p>来看一个例子：</p>
<p>​        在A图中, 内存里有四个程序,因为只有一个物理的程序计数器，所以这四个程序呢是串形执行的。</p>
<p>​        有了多道程序设计技术之后，每个程序变换成了一个独立的控制流，占用一个逻辑的程序计数器。这也是<strong>操作系统虚拟性的一个体现</strong>，<font color="red">把一个物理的程序计数器，给它变换成多个逻辑的程序计数器</font>，实际上每个程序都有自己的程序计数器，由于物理上只有一个程序计数器，所以每个程序真正的上 CPU 就把逻辑程序计数器的内容，推送到物理程序计数器里头。通过这种变换，达到了在内存中同时有多个程序，达到并发执行的效果。</p>
<p>​        C图表示出在一个时间间隔内，每一个程序 A B C D 都执行过了。由于只有一个物理 CPU ，所以这些程序是轮流在 CPU 上执行。但是从宏观上讲它们都在并发执行。</p>
<p><strong>同时又产生了一个问题：在这样一个计算环境下，多个程序并发执行，如何管理在并发环境下同时执行的这些程序？</strong>首先来看下并发环境与并发程序。</p>
<h2 id="1-并发环境与并发程序"><a href="#1-并发环境与并发程序" class="headerlink" title="1.并发环境与并发程序"></a>1.并发环境与并发程序</h2><p><strong>并发环境：</strong>一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态， 并且次序不是事先确定的。</p>
<p><strong>并发程序：</strong>在并发环境中执行的程序。</p>
<blockquote>
<p>在一个并发环境下执行的并发程序，怎么样来刻画这样的程序呢？于是进程的定义就应运而生了。</p>
</blockquote>
<h2 id="2-进程的定义"><a href="#2-进程的定义" class="headerlink" title="2.进程的定义"></a>2.进程的定义</h2><p><strong>定义：</strong>进程是具有独立功能的程序，关于某个数据集合上的一次运行活动，是资源分配的单位，也是CPU调度的单位。又称任务。</p>
<p><strong>特点：</strong></p>
<ul>
<li><p><strong>进程是程序的一次执行过程。</strong>（一个程序执行了两次,三次， 那就是不同的进程） </p>
</li>
<li><p><strong>进程是运行程序的一个抽象。</strong>（它代表了所运行的那个环境，代表了一个 CPU，因此有时候说进程是对 CPU 的一个抽象）</p>
</li>
<li><p><strong>将一个 CPU 把它变换成多个虚拟的 CPU 。</strong>(虚拟化技术)</p>
</li>
<li><p><strong>操作系统的资源是以进程为单位来分配的。比如说内存，文件等等。 最重要的一个资源就是地址空间。</strong>(操作系统为每一个进程分配了一个独立的地址空间)</p>
</li>
<li><p><strong>操作系统把CPU的控制权，交给了某一个进程，让这个进程上去运行，这称之为一个调度。</strong></p>
</li>
</ul>
<blockquote>
<p>在操作系统执行过程中，会有很多的程序向操作系统提出申请来运行，那么操作系统怎么知道这些进程是存在，还是不存在呢？ 这里就介绍操作系统为了管理进程所设计的一个非常重要的数据结构，进程控制块 PCB 。</p>
</blockquote>
<h2 id="3-进程控制块PCB"><a href="#3-进程控制块PCB" class="headerlink" title="3.进程控制块PCB"></a>3.进程控制块PCB</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1).定义"></a>(1).定义</h3><p><strong>PCB：Process Control Block.</strong>又称进程描述符、进程属性。</p>
<p>​        操作系统为了管理进程而，设计的一个非常重要的<strong>数据结构</strong>，这就是进程控制块PCB。这个数据结构是专门用于<strong>控制和管理进程的，它保存控制和管理进程所需要的所有的信息。</strong>主要是记录了进程的<strong>各种属性</strong>，并且描述出进程的<strong>运动变化过程</strong>，进程的<strong>发展程度</strong>。<strong>进程控制块PCB这个数据结构是操作系统感知进程存在的一个标志。它们是一一对应的。</strong></p>
<p><strong>进程表：</strong>由于操作系统管理了很多的进程，为了便于管理，就把所有进程的每个进程的PCB集中在一起，放在了内存的固定区域，这就形成了进程表。</p>
<blockquote>
<p>进程表是所有进程的 PCB 的一个集合。而且就是进程表的大小往往是固定的，确定了在一个操作系统中最多支持多少个进程 。</p>
</blockquote>
<h3 id="2-PCB包含的信息内容"><a href="#2-PCB包含的信息内容" class="headerlink" title="(2).PCB包含的信息内容"></a>(2).PCB包含的信息内容</h3><h4 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h4><ul>
<li><strong>进程标识符(process ID)</strong>，唯一的，通常是一个整数。</li>
<li><strong>进程名</strong>，通常基于可执行文件名，不唯一。</li>
<li><strong>用户标识符(user ID)</strong></li>
<li><strong>进程组关系</strong></li>
</ul>
<h4 id="进程控制信息"><a href="#进程控制信息" class="headerlink" title="进程控制信息"></a>进程控制信息</h4><ul>
<li><strong>当前状态</strong></li>
<li><strong>优先级(priority)</strong></li>
<li><strong>代码执行入口地址</strong></li>
<li><strong>程序的磁盘地址</strong></li>
<li><strong>运行统计信息</strong>(执行时间、页面调度) </li>
<li><strong>进程间同步和通信</strong></li>
<li><strong>进程的队列指针</strong></li>
<li><strong>进程的消息队列指针</strong></li>
</ul>
<h4 id="所拥有的资源和使用情况"><a href="#所拥有的资源和使用情况" class="headerlink" title="所拥有的资源和使用情况"></a>所拥有的资源和使用情况</h4><ul>
<li><strong>虚拟地址空间的状况</strong> </li>
<li><strong>打开文件列表</strong></li>
</ul>
<h4 id="CPU现场信息"><a href="#CPU现场信息" class="headerlink" title="CPU现场信息"></a>CPU现场信息</h4><blockquote>
<p><strong>CPU的现场信息</strong>是指当进程不运行的时候，操作系统要把一些重要的信息，硬件执行的状态信息，保存在PCB 里。</p>
</blockquote>
<ul>
<li><p><strong>寄存器值</strong>(通用寄存器、程序计数 器PC、程序状态字PSW、栈指针)</p>
</li>
<li><p><strong>指向该进程页表的指针</strong></p>
</li>
</ul>
<h3 id="3-SOLARIS的进程控制块与进程表"><a href="#3-SOLARIS的进程控制块与进程表" class="headerlink" title="(3).SOLARIS的进程控制块与进程表"></a>(3).SOLARIS的进程控制块与进程表</h3><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/2.png" style="zoom:33%;"></p>
<p>SOLARIS是基于 Unix 操作系统，它的进程控制块的名字一般叫Proc结构。每一个Proc结构代表一个PCB。把所有的Proc结构组织成一个链，那么这就是一个进程表。</p>
<p><strong>Proc 结构保存的信息：</strong>（重点介绍三个）</p>
<p>第一个是可执行文件 p_exec，通过这样一个记录信息，可以找到这个进程所对应的可执行文件在磁盘上的位置。</p>
<p>第二个是进程的地址空间 p_as，进程地址空间放了很多内容，每一项内容都放在一段里头，通过段来把进程地址空间描述清楚，把这些段按照地址大小的顺序，把它建立成一个 AVL 树，便于以后的查找。 </p>
<p>第三个是文件表，通过这张表可以把所有打开的文件都能找到。</p>
<hr>
<h1 id="二-进程状态及状态转换"><a href="#二-进程状态及状态转换" class="headerlink" title="二.进程状态及状态转换"></a>二.进程状态及状态转换</h1><h2 id="1-进程的三种状态及状态的转换"><a href="#1-进程的三种状态及状态的转换" class="headerlink" title="1.进程的三种状态及状态的转换"></a>1.进程的三种状态及状态的转换</h2><h3 id="1-进程的三种基本状态"><a href="#1-进程的三种基本状态" class="headerlink" title="(1).进程的三种基本状态"></a>(1).进程的三种基本状态</h3><p><strong>运行态(Running)</strong> </p>
<p>进程占有CPU，并在CPU上运行。</p>
<p><strong>就绪态(Ready)</strong> </p>
<p>进程已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。</p>
<p><strong>等待态(Waiting/Blocked)</strong></p>
<blockquote>
<p>也称阻塞态、封锁态、睡眠态 </p>
</blockquote>
<p>进程因等待某一事件而暂时不能运行。</p>
<h3 id="2-三状态模型及状态转换"><a href="#2-三状态模型及状态转换" class="headerlink" title="(2).三状态模型及状态转换"></a>(2).三状态模型及状态转换</h3><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/3.png" style="zoom:25%;"></p>
<h2 id="2-进程的其他状态"><a href="#2-进程的其他状态" class="headerlink" title="2.进程的其他状态"></a>2.进程的其他状态</h2><h3 id="1-创建态"><a href="#1-创建态" class="headerlink" title="(1).创建态"></a>(1).创建态</h3><p>已完成创建一进程所必要的工作，比如分配了PID、填写了PCB。但由于某些原因，操作系统尚未同意执行该进程。</p>
<h3 id="2-终止态"><a href="#2-终止态" class="headerlink" title="(2).终止态"></a>(2).终止态</h3><p>终止执行后，进程进入该状态。</p>
<ul>
<li><p>可完成一些数据统计工作</p>
</li>
<li><p><strong>资源回收</strong></p>
</li>
</ul>
<h3 id="3-挂起态"><a href="#3-挂起态" class="headerlink" title="(3).挂起态"></a>(3).挂起态</h3><p>在操作系统当中，如果想进行一些负载调节时，可能会把进程送入这个状态。</p>
<p>比如如果现在系统中进程太多，CPU也忙不过来了，此时操作系统会把一部分进程，让它暂时不能运行，但是它又不是等待某个事件发生，所以就把它弄成一个特殊的状态，叫挂起态。</p>
<p>一旦进程进入了挂起态，操作系统会把它的内存空间呢收回来。把这些进程的相关的内容送到磁盘上保存起来，一旦继续让它运行，我们通常称之为激活。进程的内容再从磁盘上读入内存就可以了。</p>
<h2 id="3-五状态模型"><a href="#3-五状态模型" class="headerlink" title="3.五状态模型"></a>3.五状态模型</h2><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/4.png" style="zoom:30%;"></p>
<h2 id="4-七状态模型"><a href="#4-七状态模型" class="headerlink" title="4.七状态模型"></a>4.七状态模型</h2><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/5.png" style="zoom:32%;"></p>
<h2 id="5-进程队列"><a href="#5-进程队列" class="headerlink" title="5.进程队列"></a>5.进程队列</h2><blockquote>
<p>操作系统在设计进程模型的时候要确定有什么样的状态，确定状态之间的转换，在什么条件下转换 ，通过什么样的操作来促成这种转换。 而且操作系统当中有很多的进程，它们都处于不同的状态。所以需要按不同的状态把它们管理起来，因此，操作系统设计了一个若干个进程队列。</p>
</blockquote>
<p>操作系统设计了一个若干个进程队列，为<strong>每一个类进程建立一个或者多个队列也是可以的。</strong> 每个队列的元素，实际上就是PCB 状态的改变，其实就是某个进程的PCB从一个队列出队，然后在另一个队列里头入队的过程。也就是伴随着状态的改变，进程的PCB从一个队列进入到另外一个队列。 </p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/6.png" style="zoom:35%;"></p>
<p><strong>五状态进程模型的队列模型：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/7.png" style="zoom:38%;"></p>
<hr>
<h1 id="三-进程控制"><a href="#三-进程控制" class="headerlink" title="三.进程控制"></a>三.进程控制</h1><p>进程控制操作主要是完成进程之间的各状态之间的转换，<strong>进程控制操作实际上就是具有特定功能的程序。</strong> <font color="red">这个程序执行的时候，由于不允许被中断</font>，所以把它称之为原语。</p>
<p><strong>原语：</strong> <strong>所谓原语(有时候又称之为原子操作) 是完成某种特定功能的一段程序</strong>，比如说完成创建，或者是完成阻塞，它是一段程序，完成了某种特定功能，<font color="red">但是这个程序在执行过程中，是具有不可分割性，或者是不可中断的，它必须持续地执行，不允许被打断</font>，这就是原语。</p>
<blockquote>
<p>实现原语需要操作系统通过屏蔽中断的一些措施来达到这样一个结果。进程控制操作最重要的一个就是进程的创建。</p>
</blockquote>
<h2 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h2><p><strong>主要完成以下几个工作：</strong> </p>
<ol>
<li><strong>首先给每一个新的进程分配一个标识ID，再给它找一个空的、 没有用过的进程控制块</strong></li>
<li><p><strong>然后要给这个进程分配它所需要的地址空间。</strong> (如果这个地址空间在虚拟存储机制之下，就假设给了它，只是给了一个虚拟地址空间）。</p>
</li>
<li><p><strong>再初始化这个进程控制块，填写相应的内容</strong>。</p>
<ul>
<li>通常都是设定一些默认值，比如说状态，进程的状态设定为New 等等 </li>
</ul>
</li>
<li>创建进程控制块之后，要把它插入到相应的队列当中， <strong>所以要设置相应的队列指针</strong>。</li>
</ol>
<h2 id="2-进程撤销"><a href="#2-进程撤销" class="headerlink" title="2.进程撤销"></a>2.进程撤销</h2><p><strong>进程的撤销实际上就是结束进程。</strong></p>
<p>结束进程其实主要做两件事情：</p>
<ol>
<li><p><strong>把进程所占有的资源回收</strong> </p>
<ul>
<li>关闭它打开的文件；如果有网络连接就断开；如果分配了一些内存，就把它回收了</li>
</ul>
</li>
<li><p><strong><font color="red">资源回收之后最重要的，是要把分配给它的 PCB 收回。</font></strong></p>
</li>
</ol>
<h2 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3.进程阻塞"></a>3.进程阻塞</h2><p><strong>处于运行状态的进程，在其运行过程中期待某一事件发生</strong>，如等待键盘输入、等待 磁盘数据传输完成、等待其它进程发送消息， <font color="red">当被等待的事件未发生时，由<strong>进程自己执行阻塞原语，使自己由运行态变为阻塞态</strong>。</font></p>
<h2 id="4-UNIX的几个进程控制操作"><a href="#4-UNIX的几个进程控制操作" class="headerlink" title="4.UNIX的几个进程控制操作"></a>4.UNIX的几个进程控制操作</h2><ul>
<li><p><strong>fork( )：</strong>通过<font color="red">复制调用进程来</font>建立新的进程，是 最基本的进程建立过程</p>
</li>
<li><p><strong>exec( )：</strong>包括一系列系统调用，它们都是通过用 一段新的程序代码覆盖原来的地址空间，<font color="red">实现进程执行代码的转换</font></p>
</li>
<li><strong>wait( )：</strong>提供初级进程同步操作，能使一个进程等待另外一个进程的结束</li>
<li><strong>exit( )</strong>：用来终止一个进程的运行</li>
</ul>
<blockquote>
<p>他们都是以系统调用的形式，作为一个接头呈现给用户，由用户程序来调用 。</p>
</blockquote>
<h2 id="5-UNIX的FORK-实现"><a href="#5-UNIX的FORK-实现" class="headerlink" title="5.UNIX的FORK()实现"></a>5.UNIX的FORK()实现</h2><ol>
<li><p><strong>首先会为子进程分配一个空闲的进程描述符，也就是 PCB。</strong></p>
<blockquote>
<p> PCB在 UNIX 一般叫 proc 结构 </p>
</blockquote>
</li>
<li><p><strong>给子进程分配了一个唯一的标识pid</strong> </p>
</li>
<li><p><strong>给子进程分配地址空间</strong> </p>
<blockquote>
<p>在 UNIX 里 fork 以一次一页的方式把父进程的地址空间内容完全地拷贝给子进程</p>
</blockquote>
</li>
<li><p><strong>从父进程那里继承各种共享资源</strong></p>
<blockquote>
<p>比如打开的文件，当前工作目录等等 </p>
</blockquote>
</li>
<li><p><strong>子进程的状态 设置为就绪态，并且把它插入到了就绪队列</strong> </p>
</li>
<li><p><strong>做完这项工作之后，fork 就为子进程返回一个值 0</strong> </p>
</li>
<li><strong>为父进程返回一个值，是子进程的 pid</strong> </li>
</ol>
<blockquote>
<p>那么也就是说，fork 执行完后，原来一个进程，父进程就一分为二，变成了两个进程，一个父进程，一个子进程。</p>
<p>在父进程得到的返回值是 pid，在子进程里得到的返回值是 0。</p>
</blockquote>
<p><strong>问题：以一次一页的方式来复制父进程的地址空间有什么弊端？</strong></p>
<p>​        父进程把它所有的内容都拷贝给子进程 ，但是子进程不一定需要，而且通常情况下，父进程创建子进程是让子进程做与父进程所不同的工作。所以把发父进程所有内容拷贝给子进程，实际上，子进程也不需要。因此，子进程会接着执行 exec这样一个函数来把父进程拷贝过来的这些地址空间给覆盖掉。因此之前的这种复制工作，实际上就是无用功了。</p>
<p><strong>Linux 使用了写时复制技术 Copy-On-Write，</strong><font color="red">Linux中父进程把地址空间的指针传递给子进程，再把地址空间设置为只读。那么当子进程要往地址空间里写东西的时候，操作系统会为子进程单独再开辟一块空间，把相应的内容放进去 那么这样的话呢，节省了之前复制父进程地址空间的时间，加快了 fork 的实现速度。</font></p>
<p><strong>代码例子：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = fork();<span class="comment">/* 创建一个子进程 */</span></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;<span class="comment">/* 出错 */</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “fork failed”);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span> </span><br><span class="line">    execlp(“/bin/ls”, “ls”, <span class="literal">NULL</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">    wait(<span class="literal">NULL</span>); <span class="comment">/* 父进程等待子进程结束 */</span> </span><br><span class="line">    <span class="built_in">printf</span>(“child complete”);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>流程：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/8.png" style="zoom:50%;"></p>
<hr>
<h1 id="四-进程相关概念"><a href="#四-进程相关概念" class="headerlink" title="四.进程相关概念"></a>四.进程相关概念</h1><h2 id="1-进程的讨论"><a href="#1-进程的讨论" class="headerlink" title="1.进程的讨论"></a>1.进程的讨论</h2><h3 id="1-进程的分类"><a href="#1-进程的分类" class="headerlink" title="(1).进程的分类"></a>(1).进程的分类</h3><h4 id="第一种分类"><a href="#第一种分类" class="headerlink" title="第一种分类"></a>第一种分类</h4><ul>
<li><strong>系统进程</strong></li>
<li><strong>用户进程</strong> </li>
</ul>
<blockquote>
<p> 系统进程是操作系统为了管理一些资源而设计的进程,它的主要特点是优先级比较高。相对于用户进程而言，系统进程会优先被调度上CPU 去执行，因为它完成了一些关键的工作。</p>
</blockquote>
<h4 id="第二中分类"><a href="#第二中分类" class="headerlink" title="第二中分类"></a>第二中分类</h4><ul>
<li>前台进程</li>
<li>后台进程 </li>
</ul>
<blockquote>
<p> 前台进程实际上就是和用户直接交互的这样一些进程：用户敲键盘、 动鼠标。</p>
<p>后台进程往往是操作系统在启动了以后创建的一些进程，这些进程为用户来进行服务，比如说打印进程。</p>
<p>有一些应用进程也在系统启动的时候被创建了， 比如说防火墙，还有一些电子邮件的接收。这样的一些进程它们在后台工作，然后发生了一些事件，它们来接收这些事件。对于用户来讲，他所打交道的是前台进程。</p>
</blockquote>
<h4 id="第三种分类"><a href="#第三种分类" class="headerlink" title="第三种分类"></a>第三种分类</h4><ul>
<li>CPU 密集型进程</li>
<li>I/O 密集型程序</li>
</ul>
<blockquote>
<p> 有一些进程需要用到很多的 CPU 时间。比如说，画面渲染需要大量的计算，因此把它称之为 CPU 密集型进程 </p>
<p>有些经常需要输入、 输出、 读盘这样一些操作，这些进程被称之为 I/O 密集型 </p>
<p>那么这两类进程的区分也是为了以后调度程序的选择做一些准备 。</p>
</blockquote>
<h3 id="2-进程层次结构"><a href="#2-进程层次结构" class="headerlink" title="(2).进程层次结构"></a>(2).进程层次结构</h3><h4 id="UNIX进程家族树-init为根"><a href="#UNIX进程家族树-init为根" class="headerlink" title="UNIX进程家族树:init为根"></a>UNIX进程家族树:init为根</h4><p>UNIX 进程都是在一个家族里，这个家族树有一个根，这个根是一个 init 进程，是个 1 号进程，是所有进程的一个祖宗。在某些情况下，某一个进程它结束了，那么它的子孙进程，其实也必须全部的结束。</p>
<h4 id="Windows-地位相同"><a href="#Windows-地位相同" class="headerlink" title="Windows:地位相同"></a>Windows:地位相同</h4><p> 那在 Windows 中也是一个进程创建另一个进程，但是创建完之后，这两个进程的关系比较疏远，也就是它们的地位是相同的。 </p>
<h2 id="2-进程与程序的区别"><a href="#2-进程与程序的区别" class="headerlink" title="2.进程与程序的区别"></a>2.进程与程序的区别</h2><ul>
<li><strong>进程更能准确刻画并发，而程序不能</strong></li>
<li><strong>程序是静态的，进程是动态的</strong></li>
<li><strong>进程有生命周期的，有诞生有消亡，是 短暂的 ; 而程序是相对长久的</strong></li>
<li><strong>一个程序可对应多个进程</strong></li>
<li><strong>进程具有创建其他进程的功能</strong>(程序没有)</li>
</ul>
<h2 id="3-进程地址空间"><a href="#3-进程地址空间" class="headerlink" title="3.进程地址空间"></a>3.进程地址空间</h2><blockquote>
<p>操作系统会给每一个进程都分配了一个地址空间。怎么理解这句话？怎么理解这样一个场景？</p>
</blockquote>
<p><strong>以代码为例：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myval;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  myval = atoi(argv[<span class="number">1</span>]); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(“myval is %d, loc <span class="number">0</span>x%lx\n”, myval, (<span class="keyword">long</span>) &amp;myval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这个程序实际上是从命令行接收了参数，把这个参数赋给一个变量 myval 然后就是循环，来打印这个变量的值，同时把这个变量的位置 打印出来。 </p>
<p>现在同时执行两个 myval 程序。 也就是这两个进程在执行，因为用了一个循环，所以这个进程会一直在那运行下去。如果运行这两个进程，分别用参数 7，8 来调用这个程序，输出的结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/9.png" style="zoom:35%;"></p>
<blockquote>
<p>当执行 myval 7 的时候，myval 的这个变量值是 7 ，地址是 60104C 。同时 myval 8 也在执行。 发现 myval 的值是 8 ，而myval 的地址呢 也是 60104C。 <strong>为何变量 myval 的值是不一样的，地址却是相同的呢？</strong></p>
</blockquote>
<p>实际上每个进程有自己相对独立地址空间。 <font color="red"><strong>两个进程实际上是两个地址空间。而且它们的地址空间是隔离的。不同的地址空间，它的地址不是实际的物理内存地址。 实际上是一个相对地址，如果支持虚存的系统当中，那么这个地址就是虚拟地址，也可以说是一个相对地址，或者是逻辑地址。</strong></font></p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/10.png" style="zoom:35%;"></p>
<p>上图是一个进程地址空间的表示图。在这个空间里，操作系统会占一部分内容：</p>
<ul>
<li><p>上半部分是<strong>操作系统内核的地址空间</strong> </p>
</li>
<li><p>下面是<strong>用户地址空间</strong></p>
<blockquote>
<p>用户地址空间包括了用户执行的过程中所需要的一些代码数据，一些临时变量。 还有在运行过程中如果进行了过程调用函数调用，需要用栈来传递参数，那么主体有这样一些内容。在进程运行过程中还可能调一些共享库， 因此还有一些共享库放在这个位置；如果打开了文件以文件内存映射文件的方式来使用这个文件的话，那么也用到这些空间。这就是进程用户地址空间的内容。</p>
</blockquote>
</li>
</ul>
<p>myvalue 7 和 myvalue 8 这两个进程每个都有这么一个地址空间 ， <font color="red"><strong>因此myvalue这个变量实际上是在不同的地址空间里的相同的位置。因此，我们看到了虚拟地址虽然是相同的 那么这个相同指的是对于这个地址空间的位置，而不是指的在物理内存的位置。</strong></font></p>
<h2 id="4-进程映像-IMAGE"><a href="#4-进程映像-IMAGE" class="headerlink" title="4.进程映像(IMAGE)"></a>4.进程映像(IMAGE)</h2><p><strong>进程映像指的是进程执行过程中它的全过程的一个静态描述，可以把它看成是在某一瞬间的进程的快照。</strong> </p>
<p><strong>包括的内容：</strong>地址空间的内容，硬件寄存器的内容，以及与该进程相关的一些内核数据结构和内核栈。 </p>
<ul>
<li><p>用户相关:进程地址空间(包括代码段、数据段、 堆和栈、共享库……)</p>
</li>
<li><p>寄存器相关:程序计数器、指令寄存器、程序状态 寄存器、栈指针、通用寄存器等的值</p>
</li>
<li><p>内核相关:</p>
<ul>
<li>静态部分:PCB及各种资源数据结构</li>
<li>动态部分:内核栈(不同进程在进入内核后使用不同的内核栈)</li>
</ul>
</li>
</ul>
<h2 id="5-上下文-CONTEXT-切换"><a href="#5-上下文-CONTEXT-切换" class="headerlink" title="5.上下文(CONTEXT)切换"></a>5.上下文(CONTEXT)切换</h2><p><strong>将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。</strong></p>
<ul>
<li><p>进程运行时，其硬件状态保存在<strong>CPU上的寄存器</strong>中。</p>
<blockquote>
<p>寄存器：程序计数器、程序状态寄存器、栈指针、通用寄存器、其他控制寄存器的值。</p>
</blockquote>
</li>
<li><p>进程不运行时，这些寄存器的值保存在<strong>进程控制块 PCB中</strong>；<font color="red">当操作系统要运行一个新的进程时，将 PCB中的相关值送到对应的寄存器中。</font>这个就完成了上下文切换的一个过程。</p>
</li>
</ul>
<hr>
<h1 id="五-线程的引入"><a href="#五-线程的引入" class="headerlink" title="五.线程的引入"></a>五.线程的引入</h1><p>为什么在进程中再派生线程?具体有三个理由：</p>
<ul>
<li><strong>应用的需要</strong> </li>
<li><strong>开销的考虑</strong> </li>
<li><strong>性能的考虑</strong></li>
</ul>
<h2 id="1-Web服务器为例"><a href="#1-Web服务器为例" class="headerlink" title="1.Web服务器为例"></a>1.Web服务器为例</h2><h3 id="1-工作方式"><a href="#1-工作方式" class="headerlink" title="(1).工作方式"></a>(1).工作方式</h3><p><strong>以Web服务器为例，</strong>其工作方式是：</p>
<ol>
<li>从客户端接收网页请求(http协议) </li>
<li>从磁盘上检索相关网页，读入内存</li>
<li>将网页返回给对应的客户端</li>
</ol>
<blockquote>
<p>每次到磁盘上搜索相关的网页，进程就会停在那里，这样性能就比较慢。 怎么样去提高服务器的工作的效率?</p>
</blockquote>
<p>通常情况下，是在服务器的内存里头，开辟一个<strong>网页缓存</strong> ( Web page Cache )，保存了常用的网页。当Web服务器从客户端接收了网页请求之后会先到网页缓存当中去查找，如果找到就直接把结果返回给客户端，就不用到磁盘上去找。 但是如果没找到就先到磁盘上去搜索相关的网页，得到了之后写入网页缓存，然后再把结果返回给用户。 </p>
<h3 id="2-无线程的情况"><a href="#2-无线程的情况" class="headerlink" title="(2).无线程的情况"></a>(2).无线程的情况</h3><p>此时有两种解决方案：</p>
<h4 id="服务进程"><a href="#服务进程" class="headerlink" title="服务进程"></a>服务进程</h4><p>设定一个服务进程，这个服务进程只能是顺序编程 。也就是说，如果它到磁盘上去搜寻网页，那就不能再去接收客户端的请求。因此会造成服务器性能下降。</p>
<blockquote>
<p>为什么不能设定多个服务进程？</p>
<p><strong>每个进程有自己独立的地址空间，所以它不能共享信息，所以只能有一个服务进程。</strong></p>
</blockquote>
<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>有限状态机的方法<strong>实际上是用一个复杂的编程模型来自己模拟一些并发的工作，即进程自己来模拟并发的工作。</strong> </p>
<p>比如说接收了一个用户请求之后，如果要到磁盘上搜寻这个网页，那么原本这个进程会被暂停，这个时候就要改造这个搜寻网页的操作，把它改造成一个<strong>非阻塞的I/O</strong>。</p>
<blockquote>
<p>到磁盘上去搜寻网页的同时这个进程还可以继续做与这个网页内容无关的一些工作。 所以叫非阻塞 I/O。</p>
</blockquote>
<p>在查询网页的同时，磁盘在工作，而且<strong>这个进程就可以回来做别的事情，它可以继续去接收用户的客户端请求。 当新的请求被接收到之后，它继续可能在 Web Cache 里找网页，然后返回去，如果没找到网页呢，继续再去调用磁盘</strong>。<font color="red">但是这就出现了一个问题：磁盘的这个结果返回了，究竟是哪一个客户端的请求呢？</font></p>
<p>所以这个时候，进程要自己把这些信息记录下来，然后磁盘返回了请求之后，就要判断是哪一个客户端的请求，然后返回给对应的客户 端。因此，它的编程模型呢是比较复杂的。</p>
<h3 id="3-引进多线程之后"><a href="#3-引进多线程之后" class="headerlink" title="(3).引进多线程之后"></a>(3).引进多线程之后</h3><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/11.png" style="zoom:35%;"></p>
<p><strong>工作方式：</strong> </p>
<p>把线程分成两类：</p>
<ul>
<li><p><strong>分派线程</strong></p>
<blockquote>
<p>分派线程只需要一个，分派线程的<strong>主要工作就是监听客户端</strong>，客户端只要有请求就把请求读进来，但是它不完成客户端的请求，它把这个请求分派给其它的线程来完成，而完成工作的线程就是工作线程。 </p>
</blockquote>
</li>
<li><p><strong>工作线程</strong></p>
<blockquote>
<p>Web 服务器上有一堆工作线程，它们都是用来完成的是服务客户请求的。分派线程获得了客户端请求之后就把它分给某一个工作线程，工作线程呢还跟前面一样先到Web Cache里去查找网页是否存在，如果存在就返回给客户端，如果不存在就要启动磁盘，到磁盘上去搜寻网页。它到磁盘上搜寻网页，这是一个阻塞的I/O，<strong>这时它就会被阻塞，然后等待，但是没有关系，因为还有其它的工作线程。</strong> </p>
</blockquote>
<h2 id="2-引入线程的优点"><a href="#2-引入线程的优点" class="headerlink" title="2.引入线程的优点"></a>2.引入线程的优点</h2></li>
</ul>
<h3 id="1-从开销的角度"><a href="#1-从开销的角度" class="headerlink" title="(1).从开销的角度"></a>(1).从开销的角度</h3><p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/12.png" style="zoom:35%;"></p>
<h3 id="2-从性能的角度"><a href="#2-从性能的角度" class="headerlink" title="(2).从性能的角度"></a>(2).从性能的角度</h3><p>如果一个进程里头又有多个线程，而这些线程，有的计算，有的去 I/O，当有多个处理器的时候，就可以充分发挥这个优势了。所以当多处理器的情况下，一个进程就可以有很多的任务同时在执行。性能就提高了很多。</p>
<hr>
<h1 id="六-线程的基本概念"><a href="#六-线程的基本概念" class="headerlink" title="六.线程的基本概念"></a>六.线程的基本概念</h1><p>进程有两个基本的属性：</p>
<ul>
<li><p><strong>进程是资源的拥有者。</strong> </p>
</li>
<li><p><strong>进程是CPU的一个调度单位。</strong> </p>
</li>
</ul>
<p>但是有了线程之后，<font color="red">线程就继承了进程中的一个属性，也就是线程成为了 CPU 的调度单位。 而进程依然还是管理资源，然后是资源的一个拥有者。 </font></p>
<p>线程实际上是<strong>进程中的一个运行实体。</strong> </p>
<blockquote>
<p> 从运行的角度，它是一个运行的实体，它是一个 CPU 的调度单位。 有的时候把线程称之为轻量级进程。 也就是说，在进程当中又增加了多个执行序列， 让这些执行序列可以并发执行，以提高软件的运行效率。 </p>
</blockquote>
<p>所以强调的是：<font color="red"><strong>在进程中增加了多个执行序列，叫线程。</strong></font></p>
<hr>
<h1 id="七-线程的属性"><a href="#七-线程的属性" class="headerlink" title="七.线程的属性"></a>七.线程的属性</h1><p> 线程是一个运行实体，它有属于线程自己的一些属性： </p>
<ul>
<li><p><strong>有标识符ID</strong></p>
<blockquote>
<p> 同一个进程的不同线程要区分 </p>
</blockquote>
</li>
<li><p><strong>有状态及状态转换</strong> </p>
<blockquote>
<p>因为线程是上 CPU 的，所以它有状态。它也有状态的转换，也需要提供一些针对线程的操作。 </p>
</blockquote>
</li>
<li><p><strong>不运行的时需要保存上下文环境</strong></p>
<blockquote>
<p>上下文环境：程序计数器等寄存器(保存在线程的相对的数据结构里)</p>
</blockquote>
</li>
<li><p><strong>有自己的栈和栈指针</strong></p>
<blockquote>
<p>不同的线程，这些信息也是不一样的。 </p>
</blockquote>
</li>
<li><p><strong>共享所在进程的地址空间和其他资源</strong></p>
<blockquote>
<p>同一个进程的不同线程它们是共享所在进程地址空间，内容和这个进程所拥有的资源的，所以这是非常重要的，也就是线程之间的通信，或者其他的一些操作带来了便利的地方，它们是共享同一个进程的地址空间和有关的资源。 </p>
</blockquote>
</li>
<li><p><strong>可以创建、撤消另一个线程</strong></p>
<blockquote>
<p>当创建进程以后，实际上是只有一个线程，我们称之为一个主线程。 然后由它再创建其他的线程，所以程序开始的时候，我们可以看成是一个单线程的进程在运行。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="八-线程机制的实现"><a href="#八-线程机制的实现" class="headerlink" title="八.线程机制的实现"></a>八.线程机制的实现</h1><blockquote>
<p>在操作系统中， 如何来支持线程机制的实现? 通常有三种方式：<strong>用户级线程</strong>、 <strong>核心级线程</strong>和<strong>混合方式</strong>。 </p>
<p>由于在线程的概念提出之前，操作系统已经运行了很多年，进程的概念已经用了很长时间。 因此当有一个新的机制提出来的时候， 不同的操作系统对这个机制的支持是不一样的。</p>
</blockquote>
<h2 id="1-用户级线程"><a href="#1-用户级线程" class="headerlink" title="1.用户级线程"></a>1.用户级线程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1).概念"></a>(1).概念</h3><p><strong>用户级线程：</strong>在用户空间建了一个线程库， 这个线程库里提供了一系列的针对线程的操作。 这些线程的管理是通过一个 Run-time System 运行时系统来管理的。 它完成的就是这些线程的创建和线程数据结构的一些管理工作。 如下图所示：</p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/13.png" style="zoom:40%;"></p>
<blockquote>
<p>有一个Run-time System，它是管理这些线程里的数据结构、 线程表。这是用户级线程的一个实现。 </p>
</blockquote>
<p>对于内核而言， 线程的实现是在用户空间，所以<strong>操作系统内核并不知道线程的存在</strong>，也就是说，<font color="red">它的管理还是以进程为单位来管理，它没有感知线程的存在。</font> </p>
<p>从图中可以看到线程的数据结构是由 Run-time System 来管理的。 内核只看到了进程的数据结构， 因此线程的切换，从一个线程换到另外一个线程不需要操作系统内核的干预，也不需要进入内核来做这件事情， 所以速度比较快。 </p>
<blockquote>
<p>UNIX 内的操作系统通常采用这种方式来支持线程。</p>
</blockquote>
<h3 id="2-POSIX线程库——PTHREAD"><a href="#2-POSIX线程库——PTHREAD" class="headerlink" title="(2).POSIX线程库——PTHREAD"></a>(2).POSIX线程库——PTHREAD</h3><p>UNIX内的操作系统通常采用这种方式来支持线程。 它支持线程的时候是遵循 POSIX 规范。也就是 POSIX 规范当中确定了多线程的这种编程的接口。 </p>
<p>那以什么样的方式呈现给用户呢？它对线程库进行了相应的规范。 这个规范就是 PTHREAD 线程库。 这个线程库按照规范要提供若干个函数来支持线程、 创建线程、撤销线程，等待某个线程的结束。 </p>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/14.png" style="zoom:33%;"></p>
<blockquote>
<p>在这堆操作当中，重点介绍一下 yield 函数，<strong>这个函数表示这个线程自愿让出 CPU。</strong> </p>
<p>我们知道一个进程的若干线程实际上是相互配合来完成一项任务的。 所以这线程之间是可以协商由谁上 CPU，所以一个线程如果占 CPU 时间太长，那么别的线程得不到机会，就需要这个线程<code>高尚</code>一点，让出 CPU，它就调用 yield 让出 CPU。 如果它不让出 CPU，其实其它线程是没法上 CPU 的，<font color="red"><strong>因为对于线程而言，它感知不到时钟中断，因为整个时钟段是对进程而言的。</strong> </font></p>
</blockquote>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3).总结"></a>(3).总结</h3><p><strong>优点:</strong></p>
<ul>
<li>线程切换快</li>
<li>调度算法是应用程序特定的</li>
<li><p>用户级线程可运行在任何操作系统上(只需要实现线程库)</p>
<p><strong>缺点:</strong></p>
</li>
</ul>
<ul>
<li><p>内核只将处理器分配给进程，同一进程中的两 个线程不能同时运行于两个处理器上</p>
</li>
<li><p>大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞</p>
<blockquote>
<p><strong>改变：</strong></p>
<ul>
<li>把系统调用，阻塞系统调用改成一个非阻塞的</li>
<li>用 Jacketing/ wrapper 的这种技术在系统调用之外封装一层。 在调用系统调用之前，先判断一下调用这个系统调用会不会导致线程阻塞，如果导致线程阻塞，那么就赶紧地换其它线程，这样的话，就不会因为某个线程调用了一个阻塞的系统调用使得整个进程被阻塞。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="2-核心级线程"><a href="#2-核心级线程" class="headerlink" title="2.核心级线程"></a>2.核心级线程</h2><p>第二类实现线程机制的方法是核心级线程。这个方案就是彻底地改造了操作系统。 </p>
<ul>
<li><p>内核管理所有的线程。 通过 API 的接口向用户提供一些 API 的函数，由用户可以创建线程。 </p>
</li>
<li><p>所以内核既维护了进程的数据结构，也维护了进程里头的各个线程的数据结构。</p>
<blockquote>
<p>从下图中可以看到内核里头既管了线程表， 也管了进程表。 </p>
</blockquote>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/10/进程-线程模型/15.png" style="zoom:35%;"></p>
<ul>
<li>线程的切换需要内核干预，因此要进入内核来完成切换的过程。 调度也是以线程为单位来进行的。 </li>
</ul>
<blockquote>
<p>实现核心级线程机制的典型的操作系统就是 Windows。 </p>
</blockquote>
<h2 id="3-混合模型"><a href="#3-混合模型" class="headerlink" title="3.混合模型"></a>3.混合模型</h2><p>混合模型就是<strong>线程的创建是在用户空间用线程库来完成的。</strong> 但是内核也要管理线程，也就是说<strong>调度是由内核来完成的。</strong> </p>
<blockquote>
<p>这个采用这种混合模型实现线程机制的是 Solaris 操作系统。 </p>
</blockquote>
<p><strong>用户空间的线程和内核的这个关系是什么？</strong></p>
<p>用户线程通过了一个多路复用来复用多个内核级线程，也就是核外的用户空间的线程通过一个机制和核内的一个内核线程对应起来。调度内核这个线程上 CPU 其实就是调度这个核外的这个线程上 CPU。这是 Solaris 的一种实现。 </p>
<hr>
<h1 id="九-总结"><a href="#九-总结" class="headerlink" title="九.总结"></a>九.总结</h1><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h2><ul>
<li><p><strong>并发性：</strong>任何进程都可以与其他进程一起向前推进</p>
</li>
<li><p><strong>动态性：</strong>进程是正在执行程序的实例</p>
<ul>
<li>进程是动态产生，动态消亡的</li>
<li>进程在其生命周期内，在三种基本状态之间转换</li>
</ul>
</li>
<li><p><strong>独立性：</strong>进程是<font color="red">资源分配</font>的一个独立单位 </p>
<blockquote>
<p>例如:各进程的<font color="red">地址空间相互独立</font></p>
</blockquote>
</li>
<li><p><strong>交互性：</strong>指进程在执行过程中可能与其他进程产生直 接或间接的关系</p>
</li>
<li><p><strong>异步性：</strong>每个进程都以其相对独立的、不可预知的速 度向前推进</p>
</li>
<li><p><strong>进程映像：</strong>程序 + 数据 + 栈(用户栈、内核栈) + PCB</p>
</li>
</ul>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><ul>
<li><p><strong>多线程应用场景</strong></p>
<blockquote>
<p>知道什么情况下去应用多线程</p>
</blockquote>
</li>
<li><p><strong>线程基本概念、属性</strong></p>
<blockquote>
<p>程作为一个进程中运行的一个实体，有哪些是属于它自己的信息？有哪些是共享同一个进程的其他的一些资源？</p>
</blockquote>
</li>
<li><p><strong>线程实现机制</strong></p>
<blockquote>
<p>操作系统中如何来实现线程？如何来支持线程？</p>
</blockquote>
</li>
</ul>
<p>看一个非常重要的概念：可再入程序(可重入程序）。 </p>
<p>所谓<strong>可再入程序指的是可以被多个进程同时调用的程序</strong>，因此对这个程序有限制。 也就是它必须<strong>具有的性质是它是纯代码的， 在执行过程中这个代码不会改变。</strong> 如果有改变，就需要调用它的进程提供不同的数据区。 这些改变可以放在数据区，因为代码部分是不再改变的。 实际上是大部分进程和线程都必须是可再入程序才能去运行。 </p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-为什么使用Makefile"><a href="#一-为什么使用Makefile" class="headerlink" title="一.为什么使用Makefile"></a>一.为什么使用Makefile</h1><p>假设有一个如图所示的C工程：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/1.png" alt></p>
<p>如果要编译出可执行程序project_demo，必须执行以下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 步骤1：编译主程序模块</span><br><span class="line"><span class="meta">$</span> gcc -o &lt;100个主程序模块的o文件&gt; -c &lt;100个主程序模块的c文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 步骤2：编译功能模块a</span><br><span class="line"><span class="meta">$</span> gcc -o &lt;1000个功能模块a的o文件&gt; &lt;1000个功能模块a的c文件&gt;</span><br><span class="line"><span class="meta">$</span> ar rcs liba.a &lt;1000个功能模块a的o文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 步骤3：编译功能模块b</span><br><span class="line"><span class="meta">$</span> gcc -o &lt;1000个功能模块b的o文件&gt; &lt;1000个功能模块b的c文件&gt;</span><br><span class="line"><span class="meta">$</span> ar rcs libb.a &lt;1000个功能模块b的o文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 步骤4：生成可执行文件demo</span><br><span class="line"><span class="meta">$</span> gcc -o demo &lt;100个主程序模块的o文件&gt; -L. -la -lb</span><br></pre></td></tr></table></figure></div>
<p><strong>这样就出现了两个问题：</strong></p>
<blockquote>
<ul>
<li>上述4个编译步骤中，几乎每个步骤都有亢长的文件名列表需要输入而且有些还是重复的，这种工作枯燥而又费时，且极易因人为疏忽而出现错误；</li>
<li>假设demo项目每次编译所需的时间都比较长，那么如果之就前已经成功编译过了demo项目，而此后当我们修改了某些源文件需要更新的demo文件时，理论上我们是不希望也不需要去重新编译整个项目的，我们只需要仅分析其中的依赖关系，仅执行需要重新编译链接的命令，以节省编译时间，但是对于依赖关系非常复杂的工程而言，分析源文件涉及到的依赖关系是个非常复杂且容易出错的过程。</li>
</ul>
</blockquote>
<p><strong>而make和Makefile的出现就是为了解决这两个问题的：</strong></p>
<blockquote>
<ul>
<li>makefile文件帮助我们<strong>记录了整个项目工程的所有需要编译的文件列表</strong>，这样我们在编译时仅需要输入简单的make命令就能编译出我们期望的结果。</li>
<li>makefile文件<strong>反映了整个项目中各个模块的依赖关系</strong>，这样我们改动了某些源文件后，仅需简单的输入make命令，<strong>make工具就会根据makefile文件里描述的依赖关系帮助我们分析哪些模块需要重新编译</strong>，并执行相应的操作。</li>
</ul>
</blockquote>
<p><strong>在linux/unix开发环境中，makefile文件则是描述了一个特定编译系统所需要的策略，而make工具则是通过解析makefile文件并执行相应的命令来帮助我们构建其编译系统。</strong></p>
<p>所以主要围绕着下面两个问题来学习Makefile和Make：</p>
<ol>
<li><font color="red">makefile如何记录整个项目工程的所有需要编译的文件列表及如何反映整个项目中各个模块的依赖关系?</font></li>
<li><font color="red">提供了makefile策略描述后，make工具又是是如何解析makefile文件来帮助我们构建其编译系统的？</font>

</li>
</ol>
<hr>
<h1 id="二-关于Makefile"><a href="#二-关于Makefile" class="headerlink" title="二.关于Makefile"></a>二.关于Makefile</h1><h2 id="1-Makefile简介"><a href="#1-Makefile简介" class="headerlink" title="1.Makefile简介"></a>1.Makefile简介</h2><p>makefile就是一个简单的文本文件，它基本上就是由一条条的<code>规则</code>构成。了解一下makefile里的最基本的语法单元，<strong>规则</strong>。</p>
<p>一条makefile的规则构成如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target:prerequisites</span></span><br><span class="line">&lt;tab&gt; command1</span><br><span class="line">&lt;tab&gt; command2</span><br><span class="line">.....</span><br><span class="line">&lt;tab&gt; commandN</span><br></pre></td></tr></table></figure></div>
<ul>
<li>target：<font color="red">规则的目标</font>，可以简单理解为<strong>这条规则存在的目的是什么</strong>。通常是<strong>程序中间或者最后需要生成的文件名</strong>，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。</li>
<li>prerequisites：<font color="red">规则的依赖列表</font>，可以简单的理解为<strong>要达到本条规则的目标所需要的先决条件是什么</strong>。可以是文件名，也可以是其他规则的目标；</li>
<li>command：<font color="red">规则的命令</font>，可以简单的理解为<strong>当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标</strong>。规则的命令其实就是shell命令。一条规则中可以有多行命令，<strong>特别注意：每行命令都必须以tab键开始！</strong></li>
</ul>
<p>实践一个简单的makefile例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的makefile文件</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="string">"Hello world!"</span>  <span class="comment">#注意：每行命令都必须以tab键开始！</span></span><br></pre></td></tr></table></figure></div>
<p>这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(<strong>规则不可以没有目标但是可以没有依赖</strong>)，以及一条命令(其实规则也是可以不需要任何命令的)。</p>
<p>在终端执行Makefile文件：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/2.png" style="zoom:50%;"></p>
<h2 id="2-Make的工作原理"><a href="#2-Make的工作原理" class="headerlink" title="2.Make的工作原理"></a>2.Make的工作原理</h2><p>通过回答下面三个问题来解释make的工作原理：</p>
<blockquote>
<ol>
<li>make命令如何使用</li>
<li>make从哪读取Makefile</li>
<li>make如何解析执行Makefile文件的规则</li>
</ol>
</blockquote>
<p>make命令的基本使用范式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make [ -f makefile ] [ options ] ... [ targets ] ...</span><br></pre></td></tr></table></figure></div>
<p>使用make命令的最简单的方式主要有如下四种形式:</p>
<ol>
<li>简单粗暴，不带任何参数，直接执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile文件：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f &lt;makefile_name&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile目标：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定目录下执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -C &lt;subdir&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<p>在执行make的时候，我们可以带上<code>-f &lt;文件名&gt;</code>参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为<strong>GNUmakefile, makefile,和 Makefile</strong>的文件来作为其makefile文件。</p>
<p>在读取完makefile的内容后，make工具<strong>并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。</strong><font color="red">而这条作为突破口的规则的目标，称为<strong>终极目标</strong></font> 。我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。</p>
<p>一般情况下，make执行一条规则的具体过程是这样的：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/3.png" alt></p>
<p><strong>make解析makefile的流程如下：</strong></p>
<p>假设有makefile内容如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">终极目标：依赖A  依赖B 依赖C</span><br><span class="line">    终极目标命令</span><br><span class="line"></span><br><span class="line">依赖A：子依赖A1 子依赖A2 </span><br><span class="line">    依赖A命令</span><br><span class="line"></span><br><span class="line">依赖B：子依赖B1 子依赖B2 </span><br><span class="line">    依赖B命令</span><br><span class="line"></span><br><span class="line">依赖C：子依赖C1 子依赖C2 </span><br><span class="line">    依赖C命令</span><br></pre></td></tr></table></figure></div>
<p><strong>过程一，以终极目标为树根，解析出整颗依赖树：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/4.png" alt></p>
<p><strong>过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则：</strong></p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/5.png" alt></p>
<hr>
<h1 id="三-Makefile基本概念实例"><a href="#三-Makefile基本概念实例" class="headerlink" title="三.Makefile基本概念实例"></a>三.Makefile基本概念实例</h1><p>通过构建一个简单的c语言项目工程(project_simple)来理解makefile的基本概念。</p>
<p>project_simple的整体目录结构：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/6.png" alt></p>
<h2 id="1-编写文件代码"><a href="#1-编写文件代码" class="headerlink" title="1.编写文件代码"></a>1.编写文件代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple.c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is simple project!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-Makefile文件编写"><a href="#2-Makefile文件编写" class="headerlink" title="2.Makefile文件编写"></a>2.Makefile文件编写</h2><p>最后就是要编写makefile了，一般在编写makefile之前都需要先分析清楚整个工程各个模块的依赖关系，及相应的生成命令。project_simple工程最终生产的是一个叫simple的可执行文件，而该可执行文件是使用gcc命令编译main.c和simple.c生成的。</p>
<p>因此整个工程的关系依赖图，如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/7.png" alt></p>
<p>因此Makefile这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">simple: main.c simple.c</span></span><br><span class="line">    gcc -o simple main.c simple.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-运行验证Makefile"><a href="#3-运行验证Makefile" class="headerlink" title="3.运行验证Makefile"></a>3.运行验证Makefile</h2><h3 id="能否编译出可执行的simple"><a href="#能否编译出可执行的simple" class="headerlink" title="能否编译出可执行的simple"></a>能否编译出可执行的simple</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span>pwd        #查看当前路径</span><br><span class="line"><span class="meta">$</span>ls         #查看编译前当前目录</span><br><span class="line"><span class="meta">$</span>make       #编译simple项目</span><br><span class="line"><span class="meta">$</span>ls         #查看编译结果</span><br><span class="line"><span class="meta">$</span>./simple   #执行simple可执行文件</span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/8.png" alt></p>
<h3 id="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"><a href="#已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作" class="headerlink" title="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"></a>已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ls -lt #查看当前项目中各文件时间戳</span><br><span class="line"><span class="meta">$</span> make   #再次执行编译，查看是否会执行编译命令</span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/9.png" alt></p>
<h3 id="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"><a href="#已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件" class="headerlink" title="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"></a>已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> ls -lt       #对比当前项目各文件时间戳</span><br><span class="line"><span class="meta">$</span> touch main.c #将main.c文件的时间戳修改至最新</span><br><span class="line"><span class="meta">$</span> ls -lt       #查看main.c的时间戳是否最新</span><br><span class="line"><span class="meta">$</span> make         #执行编译命令</span><br><span class="line"><span class="meta">$</span> ls -lt       #查看simple的时间戳是否被更新至最新</span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/10.png" alt></p>
<hr>
<h1 id="四-Makefile语法"><a href="#四-Makefile语法" class="headerlink" title="四.Makefile语法"></a>四.Makefile语法</h1><p>完整的makefile所包含的语法模块：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/11.png" alt></p>
<h2 id="1-通过complicated项目来进行学习Makefile语法"><a href="#1-通过complicated项目来进行学习Makefile语法" class="headerlink" title="1.通过complicated项目来进行学习Makefile语法"></a>1.通过complicated项目来进行学习Makefile语法</h2><p>构建一个名为project_complicated的项目工程，目录结构如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/12.png" alt></p>
<p>编写源代码文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complicated.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, HELLO_STRING);</span><br><span class="line">    complicated();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_STRING <span class="meta-string">"Hello !"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_NAME <span class="meta-string">"complicated"</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"complicated.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This is a %s porject!\n"</span>, PROJECT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>项目依赖关系：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/13.png" alt></p>
<p>对比simple项目，发现complicated项目貌似只是多了一个头文件，但是依赖关系图却多了一层.o文件。</p>
<blockquote>
<p>在用gcc 编译出可执行文件的过程中是包含两个阶段的：编译阶段和链接阶段。</p>
</blockquote>
<p>上述的依赖关系图更加准确的反映出了整个项目的构建过程，这样据此写出来的makefile才能更加灵活及更具可扩展性，<strong>精确的分析清楚项目的依赖关系，是编写一个好的makefile的关键。</strong></p>
<p>编写Makefile文件:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<p>验证过程及结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/14.png" alt></p>
<h2 id="2-使用注解提高可维护性"><a href="#2-使用注解提高可维护性" class="headerlink" title="2.使用注解提高可维护性"></a>2.使用注解提高可维护性</h2><ul>
<li>makefile中<code>#</code>字符后的内容被作为是注释内容（和shell脚本一样）处理。</li>
<li>注释行的结尾如果存在反斜线<code>\</code>，那么下一行也被作为注释行。</li>
<li>当在makefile中如果需要使用字符<code>#</code>时，可以使用反斜线加<code>#</code>（<code>\#</code>）来实现，其表示将<code>#</code>作为一字符而不是注释的开始标志。</li>
</ul>
<p>写一个例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个演示注释语法的makefile</span></span><br><span class="line"><span class="section">all: test #关于依赖的注释</span></span><br><span class="line"><span class="comment">#    echo "Makefile for comment 1"   这里是注释，不是命令</span></span><br><span class="line">    echo <span class="string">"Makefile for comment 2"</span> </span><br><span class="line"><span class="comment"># 这是一个关于test规则的 \</span></span><br><span class="line">  多行注释</span><br><span class="line"><span class="section">test:</span></span><br><span class="line"><span class="comment"># 没有反斜线\, #被当作注释的开始</span></span><br><span class="line">    echo this is a <span class="comment"># test rule1 </span></span><br><span class="line"><span class="comment"># 加上反斜线\, #被当作普通字符</span></span><br><span class="line">    echo this is a \<span class="comment"># test rule2</span></span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/15.png" alt></p>
<blockquote>
<p>可以看出make在执行时一般情况下对于makefile中以<code>#</code>开始到行尾的内容都是直接忽略不做任何处理的。</p>
</blockquote>
<p>complicated项目Makefile:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.1</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。</p>
<p>变量定义的基本格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">变量名 赋值符 变量值</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ul>
<li>变量名指的就是该变量的名字，是不包括<code>:</code>、<code>#</code>、<code>=</code>、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但<strong>定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义</strong>，并且这样命名的变量对于一些shell来说不能作为环境变量使用。<strong>变量名是大小写敏感的。</strong>变量<code>foo</code>、<code>Foo</code>和<code>FOO</code>指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。</li>
<li>变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。</li>
<li>赋值符，有<code>=</code> 、 <code>:=</code> 、 <code>?=</code>和 <code>+=</code>四种格式，其中<code>=</code> 和 <code>:=</code> 为基本定义类型， <code>?=</code>和 <code>+=</code>为基于<code>=</code>的扩展定义类型</li>
</ul>
</blockquote>
<p>一个在makefile中定义变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br></pre></td></tr></table></figure></div>
<h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>当我们定义了一个变量之后，我们就可以在makfile中的<strong>目标</strong>、<strong>依赖</strong>、<strong>命令</strong>中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量<strong>被展开的过程</strong> )，替换掉变量的名字。</p>
<p>变量的引用有以下几种方式：</p>
<blockquote>
<ol>
<li><code>${变量名}</code></li>
<li><code>$（变量名）</code></li>
<li><code>$单字符变量名</code> ，变量名仅包含一个字符，如<code>$@</code> 、<code>$^</code>等</li>
</ol>
</blockquote>
<p>一个在makefile中引用变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program : <span class="variable">$(objects)</span>          <span class="comment">#在依赖中引用变量</span></span><br><span class="line">    gcc -o program $&#123;objects&#125; <span class="comment">#在命令中引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h           <span class="comment">#在目标中引用变量</span></span><br></pre></td></tr></table></figure></div>
<h3 id="变量的分类与赋值"><a href="#变量的分类与赋值" class="headerlink" title="变量的分类与赋值"></a>变量的分类与赋值</h3><p>根据变量定义时所使用的<strong>赋值操作符的不同</strong>，可以将变量分成两种类型(或者说是两种风格)：</p>
<p><code>递归展开式变量</code>和<code>直接展开式变量</code>；</p>
<blockquote>
<p>使用赋值操作符<code>=</code> 、 <code>+=</code> 和 <code>?=</code>定义的变量都是<strong>递归展开式变量</strong>，使用赋值操作符 <code>:=</code>定义的变量为<strong>直接展开式变量</strong> 。</p>
<p>两种变量类型的的最根本区别在于：<strong>变量值的求值时机</strong>，递归式变量的求值时机在于<strong>变量被引用时</strong>，直接展开式的求值时机在于<strong>变量被定义时</strong>。</p>
</blockquote>
<p>编写Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">foo1 = <span class="variable">$(bar)</span>   <span class="comment">#递归展开式变量</span></span><br><span class="line">foo2 := <span class="variable">$(bar)</span>  <span class="comment">#直接展开式变量</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">"foo1 is <span class="variable">$(foo1)</span>, foo2 is <span class="variable">$(foo2)</span>"</span></span><br></pre></td></tr></table></figure></div>
<p>然后，使用 <code>$ make -f variabletype.mk</code> 执行variabletype.mk，演示及结果如下：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/16.png" alt></p>
<p>由于变量<code>foo1</code>的变量值是在执行<code>echo</code>命令时才求的值，所以<code>foo1</code>的值被递归的展开为<code>Huh?</code>； 而变量<code>foo2</code>的变量值在定义时就被求值了，此时由于变量<code>bar</code>的值为空，因此<code>foo2</code>的值也为空。</p>
<blockquote>
<p><strong>注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败</strong></p>
</blockquote>
<p><code>+=</code> 和 <code>?=</code>是基于<code>=</code>扩展而来的两种变量赋值操作符；</p>
<p><code>+=</code> 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar = foo1   </span><br><span class="line">bar += foo2  <span class="comment">#追加赋值，bar的值将为 foo1 foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure></div>
<p><code>?=</code>称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar1 = foo1</span><br><span class="line">bar1 ?= foo2  <span class="comment"># bar1 的值还是foo1</span></span><br><span class="line">bar2 ?= foo2  <span class="comment"># bar2 的值为foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:  </span></span><br><span class="line">    echo <span class="string">"bar1 is <span class="variable">$(bar1)</span>, bar2 is <span class="variable">$(bar2)</span>"</span></span><br></pre></td></tr></table></figure></div>
<h3 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h3><p>在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。</p>
<ul>
<li>自动化变量</li>
</ul>
<p>所谓自动化变量，<strong>就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量</strong>，一般情况下常用的有以下几个自动化变量：</p>
<blockquote>
<p><code>$@</code> — 代表规则中的目标文件名</p>
<p><code>$&lt;</code> — 代表规则的第一个依赖的文件名</p>
<p><code>$^</code> — 代表规则中所有依赖文件的列表，文件名用空格分割</p>
</blockquote>
<p>Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: first second third</span></span><br><span class="line">    echo <span class="string">"\$<span class="variable">$@</span> = <span class="variable">$@</span>"</span></span><br><span class="line">    echo <span class="string">"$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>"</span></span><br><span class="line">    echo <span class="string">"$<span class="variable">$^</span> = <span class="variable">$^</span>"</span></span><br><span class="line"></span><br><span class="line">first second third:</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ol>
<li><script type="math/tex; mode=display">`字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给`echo`命令执行，需要使用`$</script></li>
<li><code>$@</code>在bash shell中也有特殊用途，因此如果希望<code>echo</code>命令在bash中正常输出<code>$@</code>， 需要加上<code>\</code>字符</li>
<li>该makefile的最后一行<code>first second third:</code> 看起来有点奇怪，这是一条<strong>没有依赖和命令的多目标规则</strong>，读者可自行将它删除看有什么效果，并思考原因。</li>
</ol>
</blockquote>
<p>运行结果:</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/17.png" alt></p>
<p>删除<code>first second third</code>后的运行结果:</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/18.png" alt></p>
<h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul>
<li>变量的分类与赋值</li>
</ul>
<p>对于一个c已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为<code>$(VAR:A=B)</code>或者<code>${VAR:A=B}</code>，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := a.c b.c c.c d.d</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">"objects = <span class="variable">$(objects)</span>"</span></span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/19.png" alt></p>
<p>使用变量改进complicated项目的makefile(v1.2)：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.2</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="多目标规则与多规则目标"><a href="#多目标规则与多规则目标" class="headerlink" title="多目标规则与多规则目标"></a>多目标规则与多规则目标</h3><h4 id="多目标规则"><a href="#多目标规则" class="headerlink" title="多目标规则"></a>多目标规则</h4><p>多目标规则，可以简单的理解为是一种将多条具有</p>
<ul>
<li><strong>相同依赖</strong></li>
<li><strong>相同生成命令</strong></li>
</ul>
<p>的规则，合并成一条规则的语法，其基本格式为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets...: prerequisites...</span></span><br><span class="line">    commands</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>假设有以下Makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">"This is a rule for <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="section">target1: dep</span></span><br><span class="line">    echo <span class="string">"This is a rule for <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="section">target2: dep</span></span><br><span class="line">    echo <span class="string">"This is a rule for <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>利用多目标规则，可以将makefile改写成 makefile 文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">"This is a rule for <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用多目标规则合并 target1 和target2的规则</span></span><br><span class="line">target1 target2: dep</span><br><span class="line">    echo <span class="string">"This is a rule for <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果:</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/20.png" alt></p>
<p>可以观察到，虽然多目标规则中要求命令必须相同，但是配合上自动化变量的使用，就是可以针对不同的目标有不同的执行结果。</p>
<h4 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h4><p>Makefile中，一个目标可以同时出现在多条规则中。</p>
<blockquote>
<p>这种情况下，此目标文件的所有依赖文件将会被合并成此目标一个依赖文件列表，其中任何一个依赖文件比目标更新（比较目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目标。</p>
<p>对于一个多规则的目标，<strong>重建此目标的命令只能出现在一个规则中</strong>（可以是多条命令）。</p>
<p>如果多个规则同时给出重建此目标的命令，make将使用最后一个规则的命令，同时提示错误信息。</p>
</blockquote>
<h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>仔细观察complicated项目中的两条子规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<p>首先<strong>它们的命令是一样的</strong>，其次它们目标依赖关系有点相似(目标都是以.o结尾的文件，依赖都是以.c结尾的文件)。<font color="red">对于这种长得很像的规则，makefile提供了一种称为<strong>静态模式规则</strong>的规则来帮助我们简化规则的编写。</font></p>
<p>静态模式规则：</p>
<blockquote>
<p>可以理解为一种特殊的多目标规则，它仅要求多条规则具有相同的命令，而依赖可以不完全一样。</p>
</blockquote>
<p>静态模式规则，其基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...</span><br><span class="line">    COMMANDS</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>其大致意思就是，用<code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>描述的模式，从<code>TARGETS ...</code>取值来形成一条条规则，所有规则的命令都用<code>COMMANDS</code>。</p>
<p><code>TARGETS ...</code>代表具有相同模式的规则的目标列表，在我们的项目中就是main.o和complicated.o，我们可以直接引用我们先前定义的objects变量。</p>
<p><code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>部分定义了，如何为目标列表中的目标，生成依赖；<code>TARGET-PATTERN</code>称为目标模式，<code>PREREQ-PATTERNS</code>称为依赖模式；目标模式和依赖模式中，一般需要包含模式字符<code>%</code>。</p>
<p>目标模式的作用就是从目标列表中的目标匹配过滤出需要的值，目标模式中的字符<code>%</code>表示在匹配过滤的过程中不做过滤的部分，目标模式中的其他字符表示要与目标列表中的目标精确匹配，例如，目标模式<code>%.o</code>， 表示从目标列表的目标中匹配所有以<code>.o</code>结尾的目标，然后过滤掉匹配目标的<code>.o</code>部分， 因此目标<code>main.o</code>经过目标模式<code>%.o</code>匹配过滤后，得到的输出就是<code>main</code>。</p>
<p>依赖模式的作用就是表示要如何生成依赖文件。具体的生成过程，就是使用目标模式过滤出来的值，替换依赖模式字符<code>%</code>所表示的位置。因此，如果依赖模式为<code>%.c</code>， 则使用上述例子过滤出来的<code>main</code>来替换字符<code>%</code>， 最终得到依赖文件<code>main.c</code></p>
<p>因此，可以用静态模式规则来简化我们的complicated项目：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态模式规则简化complicated makefile</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>complicated项目编译完成后，会有可执行文件及中间目标文件，有时出于某些需求，需要将编译生成的文件都删除，让整个项目回到最初的状态。修改后的Makefile如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">executbale := complicated</span><br><span class="line">sources := main.c complicated.c</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(object)</span>:%.o:%.c</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p> 运行结果:</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/21.png" alt></p>
<p>上述的clean规则，貌似能正常工作，但其实是存在bug的，当目录下刚好存在一个叫做clean的文件时，事情就没那么顺利了：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/22.png" alt></p>
<blockquote>
<p>出现以上问题的原因是，当编译目录下存在clean文件时，由于clean规则没有依赖，所以clean文件的时间戳永远显得都是最新的，故其命令也无法被执行，这时我们就得请伪目标出手帮助了。</p>
</blockquote>
<p>当我们将一个目标定义成伪目标时，意味着它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。</p>
<p>定义一个伪目标的基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: &lt;伪目标&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>因此我们以定义complicated项目的clean目标，为伪目标，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p>这样目标<code>clean</code>就是一个伪目标，无论当前目录下是否存在<code>clean</code>这个文件。我们输入<code>make clean</code>之后。<code>rm</code>命令都会被执行。</p>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/23.png" alt></p>
<h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><h3 id="命令的回显"><a href="#命令的回显" class="headerlink" title="命令的回显"></a>命令的回显</h3><p>通常，make在执行命令行之前会把要执行的命令行进行输出，如以下makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">"Hello world!"</span></span><br></pre></td></tr></table></figure></div>
<p>在执行make时，其输出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> make</span><br><span class="line">  echo "Hello world!"</span><br><span class="line">  Hello world!</span><br></pre></td></tr></table></figure></div>
<p><strong>关闭命令回显有以下几种方式：</strong></p>
<ol>
<li>每个需要关闭回显的命令行前加上”@”字符，上述例子关闭回显：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">"Hello world!"</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>执行make时带上参数<code>-s</code>或<code>--slient</code>禁止所有执行命令的显示</li>
<li>在Makefile中使用没有依赖的特殊目标<code>.SILENT</code>也可以禁止所有命令的回显</li>
</ol>
<h3 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>在Makefile中<strong>书写在同一行中的多个命令属于一个完整的shell命令行</strong>，<strong>书写在独立行的一条命令是一个独立的shell命令行</strong>。所以需要注意：在一个规则的命令中，命令行<code>cd</code>改变目录不会对其后的命令的执行产生影响。就是说其后的命令执行的工作目录不会是之前使用<code>cd</code>进入的那个目录。如果要实现这个目的<strong>，</strong>就不能把<code>cd</code>和其后的命令放在两行来书写。而应该把这两条命令写在一行上，用分号分隔。这样它们才是一个完整的shell命令行。</p>
<p>对比以下例子两个规则的输出，编写makefile 文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target1:</span></span><br><span class="line">    @echo <span class="string">"target1"</span></span><br><span class="line">    @cd ~</span><br><span class="line">    @pwd</span><br><span class="line"></span><br><span class="line"><span class="section">target2:</span></span><br><span class="line">    @echo <span class="string">"target2"</span></span><br><span class="line">    @cd ~; pwd</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/24.png" alt></p>
<h3 id="命令执行的错误处理"><a href="#命令执行的错误处理" class="headerlink" title="命令执行的错误处理"></a>命令执行的错误处理</h3><p>通常情况下，规则中的每一条命令在运行结束后，make都会检测命令执行的返回状态，如果返回成功，就执行下一条命令；命令出错（返回状态非0），make就会放弃对当前规则的执行，或者终止对当前makefile的解析执行。</p>
<p>在一些情况下，规则中的一个命令的执行失败并不代表规则执行的错误。为了忽略一些无关紧要的命令执行失败的情况，我们可以在命令之前加一个减号<code>-</code>，来告诉make忽略此命令的执行失败检查。</p>
<p>在更加深入的认识了makefile的规则后，我们complicated项目的makefile(v1.3)就可以这样写了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.3</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<h2 id="5-内嵌函数"><a href="#5-内嵌函数" class="headerlink" title="5.内嵌函数"></a>5.内嵌函数</h2><p>make的内嵌函数为我们提供了处理文件名、变量、文本和命令的方法。使我们的Makefile更为灵活和健壮。我们可以在需要的地方调用函数来处理指定的文本（参数），函数在调用它的地方被替换为它的处理结果。函数调用（引用）的展开和变量引用的展开方式类似：</p>
<p>函数调用方式1:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(FUNCTION ARGUMENTS)</span></span><br></pre></td></tr></table></figure></div>
<p>函数调用方式2：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;FUNCTION ARGUMENTS&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="内嵌函数的分类"><a href="#内嵌函数的分类" class="headerlink" title="内嵌函数的分类"></a>内嵌函数的分类</h3><p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/25.png" alt></p>
<p><strong>使用wildcard函数改进complicated项目makefile:</strong></p>
<p>wildcard函数，其使用范式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>函数名称：wildcard</p>
<p>函数功能：列出当前目录下所有符合模式“PATTERN”格式的文件名。</p>
<p>返回值：空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</p>
<p>函数说明：“PATTERN”使用shell可识别的通配符，包括<code>?</code>（单字符）、<code>*</code>（多字符）等。</p>
</blockquote>
<p>示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure></div>
<p>返回值为当前目录下所有.c源文件列表。</p>
<p>我们可以引进wildcard函数，改进complicated项目的makefile，使其能够自动扫描当前目录下的源文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.4</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 引进wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sourcecs := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/26.png" alt></p>
<h2 id="6-自动生成依赖关系"><a href="#6-自动生成依赖关系" class="headerlink" title="6.自动生成依赖关系"></a>6.自动生成依赖关系</h2><p>complicated项目的makefile已经完成的比较完善了，但还存在一个问题，当更新头文件complicated.h的内容后，执行make时，项目并不会重新编译。</p>
<p>出现以上问题的根本原因是，我们的makefile还没能精确的反映整个项目工程的依赖关系！很明显，项目的依赖关系应该加入对于头文件的依赖，即如下图：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/27.png" alt></p>
<p>根据上述依赖关系，我们可以在makefile加上如下规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(objects)</span>: complicated.h</span><br></pre></td></tr></table></figure></div>
<p>上述新增规则，是一条多目标规则，它与之前的静态模式规则，又组成了多规则目标，可自行思考其工作原理。</p>
<p>上述规则加入虽然能解决我们的问题，但是对于大型复杂的项目，这种需要我们逐个去分析头文件被依赖的关系，几乎是不可能的。所以我们需要工具来帮我们做这个事。下面我们来介绍如何实现自动生成依赖关系。</p>
<p>gcc提供了这样的功能，帮助我们分析一个文件对其他文件的依赖关系列表。在执行gcc时带上<code>-MM</code>选项时，gcc工具就会列出指定文件对其他文件的依赖关系列表。直接来看例子：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/28.png" alt></p>
<p>接下来要考虑的问题就是如何将gcc的输出导入到makefile中了。</p>
<p>makefile支持使用<code>sinclude</code>关键字将指定文件导入到当前的makefile当中，它的作用与C语言的<code>#include</code>预处理命令是一样的。使用方式<code>sinclude &lt;other_makefiles&gt;</code>。</p>
<p>因此，可以将gcc对于源文件的依赖关系分析输出到某个文件(可以称为依赖描述文件，一般命名为与源文件同名但以.d结尾的文件)当中，然后再将依赖描述文件导入到makefile中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖描述文件列表</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br></pre></td></tr></table></figure></div>
<p>当使用<code>sinclude</code>关键字向当前makefile导入文件时，如果所导入的文件不存在，make会试图去执行可以生产导入文件的规则去生产被导入的文件，然后再执行导入。</p>
<p>因此可以使用静态模式规则，让make在执行时，去调用gcc生成依赖关系文件，可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    gcc -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>因此，complicated项目的最终makefile可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.5</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"><span class="comment"># 6. 加入自动规则依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sources := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动规则依赖</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="//ZYBO_o.github.io/2020/03/15/Makefile学习/29.png" alt></p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>存储模型</title>
    <url>/2020/08/17/%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-基本概念：地址重定位"><a href="#一-基本概念：地址重定位" class="headerlink" title="一.基本概念：地址重定位"></a>一.基本概念：地址重定位</h1><h2 id="1-要解决的问题"><a href="#1-要解决的问题" class="headerlink" title="1.要解决的问题"></a>1.要解决的问题</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/1png.png" style="zoom:30%;"></p>
<p>要解决的问题是：如何把一个进程的地址空间的内容装载到内存，然后合理地来分配使用内存，使得每一个进程能够正确地执行。</p>
<h2 id="2-为什么引入"><a href="#2-为什么引入" class="headerlink" title="2.为什么引入"></a>2.为什么引入</h2><ul>
<li><strong>进程中的地址不是最终的物理地址</strong> </li>
<li><strong>在进程运行前无法计算出物理地址</strong><ul>
<li><strong>因为不能确定进程被加载到内存什么地方</strong></li>
</ul>
</li>
</ul>
<p>综上，引出了地址重定位的支持。</p>
<h2 id="3-地址重定位"><a href="#3-地址重定位" class="headerlink" title="3.地址重定位"></a>3.地址重定位</h2><ul>
<li><strong>进程地址空间的地址不是最终的物理地址，而是逻辑地址</strong>，有时也叫相对地址或者叫虚拟地址。</li>
</ul>
<blockquote>
<p>用户程序经过编译、汇编后形成目标代码，目标代码通常采用相对地址的形式，其首地址为0，其余地址都相对于首地址而编址。<font color="red"><strong>不能用逻辑地址在内存中读取信息</strong></font></p>
</blockquote>
<ul>
<li><strong>物理地址(绝对地址，实地址)：</strong> 内存中存储单元的地址，可直接寻址。</li>
</ul>
<p><strong>为了保证CPU执行指令时可正确访问内存单元，<font color="red">需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址</font>，这一过程称为地址重定位。</strong></p>
<h2 id="4-静态重定位和动态重定位"><a href="#4-静态重定位和动态重定位" class="headerlink" title="4.静态重定位和动态重定位"></a>4.静态重定位和动态重定位</h2><h3 id="1-静态重定位"><a href="#1-静态重定位" class="headerlink" title="(1).静态重定位"></a>(1).静态重定位</h3><p><strong>当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换。</strong>一般可以由软件完成。</p>
<blockquote>
<ul>
<li><strong>优点：</strong>在程序的执行过程中，地址就直接可以拿来去到内存中取指令或者取数据。</li>
<li><strong>缺点：</strong>程序在内存的位置不能改变，一旦改变就要重新计算这个转换过程 。</li>
</ul>
</blockquote>
<h3 id="2-动态重定位"><a href="#2-动态重定位" class="headerlink" title="(2).动态重定位"></a>(2).动态重定位</h3><p><strong>在进程执行过程中进行地址变换。 →→ 即逐条指令执行时完成地址转换。</strong>为了加快速度，需要硬件部件支持。<br><img src="//ZYBO_o.github.io/2020/08/17/存储模型/2.png" style="zoom:35%;"></p>
<p>假设起始的地址是在重定位寄存器(基址寄存器)中，会把逻辑送到了这个寄存器进行计算， CPU在执行时会取到一个逻辑地址，然后就把这个地址送到了这个重定位寄存器来完成地址转换的工作，得到真正的物理地址。 </p>
<p><strong>所以逻辑地址经过这样一个部件的转换就会得到物理地址，然后用这个物理地址到内存中去存取相关的指令或者数据。</strong></p>
<hr>
<h1 id="二-物理内存管理"><a href="#二-物理内存管理" class="headerlink" title="二.物理内存管理"></a>二.物理内存管理</h1><h2 id="1-空闲内存管理"><a href="#1-空闲内存管理" class="headerlink" title="1.空闲内存管理"></a>1.空闲内存管理</h2><p>管理方式主要分为：等长划分和不等长划分。</p>
<h3 id="1-等长划分"><a href="#1-等长划分" class="headerlink" title="(1).等长划分"></a>(1).等长划分</h3><p>主要使用的数据结构是 <strong>位图</strong>。</p>
<p>每个分配单元对应于位图中的一位，0表示空闲，1表示占用(或者相反)</p>
<h3 id="2-不等长划分"><a href="#2-不等长划分" class="headerlink" title="(2).不等长划分"></a>(2).不等长划分</h3><p>主要使用的数据结构是 空闲区表，已分配区表和空闲块链表。</p>
<ul>
<li><p>空闲区表，已分配区表</p>
<p>表中每一项记录了空闲区 (或已分配区)的起始地址、长度、标志</p>
</li>
<li><p>空闲块链表</p>
<p>每一个表项用链串联起来</p>
</li>
</ul>
<h2 id="2-内存分配算法"><a href="#2-内存分配算法" class="headerlink" title="2.内存分配算法"></a>2.内存分配算法</h2><blockquote>
<p> 以空闲区表和已分配区表为例介绍内存分配的算法。</p>
</blockquote>
<ul>
<li><p><strong>首次适配 first fit</strong></p>
<ul>
<li>在空闲区表中找到第一个满足进程要求的空闲区</li>
</ul>
</li>
<li><p><strong>下次适配 next fit</strong></p>
<ul>
<li>从上次找到的空闲区处接着查找</li>
</ul>
</li>
<li><p><strong>最佳适配 best fit</strong></p>
<ul>
<li>查找整个空闲区表，找到能够满足进程要求的最小空闲区</li>
</ul>
</li>
<li><p><strong>最差适配 worst fit</strong></p>
<ul>
<li>总是分配满足进程要求的最大空闲区</li>
</ul>
</li>
</ul>
<p>当找到了满足要求的空闲区后，<strong>将该空闲区分为两部分，一部分供进程使用，另一部分形成新的空闲区。</strong></p>
<p>示例：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/5.png" style="zoom:33%;"></p>
<h2 id="3-回收问题"><a href="#3-回收问题" class="headerlink" title="3.回收问题"></a>3.回收问题</h2><p>内存回收算法主要考虑的就是合并。</p>
<ul>
<li><p>当某一块归还后，<strong>前后空闲空间合并，修改内存空闲区表</strong></p>
</li>
<li><p>四种情况 </p>
<ul>
<li><strong>上相邻、下相邻、上下都相邻、上下都不相邻</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="三-伙伴系统"><a href="#三-伙伴系统" class="headerlink" title="三.伙伴系统"></a>三.伙伴系统</h1><p>伙伴系统是Linux低层内存管理采用的一种经典的内存分配方案。它是一种特殊的 “分离适配”算法。</p>
<p><strong>主要思想：</strong>将内存按2的幂进行划分，组成若干空闲块链表;查找该链表找到能满足进程需求的最佳匹配块。</p>
<p>算法：</p>
<ul>
<li><strong>首先将整个可用空间看作一块: $2^U$</strong></li>
<li><strong>假设进程申请的空间大小为 s，如果满足$2^{U-1} &lt; s &lt;= 2^U$，则分配整个块。</strong></li>
<li><p><strong>否则，将块划分为两个大小相等的伙伴，大小为$2^{U-1}$</strong></p>
</li>
<li><p><strong>一直划分下去直到产生<font color="red">大于或等于 s 的最小块</font></strong></p>
</li>
</ul>
<p>示例：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/6.png" style="zoom:33%;"></p>
<hr>
<h1 id="四-基本内存管理方案"><a href="#四-基本内存管理方案" class="headerlink" title="四.基本内存管理方案"></a>四.基本内存管理方案</h1><blockquote>
<p>单一连续区、固定分区和可变分区，它们的特点进程作为一个整体进入一片连续的区域。</p>
<p> 页式，段式和段页式这三种方案不是整个进程进入内存的，而是进入内存的若干个区域，而且这些区域也不连续。</p>
</blockquote>
<h2 id="1-单一连续区"><a href="#1-单一连续区" class="headerlink" title="1.单一连续区"></a>1.单一连续区</h2><p><strong>基本思想：</strong>一段时间内只有一个进程在内存。</p>
<p><strong>特点：</strong>简单，内存利用率低</p>
<p>有三种不同的布局：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/7.png" style="zoom:33%;"></p>
<h2 id="2-固定分区"><a href="#2-固定分区" class="headerlink" title="2.固定分区"></a>2.固定分区</h2><ul>
<li><strong>把内存空间分割成若干区域，称为分区</strong> </li>
<li><strong>每个分区的大小可以相同也可以不同</strong> </li>
<li><strong>分区大小固定不变</strong></li>
<li><strong>每个分区装一个且只能装一个进程</strong></li>
</ul>
<p>示例：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/8.png" style="zoom:33%;"></p>
<h2 id="3-可变分区"><a href="#3-可变分区" class="headerlink" title="3.可变分区"></a>3.可变分区</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li><p>根据进程的需要，把内存空闲空间分割出一个分区，分配给该进程</p>
</li>
<li><p>剩余部分成为新的空闲区</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>外碎片</li>
<li>导致利用率降低</li>
</ul>
<h3 id="2-碎片问题的解决"><a href="#2-碎片问题的解决" class="headerlink" title="(2).碎片问题的解决"></a>(2).碎片问题的解决</h3><p><strong>碎片：很小的、不易利用的空闲区，会导致内存利用率下降。</strong></p>
<p>解决方案：</p>
<p><strong>紧缩技术(memory compaction)：</strong>在内存移动程序，将所有小的空闲区合并为较大的空闲区。</p>
<blockquote>
<p>不是所有进程都可以随便的搬家移动的，需要考虑两个问题：</p>
<ul>
<li><p><strong>开销。</strong>如果有很多进程都需要移动，这会导致时间，空间上的开销。 </p>
</li>
<li><p><strong>移动的时机。</strong> 比如一个进程正在做磁盘的IO操作 ，那这时此进程就不能够移动去别处，因为这样会影响IO的结果。 </p>
</li>
</ul>
</blockquote>
<h2 id="4-页式存储管理方案"><a href="#4-页式存储管理方案" class="headerlink" title="4.页式存储管理方案"></a>4.页式存储管理方案</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li><strong>用户进程地址空间被划分为大小相等的部分，称为<font color="red">页(page) 或页面</font>，从0开始编号。</strong></li>
<li><strong>内存空间按同样大小划分为大小相等的区域，称 为<font color="red">页框(page frame)</font>，从0开始编号;也称为物理页面，页帧，内存块。</strong></li>
</ul>
<h4 id="内存分配-规则"><a href="#内存分配-规则" class="headerlink" title="内存分配(规则)"></a>内存分配(规则)</h4><ul>
<li><p><strong>以页为单位进行分配，并按进程需要的页数来分配；<font color="red">逻辑上相邻的页，物理上不一定相邻。</font></strong></p>
</li>
<li><p>典型页面尺寸：4K 或 4M</p>
</li>
</ul>
<h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p>逻辑地址实际上由两部分组成，页号和页内地址。</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/9.png" style="zoom:30%;"></p>
<p>这种划分是系统硬件自动完成的。 对用户来讲实际上是透明的，这是页式存储管理方案的一个特点。</p>
<h3 id="2-内存分配的过程"><a href="#2-内存分配的过程" class="headerlink" title="(2).内存分配的过程"></a>(2).内存分配的过程</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/10.png" style="zoom:30%;"></p>
<p><strong><font color="red">页表</font>会把逻辑上的某一页和物理上的某一页框的对应关系记录下来， 通过页表记录的这样一个映射关系。页表里的一行叫做<font color="red">页表项</font>。</strong> </p>
<h3 id="3-相关数据结构与地址转换"><a href="#3-相关数据结构与地址转换" class="headerlink" title="(3).相关数据结构与地址转换"></a>(3).相关数据结构与地址转换</h3><ul>
<li><strong>页表</strong><ul>
<li><strong>页表项：</strong>记录了逻辑页号与页框号的对应关系 </li>
<li>每个进程一个页表，存放在内存</li>
<li>页表起始地址保存在系统的寄存器中，或者可能是在PCB中，我也不清楚。</li>
</ul>
</li>
<li><strong>空闲内存管理</strong><ul>
<li>用 bitmap位图这个数据结构可以管理物理内存</li>
</ul>
</li>
<li><strong>地址转换(硬件支持)</strong><ul>
<li><strong><font color="red">CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成为物理地址</font></strong></li>
</ul>
</li>
</ul>
<h3 id="4-问题"><a href="#4-问题" class="headerlink" title="(4).问题"></a>(4).问题</h3><p>会产生<strong>内碎片问题</strong>。 </p>
<blockquote>
<p>假设一个进程需要五页，然后加一条指令，尽管只有还剩一条指令，但还是得要给它分六页，所以实际上还是得给它分成六页，假设最后一条指令在这个第六页上，只占了很小很小的空间，整个大部分的页面都是空的，而这些空的内存空间就是内碎片。</p>
</blockquote>
<h2 id="5-段式存储管理方案"><a href="#5-段式存储管理方案" class="headerlink" title="5.段式存储管理方案"></a>5.段式存储管理方案</h2><h3 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><h4 id="设计思想-1"><a href="#设计思想-1" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li>用户进程地址空间:按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名</li>
<li>内存空间被动态划分为若干长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定。</li>
</ul>
<h4 id="内存分配-规则-1"><a href="#内存分配-规则-1" class="headerlink" title="内存分配(规则)"></a>内存分配(规则)</h4><ul>
<li>以段为单位进行分配，每段 在内存中占据连续空间，但各段之间可以不相邻</li>
</ul>
<h4 id="逻辑地址-1"><a href="#逻辑地址-1" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/11.png" style="zoom:33%;"></p>
<p>逻辑地址和页式不一样的地方是：段号和段内地址不是自动划分的，必须显示给出。</p>
<h3 id="2-内存分配的过程-1"><a href="#2-内存分配的过程-1" class="headerlink" title="(2).内存分配的过程"></a>(2).内存分配的过程</h3><p>示例：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/12.png" style="zoom:30%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/13.png" style="zoom:30%;"></p>
<p><strong>要把逻辑地址和物理地址对应关系记录下来就需要一个数据结构，这就是段表。</strong> </p>
<h3 id="3-相关数据结构与地址转换-1"><a href="#3-相关数据结构与地址转换-1" class="headerlink" title="(3).相关数据结构与地址转换"></a>(3).相关数据结构与地址转换</h3><ul>
<li><p><strong>段表:</strong></p>
<ul>
<li><strong>每项记录了段号、段首地址和段长度之间的关系</strong></li>
<li><strong>每个进程一个段表，存放在内存</strong></li>
<li><strong>段表起始地址保存在何处?与页表一样</strong></li>
</ul>
</li>
<li><p><strong>物理内存管理：</strong></p>
<ul>
<li>可以用不等长的物理内存管理方法，可以用空闲区表来管理这个物理内存</li>
</ul>
</li>
<li><p><strong>地址转换(硬件支持)</strong></p>
<ul>
<li><font color="red">**CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址**</font>



</li>
</ul>
</li>
</ul>
<h2 id="6-段页式存储管理方案"><a href="#6-段页式存储管理方案" class="headerlink" title="6.段页式存储管理方案"></a>6.段页式存储管理方案</h2><h3 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><h4 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h4><ul>
<li><strong>综合页式、段式方案的优点，克服二者的缺点</strong></li>
</ul>
<h4 id="设计思想-2"><a href="#设计思想-2" class="headerlink" title="设计思想"></a>设计思想</h4><ul>
<li>用户进程划分<strong>：先按段划分，每一段再按页面划分</strong></li>
</ul>
<h4 id="逻辑地址-2"><a href="#逻辑地址-2" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/14.png" style="zoom:33%;"></p>
<ul>
<li>由三部分组成：第一部分是<strong>段号</strong>，然后是原来的<strong>段内地址</strong>又划分成<strong>页号</strong>和<strong>页内地址</strong>，所以由三部分组成。</li>
</ul>
<h4 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h4><ul>
<li>同页式存储管理方案</li>
</ul>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ul>
<li>以页为单位进行分配</li>
</ul>
<h3 id="2-段页式存储管理"><a href="#2-段页式存储管理" class="headerlink" title="(2).段页式存储管理"></a>(2).段页式存储管理</h3><p><strong>数据结构及有关操作</strong></p>
<ul>
<li><strong>段表</strong>：记录了每一段的页表始址和页表长度</li>
<li><strong>页表</strong>：记录了逻辑页号与页框号的对应关系。每一段有一张页表，一个进程有多个页表</li>
</ul>
<p><strong>每个进程由一张段表和多个页表组成的。</strong></p>
<ul>
<li><strong>空闲区管理</strong>：同页式管理</li>
<li><strong>内存分配、回收</strong>：同页式管理</li>
</ul>
<p><strong>地址转换</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/15.png" style="zoom:33%;"></p>
<p>首先拿到逻辑地址，逻辑地址是由两部分组成：段号和段内地址。用段号去查段表，得到了所对应的页表的起始地址和长度，然后再把段内地址自动划分成两部分：页号页内地址，用页号去查对应的页表，得到页框号，然后再和页内地址拼接成最后的物理地址。 </p>
<p>整个这个过程比较复杂，成本也比较高。</p>
<h2 id="7-基本内存管理方案小结"><a href="#7-基本内存管理方案小结" class="headerlink" title="7.基本内存管理方案小结"></a>7.基本内存管理方案小结</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/16.png" style="zoom:33%;"></p>
<h1 id="五-交换技术SWAPPING"><a href="#五-交换技术SWAPPING" class="headerlink" title="五.交换技术SWAPPING"></a>五.交换技术SWAPPING</h1><h2 id="1-为什么引入SWAPPING"><a href="#1-为什么引入SWAPPING" class="headerlink" title="1.为什么引入SWAPPING"></a>1.为什么引入SWAPPING</h2><p>为了解决在较小的内存空间运行较大的进程。采用了内存”扩充”技术。</p>
<ul>
<li><strong>内存紧缩技术(例如:可变分区)</strong> </li>
<li><strong>覆盖技术 overlaying</strong></li>
<li><strong>交换技术 swapping</strong></li>
<li><strong>虚拟存储技术 virtual memory</strong></li>
</ul>
<h2 id="2-覆盖技术"><a href="#2-覆盖技术" class="headerlink" title="2.覆盖技术"></a>2.覆盖技术</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p><strong>解决的问题：程序大小超过物理内存总和</strong></p>
<ul>
<li><p>程序执行过程中，程序的不同部分在内存中相互替代</p>
<ul>
<li><p>按照其自身的逻辑结构，<strong>将那些不会同时执 行的程序段共享同一块内存区域</strong></p>
</li>
<li><p>要求程序各模块之间有明确的调用结构</p>
</li>
</ul>
</li>
<li><p>程序员声明覆盖结构，操作系统完成自动覆盖</p>
</li>
</ul>
<blockquote>
<p>主要用于早期的操作系统</p>
</blockquote>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="(2).示例"></a>(2).示例</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/17.png" style="zoom:30%;"></p>
<h2 id="3-交换技术"><a href="#3-交换技术" class="headerlink" title="3.交换技术"></a>3.交换技术</h2><h3 id="1-基本概念-5"><a href="#1-基本概念-5" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li><p>设计思想 </p>
<ul>
<li>内存空间紧张时，<strong>系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域</strong>(进程在内存与磁盘之间的动态调度)</li>
</ul>
</li>
<li><p>讨论：实现时遇到的问题</p>
<ul>
<li><strong>进程的哪些内容要交换到磁盘?会遇到什么困难?</strong> <ul>
<li><strong>运行时创建或修改的内容:栈和堆</strong></li>
</ul>
</li>
<li><strong>在磁盘的什么位置保存被换出的进程?</strong><ul>
<li><strong><font color="red">交换区</font>:一般系统会指定一块特殊的磁盘区域作为交换空间(swap space)，包含连续的磁道， 操作系统可以使用底层的磁盘读写操作对其高效访问。</strong></li>
</ul>
</li>
<li><strong>交换时机?</strong><ul>
<li><strong>只要不用就换出(很少再用);</strong></li>
<li><strong><font color="red">内存空间不够或有不够的危险时换出</font></strong></li>
</ul>
</li>
<li><strong>如何选择被换出的进程?</strong><ul>
<li><strong>考虑进程的各种属性;不应换出处于等待I/O状态的进程</strong></li>
</ul>
</li>
<li><strong>如何处理进程空间增长?</strong><ul>
<li><strong>预留空间向上增长</strong></li>
<li><strong>预留空间同向增长</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/18.png" style="zoom:33%;"></p>
<hr>
<h1 id="六-虚拟存储技术"><a href="#六-虚拟存储技术" class="headerlink" title="六.虚拟存储技术"></a>六.虚拟存储技术</h1><h2 id="1-基本概念-6"><a href="#1-基本概念-6" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul>
<li><p><strong><font color="red">虚拟存储技术</font></strong>是指:<strong>当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作。</strong></p>
</li>
<li><p><strong><font color="red">虚拟地址空间</font>：引入了虚拟存储技术之后每个进程的地址空间</strong></p>
</li>
<li><p><strong><font color="red">虚拟地址</font>：是在虚拟内存中指令或数据的位置，该位置可以被访问，仿佛它是内存的一部分</strong></p>
</li>
</ul>
<p>产生疑问：虚拟内存的地址究竟在哪里？</p>
<h2 id="2-存储器的层次结构"><a href="#2-存储器的层次结构" class="headerlink" title="2.存储器的层次结构"></a>2.存储器的层次结构</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/19.png" style="zoom:30%;"></p>
<h2 id="3-虚存与存储体系"><a href="#3-虚存与存储体系" class="headerlink" title="3.虚存与存储体系"></a>3.虚存与存储体系</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/20.png" style="zoom:33%;"></p>
<ul>
<li><strong>把内存与磁盘有机地结合起来使用，从而得到一个容量很大的“内存”，即<font color="red">虚存</font>。</strong></li>
<li><strong>虚存是对物理内存的抽象，构建在存储体系之上，由操作系统协调各存储器的使用</strong></li>
<li><strong>虚存提供了一个比物理内存空间大得多的地址空间</strong></li>
</ul>
<blockquote>
<p>虚存的大小受到了<strong>计算机系统的寻址机制</strong>还有<strong>磁盘空间中可用空间</strong>的这两方面的限制。</p>
</blockquote>
<h2 id="4-地址保护"><a href="#4-地址保护" class="headerlink" title="4.地址保护"></a>4.地址保护</h2><ul>
<li><strong>确保每个进程有独立的地址空间</strong></li>
<li><strong>确保进程访问合法的地址范围</strong></li>
<li><strong>确保进程的操作是合法的</strong></li>
</ul>
<blockquote>
<p>防止地址越界，防止访问越权。</p>
</blockquote>
<p>示例</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/21.png" style="zoom:35%;"></p>
<h2 id="5-虚拟页式"><a href="#5-虚拟页式" class="headerlink" title="5. 虚拟页式"></a>5. 虚拟页式</h2><p>把<strong>虚拟存储技术</strong>应用到<strong>页式存储管理方案</strong>就得到了<strong>虚拟页式存储管理系统</strong></p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="(1).概念"></a>(1).概念</h3><p><strong>基本思想</strong></p>
<ul>
<li><strong>进程开始运行之前，不是装入全部页面，而是装入一个或零个页面</strong></li>
<li><strong>之后，根据进程运行的需要，动态装入其 他页面</strong></li>
<li><strong>当内存空间已满，而又需要装入新的页面 时，则根据某种算法置换内存中的某个页 面，以便装入新的页面</strong></li>
</ul>
<h3 id="2-两种方式"><a href="#2-两种方式" class="headerlink" title="(2).两种方式"></a>(2).两种方式</h3><p><strong>1、请求调页(demand paging)</strong></p>
<p>当需要这个页面，这个页面还没在内存，这时操作系统把它调入内存。</p>
<p><strong>2、预先调页(prepaging)</strong></p>
<p>预测猜测哪些页面即将会被用到，提前把它调入内存</p>
<p><strong>虚拟存储技术其实<font color="red">以CPU时间和磁盘空间换取昂贵内存空间</font>， 这是操作系统中的资源转换技术。</strong></p>
<hr>
<h1 id="六-页表及页表项的设计"><a href="#六-页表及页表项的设计" class="headerlink" title="六.页表及页表项的设计"></a>六.页表及页表项的设计</h1><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/22.png" style="zoom:30%;"></p>
<p>当进程运行的过程中如果要访问一些页面，那就要通过一个页表，页表记录哪些页面已经加载到内存。</p>
<h2 id="1-页表表项设计"><a href="#1-页表表项设计" class="headerlink" title="1.页表表项设计"></a>1.页表表项设计</h2><h3 id="1-基本概念-7"><a href="#1-基本概念-7" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>页表<strong>由页表项组成</strong>，包含页框号、有效位、访问位、修改位、保护位。</p>
<ul>
<li><strong>页框号 (内存块号、物理页面号、页帧号)</strong></li>
<li><p><strong>有效位(驻留位、中断位)：</strong>表示该页是在内存还是在磁盘</p>
<ul>
<li>有效位是0表示这个页面还没有读进内存，这时页框号是无效的；如果有效位为1 ，表示相应的虚页面的内容已经读入内存。</li>
</ul>
</li>
<li><p><strong>访问位：</strong>引用位</p>
<ul>
<li>引用位为1表示被引用</li>
</ul>
</li>
<li><strong>修改位：</strong>此页在内存中是否被修改过 <ul>
<li>修改过则为1</li>
</ul>
</li>
<li><strong>保护位：</strong>读/可读写</li>
</ul>
<p><strong>通常，页表项是硬件设计的。</strong></p>
<h3 id="2-关于页表"><a href="#2-关于页表" class="headerlink" title="(2).关于页表"></a>(2).关于页表</h3><p> <strong>32位虚拟地址空间的页表规模</strong> </p>
<ul>
<li>页面大小为4K;页表项大小为4字节 </li>
<li>则:一个进程地址空间有 $2^{20}$页</li>
<li>其页表需要占 1024页</li>
</ul>
<p><strong>64位虚拟地址空间的页表规模</strong> </p>
<ul>
<li><p>页面大小为4K;页表项大小为8字节</p>
</li>
<li><p>页表规模: 32,000 TB</p>
</li>
</ul>
<p><strong>页表页在内存中若不连续存放，则需要引入页表页的 地址索引表 → <font color="red">页目录</font></strong></p>
<h3 id="3-二级页表结构及地址映射"><a href="#3-二级页表结构及地址映射" class="headerlink" title="(3).二级页表结构及地址映射"></a>(3).二级页表结构及地址映射</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/23.png" style="zoom:33%;"></p>
<h3 id="4-CORE17页表结构"><a href="#4-CORE17页表结构" class="headerlink" title="(4).CORE17页表结构"></a>(4).CORE17页表结构</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/24.png" style="zoom:33%;"></p>
<blockquote>
<p> <strong>虚拟地址空间$2^{48}$</strong></p>
</blockquote>
<h3 id="5-1386页目录项和页表项"><a href="#5-1386页目录项和页表项" class="headerlink" title="(5).1386页目录项和页表项"></a>(5).1386页目录项和页表项</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/25.png" style="zoom:33%;"></p>
<ul>
<li><strong>PFN(Page Frame Number)：页框号</strong> </li>
<li><strong>P(Present)：有效位</strong> </li>
<li><strong>A(Accessed)：访问位</strong></li>
<li><strong>D(Dirty)：修改位</strong> </li>
<li><strong>R/W(Read/Write)：只读/可读写</strong> </li>
<li><strong>U/S(User/Supervisor)：用户/内核</strong> </li>
<li><strong>PWT(Page Write Through)：缓存写策略</strong> </li>
<li><strong>PCD(Page Cache Disable)：禁止缓存</strong> </li>
<li><strong>PS(Page Size):大页4M</strong></li>
</ul>
<h2 id="2-反转页表"><a href="#2-反转页表" class="headerlink" title="2.反转页表"></a>2.反转页表</h2><h3 id="1-基本概念-8"><a href="#1-基本概念-8" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><ul>
<li>从虚拟地址空间出发：<strong>虚拟地址 → 查页表 → 得到页框号 → 形成物理地址 每个进程一张页表</strong></li>
</ul>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><ul>
<li><p><strong>从物理地址空间出发，整个系统建立一张页表</strong></p>
</li>
<li><p><strong>页表项记录进程i的某虚拟地址(虚页号)与页框号的映射关系</strong></p>
</li>
</ul>
<h3 id="3-反转页表设计"><a href="#3-反转页表设计" class="headerlink" title="(3).反转页表设计"></a>(3).反转页表设计</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/26.png" style="zoom:33%;"><img src="//ZYBO_o.github.io/2020/08/17/存储模型/27.png" style="zoom:33%;"></p>
<ul>
<li><p><strong>PowerPC、UltraSPARC和IA-64 等体系结构采用</strong></p>
</li>
<li><p><strong>将虚拟地址的页号部分映射到一个散列值</strong></p>
</li>
<li><p><strong>散列值指向一个反转页表</strong></p>
</li>
<li><strong>反转页表大小与实际内存成固定比例，与进程个数无关</strong></li>
</ul>
<hr>
<h1 id="七-地址转换过程及TLB的引入"><a href="#七-地址转换过程及TLB的引入" class="headerlink" title="七.地址转换过程及TLB的引入"></a>七.地址转换过程及TLB的引入</h1><h2 id="1-地址转换过程"><a href="#1-地址转换过程" class="headerlink" title="1.地址转换过程"></a>1.地址转换过程</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/28.png" style="zoom:33%;"></p>
<p><strong>整个过程是由MMU内存管理单元完成的。</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/29.png" style="zoom:33%;"></p>
<p><strong><font color="red">内存管理单元的作用将CPU取到的虚拟地址转换成物理地址。</font></strong></p>
<p>MMU的位置如下：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/31.png" style="zoom:33%;"></p>
<h2 id="2-快表TLB的引入"><a href="#2-快表TLB的引入" class="headerlink" title="2.快表TLB的引入"></a>2.快表TLB的引入</h2><h3 id="1-问题："><a href="#1-问题：" class="headerlink" title="(1).问题："></a>(1).问题：</h3><ul>
<li><p><strong>页表 → 两次或两次以上的内存访问</strong></p>
</li>
<li><p><strong>CPU的指令处理速度与内存指令的访问速度差异大，CPU的速度得不到充分利用</strong></p>
</li>
</ul>
<p>如何加快地址映射速度，以改善系统性能?</p>
<p><strong><font color="red">利用程序访问的局部性原理</font>→引入快表(TLB)</strong>→<strong>加快地址转换的速度</strong> </p>
<h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="(2).基本概念"></a>(2).基本概念</h3><p><strong>快表(Translation Look-aside Buffers)：实际上是一个缓冲区。</strong></p>
<p>特点：</p>
<ul>
<li><strong>在CPU中引入的高速缓存(Cache)，可以匹配CPU的处理 速率和内存的访问速度</strong></li>
<li><p><strong>一种随机存取型存储器，除连线寻址机制外，还有接线逻辑，<font color="red">能按特定的匹配标志在一个存储周期内对所有的字同时进行比较</font></strong></p>
</li>
<li><p>快表通常称为相联存储器，<strong>特点是按内容并行查找。</strong></p>
</li>
<li><p><strong>快表容量有限，保存正在运行进程的页表的子集(部分页表项)</strong></p>
</li>
</ul>
<p><strong>快表的大小：</strong>像高速缓存一样分成几级，每一级的大小不一样。</p>
<p><strong>快表的位置：</strong>在CPU片上 </p>
<h3 id="3-引入快表后地址转换过程示意"><a href="#3-引入快表后地址转换过程示意" class="headerlink" title="(3).引入快表后地址转换过程示意"></a>(3).引入快表后地址转换过程示意</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/32.png" style="zoom:35%;"></p>
<hr>
<h1 id="八-页错误"><a href="#八-页错误" class="headerlink" title="八.页错误"></a>八.页错误</h1><h2 id="1-基本概念-9"><a href="#1-基本概念-9" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h2><p>页错误又称页面错误、页故障、页面失效。<strong>指的是地址转换过程中硬件产生的异常。</strong></p>
<p>具体原因：</p>
<ul>
<li><p><strong>所访问的虚拟页面没有调入物理内存 → <font color="red">缺页异常</font></strong></p>
</li>
<li><p><strong>页面访问违反权限(读/写、用户/内核)</strong></p>
</li>
<li><p><strong>错误的访问地址</strong></p>
<blockquote>
<p>代码，数据呀，以及引用的一些共享库是有内容的，但是在访问过程当中的虚拟地址指向了没有 内容的位置，这相当于错误的访问地址。</p>
</blockquote>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/33.png" style="zoom:33%;"></p>
<h2 id="2-缺页异常处理"><a href="#2-缺页异常处理" class="headerlink" title="(2).缺页异常处理"></a>(2).缺页异常处理</h2><ul>
<li><p>是一种<strong>PageFault</strong></p>
</li>
<li><p><strong>在地址映射过程中，硬件检查页表时发现所要访 问的页面不在内存，则产生该异常——<font color="red">缺页异常</font></strong></p>
</li>
<li><p><strong>由操作系统执行<font color="red">缺页异常处理程序</font>，主要工作：获得磁盘地址， 启动磁盘，将该页调入内存</strong></p>
<ul>
<li><strong>第一种可能性：如果内存中有空闲页框，则分配一个页框， 将新调入页装入，并修改页表中相应页表项 的有效位及相应的页框号</strong></li>
<li><strong>第二种可能性：若内存中没有空闲页框，则要置换内存中某一页框；若该页框内容被修改过，则要将其写回磁盘</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>可以增加预取的功能。 也就是在把页面调入内存的同时，顺带的把相关的一些页面也都调进内存。 比如Windows就会这么做，当要读入一段页面，这个页面是代码内容的话，就会接着多读入几个页面。 数据的话，它也会多读入几个页面，这就可以在一定程度上防止缺页的再发生。</p>
</blockquote>
<hr>
<h1 id="九-软件相关策略"><a href="#九-软件相关策略" class="headerlink" title="九.软件相关策略"></a>九.软件相关策略</h1><h2 id="1-驻留集"><a href="#1-驻留集" class="headerlink" title="1.驻留集"></a>1.驻留集</h2><p><strong>驻留集大小：给每个进程分配多少页框。</strong></p>
<p>分配策略：</p>
<ul>
<li><p><strong>固定分配策略</strong></p>
<ul>
<li><strong>进程创建时确定 可以根据进程类型(交互、批处理、应用类)或者基于程序员或系统管理员的需要来确定。</strong></li>
</ul>
</li>
<li><p><strong>可变分配策略</strong> </p>
<ul>
<li><strong>根据缺页率评估进程局部性表现</strong></li>
<li><strong>缺页率高→增加页框数</strong> </li>
<li><strong>缺页率低→减少页框数</strong> </li>
<li><strong>系统开销</strong></li>
</ul>
</li>
</ul>
<h2 id="2-置换问题"><a href="#2-置换问题" class="headerlink" title="2.置换问题"></a>2.置换问题</h2><p><strong>当一个内存已经用完，没有空闲页框时，就需要挑一些页框把它内容换出去，这就是置换。</strong></p>
<p><strong>置换范围</strong></p>
<ul>
<li>计划置换页面的集合是局限在产生缺页中断的进程，还是所有进程的页框?</li>
</ul>
<p><strong>置换策略</strong> </p>
<ul>
<li>在计划置换的页框集合中，选择换出哪一个页框?</li>
</ul>
<h3 id="1-置换范围"><a href="#1-置换范围" class="headerlink" title="(1).置换范围"></a>(1).置换范围</h3><ul>
<li><p>局部置换策略 </p>
<ul>
<li>仅在产生本次缺页的进程的驻留集中选择</li>
</ul>
</li>
<li><p>全局置换策略 </p>
<ul>
<li>将内存中所有未锁定的页框都作为置换的候选</li>
</ul>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/34.png" style="zoom:33%;"></p>
<h3 id="2-置换策略"><a href="#2-置换策略" class="headerlink" title="(2).置换策略"></a>(2).置换策略</h3><ul>
<li><p><strong>所有策略的目标</strong></p>
<p><strong>→置换出的页框是最近最不可能访问的页</strong></p>
</li>
<li><p><strong>根据局部性原理，最近的访问历史和最近将要 访问的模式间存在相关性，因此，大多数策略都<font color="red">基于过去的行为来预测将来的行为</font></strong></p>
</li>
</ul>
<blockquote>
<p><strong>注意：置换策略设计得越精致、越复杂，实现 的软硬件开销就越大</strong></p>
<p><strong>约束：不能置换被锁定的页框</strong></p>
</blockquote>
<h3 id="3-页框锁定"><a href="#3-页框锁定" class="headerlink" title="(3).页框锁定"></a>(3).页框锁定</h3><p>为什么要锁定页面?</p>
<ul>
<li><strong>采用虚存技术后</strong><ul>
<li><strong>开销 → 使进程运行时间变得不确定</strong></li>
</ul>
</li>
<li><strong>给每一页框增加一个锁定位</strong></li>
<li><strong>通过设置相应的锁定位，不让操作系统将进程使用的页面换出内存，避免产生由交换过程带来的不确定的延迟。</strong></li>
</ul>
<blockquote>
<p>例如:操作系统核心代码、关键数据结构、I/O缓冲</p>
</blockquote>
<h2 id="3-清除策略"><a href="#3-清除策略" class="headerlink" title="3.清除策略"></a>3.清除策略</h2><h3 id="1-基本概念-10"><a href="#1-基本概念-10" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li><p><strong>清除：从进程的驻留集中收回页框</strong></p>
</li>
<li><p><strong>虚拟页式系统工作的<font color="red">最佳状态</font>：发生缺页异常时，系统中有大量的空闲页框</strong></p>
</li>
<li><p><strong>结论：在系统中<font color="red">保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能</font></strong></p>
</li>
</ul>
<h3 id="2-设计策略"><a href="#2-设计策略" class="headerlink" title="(2).设计策略"></a>(2).设计策略</h3><ul>
<li><p><strong>设计一个分页守护进程(paging daemon)，多数时间睡眠着，可定期唤醒以检查内存的状态</strong></p>
</li>
<li><p><strong>如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存</strong></p>
</li>
<li><p><strong>如果页面装入内存后被修改过，则将它们写回磁盘。<font color="red">分页守护进程可保证所有的空闲页框是“干净”的</font></strong></p>
</li>
</ul>
<h3 id="3-页缓存技术"><a href="#3-页缓存技术" class="headerlink" title="(3).页缓存技术"></a>(3).页缓存技术</h3><p>当进程需要使用一个已置换出的页框时，如果该页框还没有被新的内容覆盖，系统将它从空闲页框集 合中移出即可恢复该页面。</p>
<p>页缓冲技术:</p>
<ul>
<li><p><strong>不丢弃置换出的页，将它们放入两个表之一：如果未被修改，则放到空闲页链表中，如果修改了，则放到修改页链表中</strong></p>
</li>
<li><p><strong>被修改的页定期写回磁盘(不是一次只写一个，大大减 少I/O操作的数量，从而减少了磁盘访问时间)</strong></p>
</li>
<li><p><strong>被置换的页仍然保留在内存中，一旦进程又要访问该页，可以迅速将它加入该进程的驻留集合(代价很小)</strong></p>
</li>
</ul>
<hr>
<h1 id="十-页面置换算法"><a href="#十-页面置换算法" class="headerlink" title="十.页面置换算法"></a>十.页面置换算法</h1><h2 id="1-最佳页面置换算法-OPT"><a href="#1-最佳页面置换算法-OPT" class="headerlink" title="1.最佳页面置换算法 OPT"></a>1.最佳页面置换算法 OPT</h2><p><strong>设计思想:</strong> </p>
<ul>
<li><strong>置换以后不再需要的或最远的将来才会用到的页面</strong></li>
</ul>
<p><strong>这个算法的实现是要建立在已经知道页面的走向序列的基础之上才能够实施这个算法。所以<font color="red">通常作为一种标准来衡量其他算法的性能</font>。</strong></p>
<h2 id="2-先进先出算法-FIFO"><a href="#2-先进先出算法-FIFO" class="headerlink" title="2.先进先出算法 FIFO"></a>2.先进先出算法 FIFO</h2><p><strong>设计思想</strong></p>
<ul>
<li><strong>选择在内存中驻留时间最长的页并置换它</strong></li>
</ul>
<p><strong>实现：<font color="red">页面链表法</font></strong></p>
<h2 id="3-第二次机会算法-SCR"><a href="#3-第二次机会算法-SCR" class="headerlink" title="3.第二次机会算法 SCR"></a>3.第二次机会算法 SCR</h2><blockquote>
<p>在先进先出基础上做的改进</p>
</blockquote>
<p>设计思想</p>
<ul>
<li><strong>按照先进先出算法选择某一页面，检查其访问位R，如果为0，则置换该页；如果为1，则给第二次机会，并将访问位置0</strong></li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/35.png" style="zoom:33%;"></p>
<h2 id="4-时钟算法-CLOCK"><a href="#4-时钟算法-CLOCK" class="headerlink" title="4.时钟算法 CLOCK"></a>4.时钟算法 CLOCK</h2><p>第二次机会算法问题：摘链、 挂链都需要花一些开销。</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/36.png" style="zoom:30%;"></p>
<p><strong>时钟算法是把所有的页框组织成一个环形，然后用一个指针，通过移动指针来选择下一个要淘汰的页框。</strong></p>
<h2 id="5-最近未使用算法-NRU"><a href="#5-最近未使用算法-NRU" class="headerlink" title="5.最近未使用算法 NRU"></a>5.最近未使用算法 NRU</h2><h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="(1).基本思想"></a>(1).基本思想</h3><p>设计思想：</p>
<ul>
<li><strong>选择在最近一段时间内未使用过的一页并置换</strong></li>
</ul>
<p>实现：</p>
<ul>
<li><strong>设置页表，表项的两位：访问位(R)， 修改位(M</strong></li>
</ul>
<blockquote>
<p>如果硬件没有这 些位，则可用软 件模拟(做标记)</p>
</blockquote>
<p><strong>启动一个进程时，R、M位置0。R位被定期清零(复位)</strong></p>
<p>发生缺页中断时，操作系统检查R，M: </p>
<ul>
<li><strong>第1类：无访问，无修改</strong> </li>
<li><strong>第2类：无访问，有修改</strong> </li>
<li><strong>第3类：有访问，无修改</strong> </li>
<li><strong>第4类：有访问，有修改</strong></li>
</ul>
<p>算法思想: <strong>随机从编号最小的非空类中选择一页置换</strong></p>
<h3 id="2-时钟实现"><a href="#2-时钟实现" class="headerlink" title="(2).时钟实现"></a>(2).时钟实现</h3><ol>
<li><p><strong>从指针的当前位置开始，扫描页框缓冲区，选择遇到的第一个页框 (r=0;m=0) 用于置换( 本扫描过程中，对使用位不做任何修改)</strong></p>
</li>
<li><p><strong>如果第1步失败，则重新扫描，选择第一个(r=0; m=1)的页框(本次扫描过程中，对每个跳过的页框，将其使用位设置成0)</strong></p>
</li>
<li><p><strong>如果第2步失败，指针将回到它的最初位置，并且集合中所有页框的使用位均为0。重复第1步，并且，如果有必要，重复第2步。这样将可以找到供置换的页框</strong></p>
</li>
</ol>
<h2 id="6-最近最少使用算法-LRU"><a href="#6-最近最少使用算法-LRU" class="headerlink" title="6.最近最少使用算法 LRU"></a>6.最近最少使用算法 LRU</h2><h3 id="1-基本概念-11"><a href="#1-基本概念-11" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>设计思想：</p>
<ul>
<li><strong>选择最后一次访问时间距离当前时间最长的一页并置换。即置换<font color="red">未使用时间最长</font>的一页</strong></li>
</ul>
<p>优点：</p>
<ul>
<li><strong>性能接近OPT</strong></li>
</ul>
<p>实现:</p>
<ul>
<li><strong>时间戳或维护一个访问页的栈 → 开销大</strong></li>
</ul>
<h3 id="2-硬件实现"><a href="#2-硬件实现" class="headerlink" title="(2).硬件实现"></a>(2).硬件实现</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/37.png" style="zoom:33%;"></p>
<h2 id="7-最不经常使用算法-NFU"><a href="#7-最不经常使用算法-NFU" class="headerlink" title="7.最不经常使用算法 NFU"></a>7.最不经常使用算法 NFU</h2><p>设计思想：</p>
<ul>
<li><strong>选择访问次数最少的页面置换</strong></li>
</ul>
<p>实现:</p>
<ul>
<li><strong>软件计数器，一页一个，初值为0</strong></li>
<li><strong>每次时钟中断时，计数器加R</strong></li>
<li><strong>发生缺页中断时，选择计数器值最小的一页置换</strong></li>
</ul>
<h2 id="8-老化算法-AGING"><a href="#8-老化算法-AGING" class="headerlink" title="8.老化算法 AGING"></a>8.老化算法 AGING</h2><p>改进(模拟LRU)：<strong>计数器在加R前先右移一位，R位加到计数器的最左端</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/38.png" style="zoom:33%;"></p>
<h2 id="9-页面置换算法的应用"><a href="#9-页面置换算法的应用" class="headerlink" title="9.页面置换算法的应用"></a>9.页面置换算法的应用</h2><h3 id="1-例子"><a href="#1-例子" class="headerlink" title="(1).例子"></a>(1).例子</h3><ul>
<li><p>系统给某进程分配3个页框(固定分配策略)，初始为空</p>
</li>
<li><p>进程执行时，页面访问顺序为: 2 3 2 1 5 2 4 5 3 2 5 2 </p>
</li>
</ul>
<p>要求：</p>
<ul>
<li>计算应用FIFO、LRU、OPT算法时的缺页次数</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/39.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/40.png" style="zoom:33%;"></p>
<h3 id="2-BELADY现象"><a href="#2-BELADY现象" class="headerlink" title="(2).BELADY现象"></a>(2).BELADY现象</h3><p>例子:系统给某进程分配 m个页框，初始为空</p>
<p>页面访问顺序为：1 2 3 4 1 2 5 1 2 3 4 5</p>
<p>采用FIFO算法，计算当 m=3 和 m=4 时的缺页中断次数：</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/41.png" style="zoom:33%;"></p>
<hr>
<h1 id="十一-工作集算法"><a href="#十一-工作集算法" class="headerlink" title="十一.工作集算法"></a>十一.工作集算法</h1><h2 id="1-影响缺页次数的因素"><a href="#1-影响缺页次数的因素" class="headerlink" title="1.影响缺页次数的因素"></a>1.影响缺页次数的因素</h2><ul>
<li><strong>页面置换算法</strong></li>
<li><strong>页面本身的大小</strong> </li>
<li><strong>程序的编制方法</strong> </li>
<li><strong>分配给进程的页框数量</strong> </li>
</ul>
<p><strong><font color="red">颠簸(Thrashing，抖动) </font>：虚存中，页面在内存与磁盘之间频繁调度，使得调度页面所需的时间比进程实际运行的时间还多， 这样导致系统效率急剧下降，这种现象称为颠簸或抖动。</strong></p>
<h3 id="1-页面尺寸问题"><a href="#1-页面尺寸问题" class="headerlink" title="(1).页面尺寸问题"></a>(1).页面尺寸问题</h3><ul>
<li><strong>确定页面大小对于分页的硬件设计非常重要 而对于操作系统是个可选的参数。</strong></li>
</ul>
<blockquote>
<p>Intel80x86/Pentium:4096或4M。</p>
</blockquote>
<ul>
<li><p><strong>引用多种页面尺寸，为有效使用TLB带来灵活性，但给操作系统带来复杂性。</strong></p>
</li>
<li><p><strong>页面尺寸考虑的因素：</strong></p>
<ul>
<li><strong>内部碎片</strong></li>
<li><strong>页表长度</strong></li>
<li><strong>辅助的物理特性</strong></li>
</ul>
</li>
<li><p><strong>最优页面大小：$P = \sqrt{2se}$</strong></p>
</li>
</ul>
<h3 id="2-程序编制方法对缺页次数的影响"><a href="#2-程序编制方法对缺页次数的影响" class="headerlink" title="(2).程序编制方法对缺页次数的影响"></a>(2).程序编制方法对缺页次数的影响</h3><p>例子:分配了一个页框；页面大小为128个整数; 矩阵$A_{128 \times 128}$按行存放</p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/42.png" style="zoom:33%;"></p>
<p>左边的编制方法导致的缺页次数比右边多很多。</p>
<h3 id="3-分配给进程的页框数与缺页率的关系"><a href="#3-分配给进程的页框数与缺页率的关系" class="headerlink" title="(3).分配给进程的页框数与缺页率的关系"></a>(3).分配给进程的页框数与缺页率的关系</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/43.png" style="zoom:25%;"></p>
<h2 id="2-工作集-WORKING-SET-模型"><a href="#2-工作集-WORKING-SET-模型" class="headerlink" title="2.工作集(WORKING SET)模型"></a>2.工作集(WORKING SET)模型</h2><h3 id="1-基本思想-1"><a href="#1-基本思想-1" class="headerlink" title="(1).基本思想"></a>(1).基本思想</h3><p>根据程序的局部性原理，<strong>一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为<font color="red">活跃页面</font>，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断。如果能为进程提供与活跃页面数相等的物理页面数，则可减少缺页中断次数。</strong></p>
<ul>
<li><strong>工作集：一个进程当前正在使用的页框集合</strong></li>
</ul>
<blockquote>
<p> 工作集是需要随时调整的，所以要计算当前的一个工作集是多少。</p>
</blockquote>
<ul>
<li><strong>工作集$W (t,\Delta)$=该进程在过去的$Δ$个虚拟时间单位中访问到的页面的集合。</strong></li>
</ul>
<p>工作集内容取决于三个因素：</p>
<ul>
<li><p><strong>访页序列特性</strong></p>
</li>
<li><p><strong>时刻 t</strong></p>
</li>
<li><p><strong>工作集窗口长度 $(Δ)$</strong></p>
<blockquote>
<p>窗口越大，工作集就越大</p>
</blockquote>
</li>
</ul>
<h3 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="(2).示例"></a>(2).示例</h3><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/44.png" style="zoom:28%;"></p>
<h2 id="3-工作集算法"><a href="#3-工作集算法" class="headerlink" title="3.工作集算法"></a>3.工作集算法</h2><h3 id="1-基本思路"><a href="#1-基本思路" class="headerlink" title="(1).基本思路"></a>(1).基本思路</h3><p><strong><font color="red">找出一个不在工作集中的页面并置换它</font></strong></p>
<p>思路：</p>
<ul>
<li><p><strong>每个页表项中有一个字段：记录该页面最后一次 被访问的时间</strong></p>
</li>
<li><p><strong>设置一个时间值T</strong> </p>
</li>
<li><strong>判断：根据一个页面的访问时间是否落在 “当前时间-T”  之前或之中决定其在工作集之外还是之内</strong></li>
</ul>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="(2).实现"></a>(2).实现</h3><p>扫描所有页表项，执行操作</p>
<ol>
<li><p><strong>如果一个页面的R位是1，则将该页面的最后一 次访问时间设为当前时间，将R位清零</strong></p>
</li>
<li><p><strong>如果一个页面的R位是0，则检查该页面的访问时间是否在 “当前时间-T” 之前</strong></p>
<p><strong>(1). 如果是，则该页面为被置换的页面;</strong></p>
<p><strong>(2). 如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值。扫描下一个页面并重复1、2</strong></p>
</li>
</ol>
<h2 id="4-页面置换算法小结"><a href="#4-页面置换算法小结" class="headerlink" title="4.页面置换算法小结"></a>4.页面置换算法小结</h2><p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/45.png" style="zoom:33%;"></p>
<hr>
<h1 id="十二-内存映射文件"><a href="#十二-内存映射文件" class="headerlink" title="十二.内存映射文件"></a>十二.内存映射文件</h1><h2 id="1-基本思想-2"><a href="#1-基本思想-2" class="headerlink" title="1.基本思想"></a>1.基本思想</h2><ul>
<li><p><strong>进程通过一个系统调用(mmap)将一个文件(或部分)映射到其虚拟地址空间的一部分，<font color="red">访问这个文件就象访问内存中的一个大数组，而不是对文件进行读写</font></strong></p>
</li>
<li><p><strong>在多数实现中，在映射共享的页面时不会实际 读入页面的内容，而是在访问页面时，页面才 会被每次一页的读入，磁盘文件则被当作后备存储</strong></p>
<blockquote>
<p>是利用了虚拟存储机制中的缺页异常，来把相应文件内容读入内存的</p>
</blockquote>
</li>
<li><p><strong>当进程退出或显式地解除文件映射时，所有被修改页面会写回文件</strong></p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/46.png" style="zoom:25%;"></p>
<h2 id="2-支持写时复制技术"><a href="#2-支持写时复制技术" class="headerlink" title="2.支持写时复制技术"></a>2.支持写时复制技术</h2><p>例如:两个进程共享三个页，每页都标志成<strong>写时复制</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/17/存储模型/47.png" style="zoom:35%;"></p>
<p><strong>当某一个进程试图要改变其中一个页面的内容时，它要做一个写操作，那么和只读就产生了冲突，就会产生Page Fault。进入了操作系统后，操作系统检查出它是一个写时复制操作，就会在内存里另开辟一个页面把相应的内容写到这个页面里。而新复制的这个页面对于执行写操作的这个进程来讲是一个私有的，对于其他的进程是共享写时复制页面的进程，看不到这样一个结果。这是写时复制技术的一个基本的实现。</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>存储模型</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2020/08/20/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-文件与文件系统"><a href="#一-文件与文件系统" class="headerlink" title="一.文件与文件系统"></a>一.文件与文件系统</h1><h2 id="1-文件的基本概念"><a href="#1-文件的基本概念" class="headerlink" title="1.文件的基本概念"></a>1.文件的基本概念</h2><p>文件是<strong>对磁盘的抽象。</strong> <strong>所谓文件是指<font color="red">一组带标识(标识即为文件名) 的、在逻辑上有完整意义的信息项的序列。</font></strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/1.png" style="zoom:33%;"></p>
<p><strong>信息项：构成文件内容的基本单位(单个字节， 或多个字节)，各信息项之间具有顺序关系</strong></p>
<p><strong>文件内容的意义:由文件建立者和使用者解释</strong></p>
<blockquote>
<p>要去读文件去写文件，<strong>需要定位读写指针</strong>，因此对于这样一个信息项的序列会有一个读写指针指到某一个具体的信息项。</p>
</blockquote>
<h2 id="2-设计文件系统分析"><a href="#2-设计文件系统分析" class="headerlink" title="2.设计文件系统分析"></a>2.设计文件系统分析</h2><h3 id="1-从操作系统角度"><a href="#1-从操作系统角度" class="headerlink" title="(1).从操作系统角度"></a>(1).从操作系统角度</h3><p>怎样组织、管理文件?</p>
<ul>
<li><strong>文件的描述、分类</strong></li>
<li><strong>文件目录的实现</strong></li>
<li><strong>存储空间的管理</strong></li>
<li><strong>文件的物理地址</strong></li>
<li><strong>磁盘实际运作方式(与设备管理的接口)</strong></li>
<li><strong>文件系统性能</strong> </li>
<li>等等</li>
</ul>
<h3 id="2-从用户角度"><a href="#2-从用户角度" class="headerlink" title="(2).从用户角度"></a>(2).从用户角度</h3><p>文件系统如何呈现在用户面前:</p>
<ul>
<li><strong>一个文件的组织</strong></li>
<li><strong>如何命名?</strong></li>
<li><strong>如何保护文件?</strong></li>
<li><p><strong>可以实施的操作?</strong></p>
</li>
<li><p>等等</p>
</li>
</ul>
<h2 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>操作系统中统一管理信息资源的一种软件，管理 文件的存储、检索、更新，提供安全可靠的共享 和保护手段，并且方便用户使用。</p>
<h3 id="2-需要完成的任务"><a href="#2-需要完成的任务" class="headerlink" title="(2).需要完成的任务"></a>(2).需要完成的任务</h3><ul>
<li><strong>统一管理磁盘空间，实施磁盘空间的分配与回收</strong></li>
<li><strong>实现文件的按名存取</strong><ul>
<li><strong>名字空间 ——&gt; 磁盘空间</strong></li>
</ul>
</li>
<li><strong>实现文件信息的共享，并提供文件的保护、保密手段</strong></li>
<li><strong>向用户提供一个方便使用、易于维护的接口，并向用户提供有关统计信息</strong></li>
<li><strong>提高文件系统的性能</strong></li>
<li><strong>提供与I/O系统的统一接口</strong></li>
</ul>
<h2 id="4-文件的分类"><a href="#4-文件的分类" class="headerlink" title="4.文件的分类"></a>4.文件的分类</h2><p>按文件性质和用途分类(UNIX)：普通文件；目录文件；特殊文件(设备文件)；管道文件；套接字</p>
<p><strong>普通文件(regular)</strong> </p>
<blockquote>
<p>包含了用户的信息，一般为ASCII或二进制文件</p>
</blockquote>
<p><strong>目录文件(directory)</strong> </p>
<blockquote>
<p> 管理文件系统的系统文件</p>
</blockquote>
<p><strong>特殊文件(special file)</strong> </p>
<blockquote>
<ul>
<li><strong>字符设备文件：</strong>和输入输出有关，用于模仿串行I/O设备，例如终端，打印机，网卡等 </li>
<li><strong>块设备文件：</strong>磁盘</li>
</ul>
</blockquote>
<h2 id="5-文章的逻辑结构"><a href="#5-文章的逻辑结构" class="headerlink" title="5.文章的逻辑结构"></a>5.文章的逻辑结构</h2><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>从用户角度看文件，由用户的访问方式确定</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/2.png" style="zoom:33%;"></p>
<ul>
<li><p>a以一个字节为单位,把文件看成是一个字节的序列。这是非常典型一个流式结构文件 </p>
</li>
<li><p>b以记录为单位，一个记录由若干个字节组成，因此文件信息项的单位就是记录</p>
</li>
<li>c把文件组织成树形结构</li>
</ul>
<blockquote>
<p>还可以组织成堆、顺序、索引、索引顺序、散列等结构</p>
</blockquote>
<h3 id="2-典型的文件逻辑结构与文件存取"><a href="#2-典型的文件逻辑结构与文件存取" class="headerlink" title="(2).典型的文件逻辑结构与文件存取"></a>(2).典型的文件逻辑结构与文件存取</h3><h4 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h4><ul>
<li><strong>流式文件：构成文件的基本单位是字符</strong> </li>
</ul>
<blockquote>
<p> 文件是有逻辑意义、无结构的一串字符的集合</p>
</blockquote>
<ul>
<li><strong>记录式文件：文件由若干个记录组成，可以按记录进行读、写、查找等操作</strong></li>
</ul>
<blockquote>
<p> 每条记录有其内部结构</p>
</blockquote>
<h4 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h4><ul>
<li><strong>顺序存取(访问)</strong> </li>
<li><strong>随机存取(访问)</strong><ul>
<li><strong>提供读写位置(当前位置)</strong> </li>
<li>例如:UNIX的seek操作</li>
</ul>
</li>
</ul>
<hr>
<h1 id="二-文件的存储介质"><a href="#二-文件的存储介质" class="headerlink" title="二.文件的存储介质"></a>二.文件的存储介质</h1><h2 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>典型的存储介质：</strong>磁盘(包括固态盘SSD)、磁带、光盘、U盘、……</p>
<blockquote>
<p>文件的信息保存在这些存储介质上，通常是以一个独立单位来进行信息的存储传输和分配。 而这个独立单位就是物理块。</p>
</blockquote>
<p><strong>物理块(块block、簇cluster)</strong></p>
<ul>
<li><strong>信息存储、传输、分配的独立单位</strong></li>
<li><strong>存储设备划分为大小相等的物理块，统一编号</strong></li>
</ul>
<h2 id="2-典型的磁盘结构"><a href="#2-典型的磁盘结构" class="headerlink" title="2.典型的磁盘结构"></a>2.典型的磁盘结构</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/3.png" style="zoom:40"></p>
<ul>
<li><p>一块盘若干个盘片组成，每个盘片上有两个盘面 </p>
</li>
<li><p>每一个盘面的信息读取都需要一个读写磁头，若干个读写磁头固定在了一个磁臂上。由磁臂带动的这些磁头沿着半径的方向进行移动。 </p>
</li>
<li><p>在盘面上有若干个同心圆，称之为磁道。 在磁道上存放信息。</p>
</li>
<li><p>把磁道划分成很多段，每一段称之为扇区。 信息实际上是存放在每一个扇区里</p>
</li>
</ul>
<p><strong>任何时刻只有一个磁头处于活动状态：输入输出数据流以位串形式出现</strong></p>
<p><strong>物理地址形式: 磁头号(盘面号)、磁道号(柱面号)、扇区号</strong></p>
<blockquote>
<ul>
<li><p>扇区：标题(10字节)、数据(512字节)、ECC纠错信息(12-16字节)</p>
</li>
<li><p>通常所说的一个扇区是 512 字节，其实是说存放的信息或者存放的数据是 512 字节，其实还有其他信息</p>
</li>
</ul>
</blockquote>
<h2 id="3-磁盘访问"><a href="#3-磁盘访问" class="headerlink" title="3.磁盘访问"></a>3.磁盘访问</h2><p>一次访盘请求所需要给出的参数: </p>
<ul>
<li><strong>读/写操作</strong></li>
<li><strong>磁盘地址(设备号，柱面号，磁头号，扇区号)</strong></li>
<li><strong>内存地址(源/目)</strong></li>
</ul>
<p>完成一次访盘请求的过程由三个动作组成：</p>
<ul>
<li><strong>寻道(时间)：</strong>磁头移动定位到指定磁道</li>
<li><p><strong>旋转延迟(时间)：</strong>等待指定扇区从磁头下旋转经过</p>
</li>
<li><p><strong>数据传输(时间)：</strong>数据在磁盘与内存之间的实 际传输</p>
</li>
</ul>
<hr>
<h1 id="三-磁盘空间管理"><a href="#三-磁盘空间管理" class="headerlink" title="三.磁盘空间管理"></a>三.磁盘空间管理</h1><h2 id="1-有关数据结构"><a href="#1-有关数据结构" class="headerlink" title="1.有关数据结构"></a>1.有关数据结构</h2><h3 id="1-位图法"><a href="#1-位图法" class="headerlink" title="(1).位图法"></a>(1).位图法</h3><ul>
<li><p><strong>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为0，否则为1</strong></p>
</li>
<li><p><strong>申请物理块时，可以在位示图中查找为1的位，返 回对应物理块号</strong></p>
</li>
<li><strong>归还时，将对应位转置1</strong></li>
</ul>
<h3 id="2-空闲块表"><a href="#2-空闲块表" class="headerlink" title="(2).空闲块表"></a>(2).空闲块表</h3><ul>
<li><strong>将所有空闲块记录在一个表中，即空闲块表</strong> </li>
<li><strong>主要两项内容：起始块号，块数</strong></li>
</ul>
<h3 id="3-空闲块链表"><a href="#3-空闲块链表" class="headerlink" title="(3).空闲块链表"></a>(3).空闲块链表</h3><ul>
<li><strong>把所有空闲块链成一个链</strong> </li>
<li><strong>扩展:成组链接法</strong></li>
</ul>
<h2 id="2-磁盘地址与块号的转换"><a href="#2-磁盘地址与块号的转换" class="headerlink" title="2.磁盘地址与块号的转换"></a>2.磁盘地址与块号的转换</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/4.png" style="zoom:30%;"></p>
<p>位图计算公式：</p>
<p><strong>已知字号i、位号j ：</strong>$块 号 = i × 字 长 + j$ </p>
<p><strong>已知块号：</strong>$字 号 = [ 块 号 / 字 长 ]   位 号 = 块 号\quad mod\quad 字 长$</p>
<h2 id="3-成组链接法设计思想"><a href="#3-成组链接法设计思想" class="headerlink" title="3.成组链接法设计思想"></a>3.成组链接法设计思想</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/5.png" style="zoom:33%;"></p>
<p>在专用块里有若干个字段，第一个字段存放了第一组的空闲块的块数，所以空闲块块数现在是二十。接着的各个字段就把二十个空闲块的块号记录在了每一个字段里头。一个文件想获取一个新的空闲块就从专用块来挑选空闲块，挑选时是从下往上挑选。 如果先分配的话，一定是801这一块，然后接着分配802这一块，最后才分配820这一块。 </p>
<h3 id="1-成组链接法—分配算法"><a href="#1-成组链接法—分配算法" class="headerlink" title="(1).成组链接法—分配算法"></a>(1).成组链接法—分配算法</h3><p>查L单元(空闲块数):</p>
<ul>
<li><p>当空闲块数&gt;1 ，i=L+空闲块数;</p>
<ul>
<li>从 i 单元得到一个空闲块号;</li>
<li>把该块分配给申请者;</li>
<li>空闲块数减1;</li>
</ul>
</li>
<li><p>当空闲块数=1 取出L+1单元内容(一组的第一块块号或0);</p>
<ul>
<li>其值=0 无空闲块，申请者等待 </li>
<li>其值不等于零，把该块内容复制到专用块;</li>
<li>该块分配给申请者;</li>
</ul>
</li>
</ul>
<p>把专用块内容读到内存L开始的区域</p>
<h3 id="2-成组链接法—回收算法"><a href="#2-成组链接法—回收算法" class="headerlink" title="(2).成组链接法—回收算法"></a>(2).成组链接法—回收算法</h3><p>归还一块:</p>
<p>查L单元的空闲块数; </p>
<ul>
<li><p>当空闲块数&lt;100 空闲块数加1;</p>
<ul>
<li>j:= L+空闲块数; </li>
<li>归还块号填入j单元。</li>
</ul>
</li>
<li><p>当空闲块数=100，则把内存中登记的信息写入归还块中;</p>
<ul>
<li>把归还块号填入L+1单元; </li>
<li>将L单元置成1。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四-文件控制块及文件目录"><a href="#四-文件控制块及文件目录" class="headerlink" title="四.文件控制块及文件目录"></a>四.文件控制块及文件目录</h1><blockquote>
<p> 操作系统为了管理文件会把文件的各种属性都记录下来。因此这些属性是操作系统管理文件所需要的信息，按照之前对进程的设计， 把文件属性所存放的这些信息称为文件控制块。 </p>
</blockquote>
<h2 id="1-文件属性"><a href="#1-文件属性" class="headerlink" title="1.文件属性"></a>1.文件属性</h2><h3 id="1-文件控制块-File-Control-Block"><a href="#1-文件控制块-File-Control-Block" class="headerlink" title="(1).文件控制块(File Control Block)"></a>(1).文件控制块(File Control Block)</h3><p><strong>为管理文件而设置的数据结构，保存管理文件所 需的所有有关信息</strong>。(有时称为<strong>文件属性</strong>或<strong>元数据</strong>)</p>
<h3 id="2-常用属性"><a href="#2-常用属性" class="headerlink" title="(2).常用属性"></a>(2).常用属性</h3><p>文件名，文件号，文件大小，文件地址，创建时 间，最后修改时间，最后访问时间，保护，口令，创建者，当前拥有者，文件类型，共享计数，各种标志(只读、隐藏、系统、归档、ASCII/二进制、 顺序/随机访问、临时文件、锁)</p>
<h2 id="2-文件目录-目录项和目录文件"><a href="#2-文件目录-目录项和目录文件" class="headerlink" title="2.文件目录,目录项和目录文件"></a>2.文件目录,目录项和目录文件</h2><h3 id="1-文件目录"><a href="#1-文件目录" class="headerlink" title="(1).文件目录"></a>(1).文件目录</h3><ul>
<li><p><strong>文件目录是操作系统中<font color="red">统一管理每个文件的元数据</font>，以支持文件名到文件物理地址的转换。</strong></p>
</li>
<li><p><strong><font color="red">将所有文件的管理信息组织在一起</font>，即构成文件目录</strong></p>
</li>
</ul>
<h3 id="2-目录文件"><a href="#2-目录文件" class="headerlink" title="(2).目录文件"></a>(2).目录文件</h3><ul>
<li><strong>将文件目录将所有文件的管理信息组织在一起后，<font color="red">以文件的形式存放在磁盘上</font>，这个文件的内容是文件目录。</strong></li>
</ul>
<h3 id="3-目录项"><a href="#3-目录项" class="headerlink" title="(3).目录项"></a>(3).目录项</h3><ul>
<li><p><strong>构成文件目录的基本单元</strong></p>
</li>
<li><p><strong>目录项可以是FCB，<font color="red">目录是文件控制块的有序集合</font></strong></p>
</li>
</ul>
<h2 id="3-文件目录结构的演化"><a href="#3-文件目录结构的演化" class="headerlink" title="3.文件目录结构的演化"></a>3.文件目录结构的演化</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/6.png" style="zoom:30%;"></p>
<h2 id="4-与目录相关的概念"><a href="#4-与目录相关的概念" class="headerlink" title="4.与目录相关的概念"></a>4.与目录相关的概念</h2><h3 id="1-一些基本概念"><a href="#1-一些基本概念" class="headerlink" title="(1).一些基本概念"></a>(1).一些基本概念</h3><ul>
<li><p><strong>路径名(文件名)</strong></p>
<ul>
<li><strong>绝对路径名：从根目录开始</strong></li>
<li><strong>相对路径名：从当前目录开始</strong></li>
</ul>
</li>
<li><p><strong>当前目录/工作目录</strong></p>
<ul>
<li><strong>当前进程正在使用的目录。</strong></li>
</ul>
</li>
<li><p><strong>目录操作</strong></p>
<ul>
<li><strong>创建目录、删除目录</strong></li>
<li><strong>读目录、写目录、改名、复制</strong></li>
</ul>
</li>
</ul>
<h3 id="2-目录文件的关联"><a href="#2-目录文件的关联" class="headerlink" title="(2).目录文件的关联"></a>(2).目录文件的关联</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/7.png" style="zoom:33%;"></p>
<p>这是一个根目录文件，目录文件是由若干目录项组成的，可以看到这里有ABC 三个目录项，通过这个目录项，找到目录项所对应的文件。</p>
<hr>
<h1 id="五-文件的物理结构"><a href="#五-文件的物理结构" class="headerlink" title="五.文件的物理结构"></a>五.文件的物理结构</h1><h2 id="1-基本概念-3"><a href="#1-基本概念-3" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p><strong>是指文件在存储介质上的存放方式。</strong></p>
<p>主要解决两个问题:</p>
<ul>
<li><p><strong>假设一个文件被划分成N块，这N块在磁盘上是怎么存放的?</strong></p>
</li>
<li><p><strong>存放之后，其地址(块号或簇号)在FCB中是怎样记录的?</strong></p>
</li>
</ul>
<h2 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.顺序结构"></a>2.顺序结构</h2><h3 id="1-基本概念-4"><a href="#1-基本概念-4" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p><strong>是指文件的信息<font color="red">存放在若干连续的物理块</font>中。</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/8.png" style="zoom:40%;"></p>
<p>在FCB中如何记录文件地址?</p>
<ul>
<li><strong>文件第一块块号</strong></li>
<li><strong>文件的长度</strong></li>
</ul>
<p>给出这两个信息就能知道文件中的任意一块的地址。</p>
<h3 id="2-连续结构的优缺点"><a href="#2-连续结构的优缺点" class="headerlink" title="(2).连续结构的优缺点"></a>(2).连续结构的优缺点</h3><ul>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>简单</strong></li>
<li><strong>支持顺序存取和随机存取</strong></li>
<li><strong>所需的磁盘寻道次数和寻道时间最少</strong></li>
<li><strong>可以同时读入多个块，检索一个块也很容易</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>文件不能动态增长</strong><ul>
<li>解决办法：<strong>预留空间:浪费 或 重新分配和移动</strong></li>
</ul>
</li>
<li><strong>不利于文件插入和删除</strong></li>
<li><strong>外部碎片:紧缩技术</strong></li>
</ul>
</li>
</ul>
<h2 id="2-链接结构"><a href="#2-链接结构" class="headerlink" title="2.链接结构"></a>2.链接结构</h2><h3 id="1-基本概念-5"><a href="#1-基本概念-5" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p><strong>一个文件的信息存放在若干不连续的物理块中， 各块之间通过指针连接，前一个物理块指向下一个物理块。</strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/9.png" style="zoom:40%;"></p>
<p>在FCB中如何记录文件地址?</p>
<ul>
<li><strong>只需要知道第一块的地址即可。</strong></li>
</ul>
<h3 id="2-链接结构的优缺点"><a href="#2-链接结构的优缺点" class="headerlink" title="(2).链接结构的优缺点"></a>(2).链接结构的优缺点</h3><ul>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>提高了磁盘空间利用率，不存在外部碎片问题</strong></li>
<li><strong>有利于文件插入和删除</strong></li>
<li><strong>有利于文件动态扩充</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>存取速度慢，不适于随机存取</strong> </li>
<li><strong>可靠性问题，如指针出错</strong></li>
<li><strong>更多的寻道次数和寻道时间</strong></li>
<li><strong>链接指针占用一定的空间</strong></li>
</ul>
</li>
</ul>
<p><strong>链接结构的一个变形: <font color="red">文件分配表 FAT</font></strong></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/10.png" style="zoom:33%;"></p>
<p>把所有指针存放在一个文件中。</p>
<ul>
<li><p>表项的值有三种<strong>：0，下一块块号，-1</strong></p>
</li>
<li><p>某文件的起始块号从何处得到？<strong>记录在FCB中。</strong></p>
</li>
</ul>
<h2 id="3-索引结构"><a href="#3-索引结构" class="headerlink" title="3.索引结构"></a>3.索引结构</h2><h3 id="1-基本概念-6"><a href="#1-基本概念-6" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li>一个文件的信息存放在若干不连续物理块中。</li>
<li>系统为每个文件建立一个专用数据结构—索引表， 并将这些物理块的块号存放在该索引表中。</li>
<li>索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</li>
</ul>
<p>在FCB中如何记录文件地址?</p>
<p>索引表存放在何处?</p>
<h3 id="2-索引结构示意"><a href="#2-索引结构示意" class="headerlink" title="(2).索引结构示意"></a>(2).索引结构示意</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/11.png" style="zoom:35%;"></p>
<p>索引表会放在某一个物理块中，这个物理块就是索引块。索引块中就存放着所分配给文件的物理块块号。</p>
<h3 id="3-索引结构的优缺点"><a href="#3-索引结构的优缺点" class="headerlink" title="(3).索引结构的优缺点"></a>(3).索引结构的优缺点</h3><ul>
<li><p><strong>优点</strong></p>
<blockquote>
<p>保持了链接结构的优点，又解决了其缺点</p>
</blockquote>
<ul>
<li><strong>既能顺序存取，又能随机存取</strong></li>
<li><strong>满足了文件动态增长、插入删除的要求</strong></li>
<li><strong>能充分利用磁盘空间</strong></li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li><strong>较多的寻道次数和寻道时间</strong> </li>
<li><strong>索引表本身带来了系统开销，如:内存、磁盘空间，存取时间</strong></li>
</ul>
</li>
</ul>
<h3 id="4-索引表的组织方式"><a href="#4-索引表的组织方式" class="headerlink" title="(4).索引表的组织方式"></a>(4).索引表的组织方式</h3><p>问题：<strong>索引表很大，需要多个物理块存放时怎么 办?</strong></p>
<p>解决方式：</p>
<ul>
<li><p><strong>链接方式</strong></p>
<ul>
<li><strong>一个盘块存一个索引表，多个索引表链接起来</strong></li>
</ul>
</li>
<li><p><strong>多级索引方式</strong> </p>
<ul>
<li><strong>将文件的索引表地址放在另一个索引表中</strong></li>
</ul>
</li>
<li><p><strong>综合模式</strong> </p>
<ul>
<li><strong>直接索引方式 与 间接索引方式 结合</strong></li>
</ul>
</li>
</ul>
<h3 id="5-多级索引与综合模式"><a href="#5-多级索引与综合模式" class="headerlink" title="(5).多级索引与综合模式"></a>(5).多级索引与综合模式</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/12.png" style="zoom:33%;"></p>
<h2 id="4-UNIX的三级索引结构"><a href="#4-UNIX的三级索引结构" class="headerlink" title="4.UNIX的三级索引结构"></a>4.UNIX的三级索引结构</h2><p>UNIX文件系统采用的是多级索引结构(综合模式)</p>
<ul>
<li><p>每个文件的索引表有15个索引项，每项2个字节</p>
</li>
<li><p>前12项直接存放文件的物理块号(直接寻址)</p>
</li>
<li><p>如果文件大于12块，则利用第13项指向一个物理块， 在该块中存放文件物理块的块号(一级索引表)</p>
<ul>
<li>假设扇区大小为512字节，物理块等于扇区块大小，一 级索引表可以存放256个物理块号</li>
</ul>
</li>
<li><p>对于更大的文件还可利用第14和第15项作为二级和三级索引表</p>
</li>
</ul>
<p>试问:采用这种结构，一个文件最大可达到 ?个物理块</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/13.png" style="zoom:30%;"></p>
<hr>
<h1 id="六-文件系统的实现"><a href="#六-文件系统的实现" class="headerlink" title="六.文件系统的实现"></a>六.文件系统的实现</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p><strong>实现文件系统需要考虑<font color="red">磁盘上</font>与<font color="red">内存中</font>的内容布局。</strong></p>
<h3 id="1-磁盘上"><a href="#1-磁盘上" class="headerlink" title="(1).磁盘上"></a>(1).磁盘上</h3><ul>
<li>如何启动操作系统?</li>
<li>磁盘是怎样管理的?怎样获取磁盘的有关信息? </li>
<li>目录文件在磁盘上怎么存放?普通文件在磁盘上怎么存放?</li>
</ul>
<h3 id="2-内存中"><a href="#2-内存中" class="headerlink" title="(2).内存中"></a>(2).内存中</h3><ul>
<li>当进程使用文件时，操作系统是如何支持的? 也就是文件系统的内存数据结构。</li>
</ul>
<h2 id="2-相关术语"><a href="#2-相关术语" class="headerlink" title="2.相关术语"></a>2.相关术语</h2><ul>
<li><p><strong>磁盘分区(partition)：</strong>把一个<font color="red">物理磁盘</font>的存储空间划分为几个相互独立的部分，称为<font color="red">分区</font></p>
</li>
<li><p><strong>文件卷(volume)</strong>：磁盘上的逻辑分区，由一个或多个物 理块(簇)组成</p>
<ul>
<li>一个文件卷可以是<strong>整个磁盘</strong>或<strong>部分磁盘</strong>或<strong>跨盘(RAID)</strong> </li>
<li>同一个文件卷中<font color="red">使用同一份管理数据</font>进行文件<font color="red">分配和磁盘空闲空间管理</font>，不同的文件卷中的管理数据是相互独立的</li>
<li>一个文件卷上：包括<strong>文件系统信息</strong>、<strong>一组文件(</strong>用户文件、 目录文件)、<strong>未分配空间</strong></li>
<li><strong>块(Block)</strong>或 <strong>簇(Cluster)</strong> : 一个或多个(2的幂)连续的扇区，可寻址数据块</li>
</ul>
</li>
<li><p><strong>格式化(format)：</strong>在<strong>一个文件卷上建立文件系统</strong>，即建立并初始化用于文件分配和磁盘空闲空间管理的管理数据——元数据</p>
</li>
</ul>
<h2 id="3-磁盘上的内容"><a href="#3-磁盘上的内容" class="headerlink" title="3.磁盘上的内容"></a>3.磁盘上的内容</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/14.png" style="zoom:30%;"></p>
<p>存放的内容：</p>
<ul>
<li><p><strong>引导区</strong> </p>
<ul>
<li>包括了从该卷引导操作系统所需要的信息</li>
<li>每个卷(分区)一个，通常为第一个扇区</li>
</ul>
</li>
<li><p><strong>卷(分区)信息</strong> </p>
<ul>
<li>包括该卷(分区)的块(簇)数、块(簇)大小、空闲块(簇)数量和指针、空闲FCB数量和指针…… </li>
</ul>
</li>
<li><p><strong>目录文件</strong>(根目录文件及其他目录文件)</p>
</li>
<li><p><strong>用户文件</strong></p>
</li>
</ul>
<h2 id="4-磁盘上文件系统的布局"><a href="#4-磁盘上文件系统的布局" class="headerlink" title="4.磁盘上文件系统的布局"></a>4.磁盘上文件系统的布局</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/15.png" style="zoom:30%;"></p>
<h2 id="5-内存中所需的数据结构——以UNIX为例"><a href="#5-内存中所需的数据结构——以UNIX为例" class="headerlink" title="5.内存中所需的数据结构——以UNIX为例"></a>5.内存中所需的数据结构——以UNIX为例</h2><ul>
<li><strong>系统打开文件表</strong><ul>
<li>整个系统一张</li>
<li>放在内存：用于保存已打开文件的FCB</li>
</ul>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/16.png" style="zoom:33%;"></p>
<ul>
<li><strong>用户打开文件表</strong><ul>
<li>每个进程一个</li>
<li>进程的PCB中记录了用户打开文件表的位置</li>
</ul>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/17.png" style="zoom:33%;"></p>
<hr>
<h1 id="七-文件系统实例——UNIX"><a href="#七-文件系统实例——UNIX" class="headerlink" title="七.文件系统实例——UNIX"></a>七.文件系统实例——UNIX</h1><h2 id="1-文件目录检索"><a href="#1-文件目录检索" class="headerlink" title="1.文件目录检索"></a>1.文件目录检索</h2><p>访问一个文件时，用户通常给出一个文件名，通过使用文件名把文件的内容读入内存通常具有两个步骤：</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/18.png" style="zoom:33%;"></p>
<ul>
<li><p><strong>目录检索</strong></p>
<ul>
<li><strong>用户给出文件名 → 按文件名查找到目录项/FCB</strong></li>
<li><strong>根据路径名检索:</strong><ul>
<li><strong>全路径名:</strong>从根开始 \A\B\C\File1 </li>
<li><strong>相对路径:</strong>从当前目录开始 C\File1</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>文件寻址</strong></p>
<ul>
<li>根据目录项/FCB中文件物理地址等信息，计算出文件中任意记录或字符在存储介质上的地址</li>
</ul>
</li>
</ul>
<h2 id="2-目录文件实现时的改进"><a href="#2-目录文件实现时的改进" class="headerlink" title="2.目录文件实现时的改进"></a>2.目录文件实现时的改进</h2><h3 id="1-基本概念-7"><a href="#1-基本概念-7" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li>问题：如何加快目录检索?</li>
<li>一种解决方案：<ul>
<li><strong>目录项分解法：</strong>即把FCB分成两部分<ul>
<li><strong>符号目录顶：</strong>文件名，文件号</li>
<li><strong>基本目录项：</strong>除文件名外的所有字段——UNIX的I节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-示意图"><a href="#2-示意图" class="headerlink" title="(2).示意图"></a>(2).示意图</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/19.png" style="zoom:33%;"></p>
<h3 id="3-改进后的好处"><a href="#3-改进后的好处" class="headerlink" title="(3).改进后的好处"></a>(3).改进后的好处</h3><p>例子:</p>
<p>假设 一个FCB 占 48 个字节，物理块大小 512 字节</p>
<ul>
<li><p>符号目录项：占 8 字节(文件名6字节，文件号2字节) </p>
</li>
<li><p>基本目录项：占48–6=42字节</p>
</li>
<li><p>一个目录文件有128个目录项</p>
</li>
</ul>
<p>分解前：占13块 </p>
<p>分解后：符号文件占 2 块，基本文件占11块</p>
<p>查找一个文件的平均访盘次数:</p>
<ul>
<li><p><strong>分解前:7次</strong></p>
</li>
<li><p><strong>分解后:2.5次</strong></p>
</li>
</ul>
<p><strong>目录文件改进后减少了访盘次数，提高了文件检索速度</strong></p>
<h2 id="3-UNIX文件系统"><a href="#3-UNIX文件系统" class="headerlink" title="3.UNIX文件系统"></a>3.UNIX文件系统</h2><ul>
<li><p>FCB划分成两部分：目录项+i节点</p>
<ul>
<li><p>目录项:文件名+i节点号</p>
</li>
<li><p>目录文件由目录项构成</p>
</li>
<li><p>i节点:描述文件的相关信息</p>
</li>
</ul>
</li>
<li><p>UNIX每个文件由一个目录项、一个i节点和若干磁盘块构成。</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/20.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/2·.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/21.png" style="zoom:33%;"></p>
<hr>
<h1 id="八-文件系统实例——FAT"><a href="#八-文件系统实例——FAT" class="headerlink" title="八.文件系统实例——FAT"></a>八.文件系统实例——FAT</h1><h2 id="1-WINDOWS—FAT16文件系统"><a href="#1-WINDOWS—FAT16文件系统" class="headerlink" title="1.WINDOWS—FAT16文件系统"></a>1.WINDOWS—FAT16文件系统</h2><ul>
<li>簇大小：1、2、4、8、16、32或64扇区</li>
<li>文件系统的数据记录在”引导扇区”中</li>
<li>文件分配表FAT的作用<ul>
<li>描述簇的分配状态、标注下一簇的簇号等</li>
</ul>
</li>
<li><p>FAT表项：2字节</p>
</li>
<li><p>目录项：32字节</p>
</li>
<li>根目录大小固定</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/22.png" style="zoom:33%;"></p>
<h2 id="2-FAT文件系统"><a href="#2-FAT文件系统" class="headerlink" title="2.FAT文件系统"></a>2.FAT文件系统</h2><h3 id="1-MBR"><a href="#1-MBR" class="headerlink" title="(1).MBR"></a>(1).MBR</h3><p>主引导记录通常放在0号扇区。</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/23.png" style="zoom:33%;"></p>
<h3 id="2-DBR"><a href="#2-DBR" class="headerlink" title="(2).DBR"></a>(2).DBR</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/24.png" style="zoom:33%;"></p>
<h2 id="3-引导扇区"><a href="#3-引导扇区" class="headerlink" title="3.引导扇区"></a>3.引导扇区</h2><h3 id="1-BIOS参数块"><a href="#1-BIOS参数块" class="headerlink" title="(1).BIOS参数块"></a>(1).BIOS参数块</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/25.png" style="zoom:33%;"></p>
<h3 id="2-扩展BIOS参数块-EBPB"><a href="#2-扩展BIOS参数块-EBPB" class="headerlink" title="(2).扩展BIOS参数块(EBPB)"></a>(2).扩展BIOS参数块(EBPB)</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/26.png" style="zoom:34%;"></p>
<h2 id="4-文件分配表FAT"><a href="#4-文件分配表FAT" class="headerlink" title="4.文件分配表FAT"></a>4.文件分配表FAT</h2><ul>
<li><p>可以把文件分配表看成是一个整数数组，每个整数代表磁盘分区的一个簇号</p>
</li>
<li><p>状态 </p>
<ul>
<li>未使用、坏簇、系统保留、被文件占用(下一簇簇号)、最后一簇(0xFFFF)</li>
</ul>
</li>
<li>簇号从0开始编号，簇0和簇1是保留的</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/27.png" style="zoom:33%;"></p>
<h2 id="5-FAT16目录项"><a href="#5-FAT16目录项" class="headerlink" title="5.FAT16目录项"></a>5.FAT16目录项</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/28.png" style="zoom:33%;"></p>
<h2 id="6-FAT32-文件系统"><a href="#6-FAT32-文件系统" class="headerlink" title="6.FAT32 文件系统"></a>6.FAT32 文件系统</h2><h3 id="1-基本概念-8"><a href="#1-基本概念-8" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><ul>
<li>FAT32的根目录区(ROOT区)不是固定区域、固定大小，而是数据区的一部分，采用与子目录文件相同的管理方式</li>
<li>目录项仍占32字节，但分为各种类型(包括:“.”目 录项、“..”目录项、短文件名目录项、长文件名目录项、卷标项(根目录)、已删除目录项(第一字节为0xE5)等)</li>
<li>支持长文件名格式</li>
<li>支持Unicode</li>
<li>不支持高级容错特性，不具有内部安全特性</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/29.png" style="zoom:33%;"></p>
<h3 id="2-目录项"><a href="#2-目录项" class="headerlink" title="(2).目录项"></a>(2).目录项</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/31.png" style="zoom:50%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/30.png" style="zoom:33%;"></p>
<h3 id="3-一般长文件名的实现方式"><a href="#3-一般长文件名的实现方式" class="headerlink" title="(3).一般长文件名的实现方式"></a>(3).一般长文件名的实现方式</h3><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/32.png" style="zoom:33%;"></p>
<p>FAT32——长文件名的目录项格式</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/33.png" style="zoom:33%;"></p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/34.png" style="zoom:33%;"></p>
<h2 id="7-Windows例子"><a href="#7-Windows例子" class="headerlink" title="7.Windows例子"></a>7.Windows例子</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/35.png" style="zoom:33%;"></p>
<p>Windows为其建立了五个目录项、四个保存长文件名、一个保存压缩文件名THEQUI~1。</p>
<hr>
<h1 id="九-文件操作的实现"><a href="#九-文件操作的实现" class="headerlink" title="九.文件操作的实现"></a>九.文件操作的实现</h1><h2 id="1-操作的实现"><a href="#1-操作的实现" class="headerlink" title="1.操作的实现"></a>1.操作的实现</h2><h3 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="(1).创建文件"></a>(1).创建文件</h3><p><strong>建立系统与文件的联系，实质是建立文件的FCB。</strong></p>
<ul>
<li><p>在目录中为新文件建立一个目录项，根据提供的参数及需要填写相关内容</p>
</li>
<li><p>分配必要的存储空间</p>
</li>
</ul>
<h3 id="2-打开文件"><a href="#2-打开文件" class="headerlink" title="(2).打开文件"></a>(2).打开文件</h3><p>根据文件名在文件目录中检索，并将该文件的目录项读入内存，建立相应的数据结构，为后续的文件操作做好准备。</p>
<blockquote>
<p> 文件描述符/文件句柄</p>
</blockquote>
<h2 id="2-文件操作——建立文件"><a href="#2-文件操作——建立文件" class="headerlink" title="2.文件操作——建立文件"></a>2.文件操作——建立文件</h2><p><strong>create(文件名，访问权限)。</strong></p>
<ol>
<li><p>检查参数的合法性</p>
<blockquote>
<p>例如:文件名是否符合命名规则；有无重名文件;</p>
<p>合法→2，否则→报错、返回</p>
</blockquote>
</li>
<li><p>申请空闲目录项，并填写相关内容;</p>
</li>
<li>为文件申请磁盘块</li>
<li>返回</li>
</ol>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/36.png" style="zoom:35%;"></p>
<h2 id="3-文件操作——打开文件"><a href="#3-文件操作——打开文件" class="headerlink" title="3.文件操作——打开文件"></a>3.文件操作——打开文件</h2><p><strong>打开文件是为文件读写做准备。</strong></p>
<p>给出文件路径名，获得文件句柄(file handle)或文件描述 符(file descriptor)，需将该文件的目录项读到内存</p>
<blockquote>
<p> fd=open(文件路径名，打开方式)</p>
</blockquote>
<ol>
<li><p>根据文件路径名查目录，找到目录项 (或I节点号) ;</p>
</li>
<li><p>根据文件号查系统打开文件表，看文件是否已被打开;</p>
<blockquote>
<p> 是 → 共享计数加1<br> 否则 → 将目录项 (或I节点)等信息填入系统打开文件 表空表项，共享计数置为1;</p>
</blockquote>
</li>
<li><p>根据打开方式、共享说明和用户身份检查访问合法性; </p>
</li>
<li><p>在用户打开文件表中获取一空表项，填写打开方式等，并指向系统打开文件表对应表项</p>
<blockquote>
<p> 返回信息:fd:文件描述符，是一个非负整数，用于以 后读写文件</p>
</blockquote>
</li>
</ol>
<h2 id="4-文件操作——指针定位"><a href="#4-文件操作——指针定位" class="headerlink" title="4.文件操作——指针定位"></a>4.文件操作——指针定位</h2><blockquote>
<p>seek(fd, 新指针的位置)</p>
</blockquote>
<p><strong>系统为每个进程打开的每个文件维护一个读写指针，即相对于文件开头的偏移地址</strong>(读写指针指向每次文件读写的开始位置，在每次读写完成后， 读写指针按照读写的数据量自动后移相应数值)</p>
<ol>
<li><p>由fd查用户打开文件表，找到对应的表项;</p>
</li>
<li><p>将用户打开文件表中文件读写指针位置设为新指针的位置，供后继读写命令存取该指针处文件内容。</p>
</li>
</ol>
<h2 id="5-文件操作——读文件"><a href="#5-文件操作——读文件" class="headerlink" title="5.文件操作——读文件"></a>5.文件操作——读文件</h2><blockquote>
<p>read(文件描述符，读指针，要读的长度，内存目的地址)</p>
</blockquote>
<ol>
<li><p>根据打开文件时得到的文件描述符，找到相应的文件控制块(目录项) </p>
<blockquote>
<p>确定读操作的合法性 </p>
<p>读操作合法→2，</p>
<p>否则→出错处理 </p>
<p>问题:文件尚未打开?</p>
</blockquote>
</li>
<li><p>将文件的逻辑块号转换为物理块号</p>
<ul>
<li>根据参数中的读指针、长度与文件控制块中的信息，确定块号、块数、块内位移</li>
</ul>
</li>
<li><p>申请缓冲区</p>
</li>
<li>启动磁盘I/O操作，把磁盘块中的信息读入缓冲区，再传送到指定的内存区(多次读盘)</li>
<li>反复执行3、4直至读出所需数量的数据或读至文件尾</li>
</ol>
<hr>
<h1 id="十-文件系统的管理"><a href="#十-文件系统的管理" class="headerlink" title="十.文件系统的管理"></a>十.文件系统的管理</h1><h2 id="1-文件系统的可靠性"><a href="#1-文件系统的可靠性" class="headerlink" title="1.文件系统的可靠性"></a>1.文件系统的可靠性</h2><p><strong>可靠性: 抵御和预防各种物理性破坏和人为性破坏的能力</strong></p>
<ul>
<li>坏块问题 </li>
<li>备份<ul>
<li>通过转储操作，形成文件或文件系统的多个副本</li>
</ul>
</li>
</ul>
<h2 id="2-文件系统备份"><a href="#2-文件系统备份" class="headerlink" title="2.文件系统备份"></a>2.文件系统备份</h2><ul>
<li><p><strong>全量转储:</strong></p>
<ul>
<li>定期将所有文件拷贝到后援存储器</li>
</ul>
</li>
<li><p><strong>增量转储:</strong></p>
<ul>
<li>只转储修改过的文件，即两次备份之间的修改，减少系统开销</li>
</ul>
</li>
<li><p><strong>物理转储:</strong></p>
<ul>
<li>从磁盘第0块开始，将所有磁盘块按序输出到磁带</li>
</ul>
</li>
<li><strong>逻辑转储:</strong><ul>
<li>从一个或几个指定目录开始，递归地转储自给定日期后所有更改的文件和目录</li>
</ul>
</li>
</ul>
<h2 id="3-文件系统一致性"><a href="#3-文件系统一致性" class="headerlink" title="3.文件系统一致性"></a>3.文件系统一致性</h2><h3 id="1-问题的产生"><a href="#1-问题的产生" class="headerlink" title="(1).问题的产生:"></a>(1).问题的产生:</h3><ul>
<li>磁盘块 → 内存 → 写回磁盘块 </li>
<li>若在写回之前，系统崩溃，则文件系统出现不一致</li>
</ul>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="(2).解决方案"></a>(2).解决方案</h3><p>设计一个实用程序，当系统再次启动时，运行该 程序，检查磁盘块和目录系统。</p>
<h2 id="4-磁盘块的一致性检查"><a href="#4-磁盘块的一致性检查" class="headerlink" title="4.磁盘块的一致性检查"></a>4.磁盘块的一致性检查</h2><p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/37.png" style="zoom:33%;"></p>
<p>UNIX一致性检查工作过程: </p>
<p>两张表，每块对应一个表中的计数器，初值为0</p>
<ul>
<li><p>表一:记录了每块在文件中出现的次数 </p>
</li>
<li><p>表二:记录了每块在空闲块表中出现的次数</p>
</li>
</ul>
<h2 id="5-磁盘系统的写入策略"><a href="#5-磁盘系统的写入策略" class="headerlink" title="5.磁盘系统的写入策略"></a>5.磁盘系统的写入策略</h2><ul>
<li><p><strong>通写(write-through)</strong> </p>
<ul>
<li><p>内存中的修改立即写到磁盘 </p>
</li>
<li><p>缺点:速度性能差</p>
<blockquote>
<p>例: FAT文件系统</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>延迟写(lazy-write)</strong></p>
<ul>
<li>利用回写(write back)缓存的方法得到高速 </li>
<li>可恢复性差</li>
</ul>
</li>
<li><p><strong>可恢复写(transaction log)</strong> </p>
<ul>
<li>采用事务日志来实现文件系统的写入 </li>
<li>既考虑安全性，又考虑速度性能</li>
</ul>
</li>
</ul>
<hr>
<h1 id="十一-文件系统的安全性"><a href="#十一-文件系统的安全性" class="headerlink" title="十一.文件系统的安全性"></a>十一.文件系统的安全性</h1><h2 id="1-文件保护机制"><a href="#1-文件保护机制" class="headerlink" title="1.文件保护机制"></a>1.文件保护机制</h2><ul>
<li>用于提供安全性、特定的操作系统机制</li>
<li>对拥有权限的用户，应该让其进行相应操作，否则，应禁止</li>
<li>防止其他用户冒充对文件进行操作</li>
</ul>
<p>实现：</p>
<ul>
<li>用户身份验证 </li>
<li>访问控制</li>
</ul>
<h2 id="2-文件的访问的控制"><a href="#2-文件的访问的控制" class="headerlink" title="2.文件的访问的控制"></a>2.文件的访问的控制</h2><h3 id="1-主动控制-访问控制表"><a href="#1-主动控制-访问控制表" class="headerlink" title="(1).主动控制:访问控制表"></a>(1).主动控制:访问控制表</h3><ul>
<li>每个文件一个</li>
<li>记录用户ID和访问权限 </li>
<li>用户可以是一组用户</li>
<li>文件可以是一组文件</li>
</ul>
<h3 id="2-能力表-权限表"><a href="#2-能力表-权限表" class="headerlink" title="(2).能力表(权限表)"></a>(2).能力表(权限表)</h3><ul>
<li><p>每个用户一个</p>
</li>
<li><p>记录文件名及访问权限 </p>
</li>
<li>用户可以是一组用户</li>
<li>文件可以是一组文件</li>
</ul>
<h2 id="3-UNIX的文件访问控制"><a href="#3-UNIX的文件访问控制" class="headerlink" title="3.UNIX的文件访问控制"></a>3.UNIX的文件访问控制</h2><p>采用文件的二级存取控制审查用户的身份、审查操作的合法性。</p>
<ul>
<li><p><strong>第一级:对访问者的识别，对用户分类:</strong></p>
<ul>
<li>文件主(owner) </li>
<li>文件主的同组用户(group)</li>
<li>其他用户(other)</li>
</ul>
</li>
<li><p>第二级:对操作权限的识别，对操作分类:</p>
<ul>
<li>读操作(r)</li>
<li>写操作(w)</li>
<li>执行操作(x)</li>
<li>不能执行任何操作(-)</li>
</ul>
</li>
</ul>
<hr>
<h1 id="十二-文件系统的性能"><a href="#十二-文件系统的性能" class="headerlink" title="十二.文件系统的性能"></a>十二.文件系统的性能</h1><blockquote>
<p>磁盘服务是速度成为系统性能的主要瓶颈之一，设计文件系统应尽可能减少磁盘访问次数。</p>
<p>提高文件系统性能的方法有：目录项(FCB)分解、当前目录、磁盘碎片整理；块高速缓存、磁盘调度、提前读取、合理分配磁 盘空间、信息的优化分布、RAID技术… …</p>
</blockquote>
<h2 id="1-块高速缓存-BLOCK-CACHE"><a href="#1-块高速缓存-BLOCK-CACHE" class="headerlink" title="1.块高速缓存(BLOCK CACHE)"></a>1.块高速缓存(BLOCK CACHE)</h2><h3 id="1-基本概念-9"><a href="#1-基本概念-9" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>块高速缓存又称为文件缓存、磁盘高速缓存、缓冲区高速缓存。</p>
<p><strong>基本思想是:在内存中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本。</strong></p>
<p>利用方式：</p>
<ul>
<li>检查所有的读请求，看所需块是否在块高速缓存中 </li>
<li>如果在，则可直接进行读操作；否则，先将数据块读入块高速缓存，再拷贝到所需的地方</li>
</ul>
<p>引入原因：<strong>由于访问的局部性原理，当一数据块被读入块高速缓存以满足一个I/O请求时，很可能将来还会再次访问到这一数据块</strong></p>
<h3 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="(2).如何实现"></a>(2).如何实现</h3><ul>
<li>块高速缓存的组织：</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/38.png" style="zoom:33%;"></p>
<ul>
<li>块高速缓存的置换(修改LRU)<ul>
<li>该块是否不久后会再次使用</li>
</ul>
</li>
<li>块高速缓存写入策略<ul>
<li>该块是否会影响文件系 统的一致性</li>
</ul>
</li>
</ul>
<h2 id="2-提前读取"><a href="#2-提前读取" class="headerlink" title="2.提前读取"></a>2.提前读取</h2><ul>
<li><strong>思路：</strong>每次访问磁盘，多读入一些磁盘块</li>
<li><strong>依据：</strong>程序执行的空间局部性原理</li>
<li><strong>开销：</strong>较小(只有数据传输时间)</li>
<li>具有针对性</li>
</ul>
<h2 id="3-WINDOWS的文件访问方式"><a href="#3-WINDOWS的文件访问方式" class="headerlink" title="3.WINDOWS的文件访问方式"></a>3.WINDOWS的文件访问方式</h2><ul>
<li><p><strong>不使用文件缓存</strong> </p>
<ul>
<li>普通方式</li>
<li>通过Windows提供的FlushFileBuffer函数实现  使用文件缓存</li>
</ul>
</li>
<li><p><strong>预读取。</strong></p>
<ul>
<li>每次读取的块大小、缓冲区大小、 置换方式</li>
<li>写回。写回时机选择、一致性问题</li>
</ul>
</li>
<li><p><strong>异步模式</strong></p>
<ul>
<li>不再等待磁盘操作的完成 </li>
<li>使处理器和I/O并发工作</li>
</ul>
</li>
</ul>
<p>用户对磁盘的访问通过访问文件缓存来实现。</p>
<ul>
<li><p>由Windows的CacheManager实现对缓存的控制 </p>
<ul>
<li><p>读取数据的时候预取</p>
</li>
<li><p>在Cache满时，根据LRU原则清除缓存的内容 </p>
</li>
<li>定期更新磁盘内容使其与Cache一致(1秒)</li>
</ul>
</li>
<li><p>Write-back机制</p>
<ul>
<li>在用户要对磁盘写数据时，只更改Cache中的 内容，由Cache Manager决定何时将更新反映到磁盘</li>
</ul>
</li>
</ul>
<p>例子</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/40.png" style="zoom:33%;"></p>
<h2 id="4-合理分配磁盘空间"><a href="#4-合理分配磁盘空间" class="headerlink" title="4.合理分配磁盘空间"></a>4.合理分配磁盘空间</h2><p>分配磁盘块时，把有可能顺序存取的块放在一起。尽量分配在同一柱面上，从而减少磁盘臂的移动次数和距离。</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/41.png" style="zoom:33%;"></p>
<h2 id="5-磁盘调度"><a href="#5-磁盘调度" class="headerlink" title="5.磁盘调度"></a>5.磁盘调度</h2><p>当有多个访盘请求等待时，采用一定的策略，对这 些请求的服务顺序调整安排，从而降低平均磁盘服务时间，达到公平、高效。</p>
<blockquote>
<ul>
<li>公平：一个I/O请求在有限时间内满足 </li>
<li>高效：减少设备机械运动带来的时间开销</li>
</ul>
</blockquote>
<p>一次访盘时间 = 寻道时间+旋转延迟时间+传输时间</p>
<blockquote>
<p>• 减少寻道时间 </p>
<p>• 减少延迟时间</p>
</blockquote>
<p>例子：</p>
<p>例子:假设磁盘访问序列: 98，183，37，122，14，124，65，67</p>
<p>读写头起始位置:53</p>
<p>要求计算:</p>
<ul>
<li>磁头服务序列</li>
<li>磁头移动总距离(道数)</li>
</ul>
<h3 id="1-先来先服务-FCFS"><a href="#1-先来先服务-FCFS" class="headerlink" title="(1).先来先服务(FCFS)"></a>(1).先来先服务(FCFS)</h3><p>思想：按访问请求到达的先后次序服务</p>
<ul>
<li><p>优点：简单，公平</p>
</li>
<li><p>缺点：效率不高，相临两次请求可能会造成最内到最 外的柱面寻道，使磁头反复移动，增加了服务时间， 对机械也不利</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/42.png" style="zoom:33%;"></p>
<h3 id="2-最短寻道时间优先-Shortest-Seek-Time-First"><a href="#2-最短寻道时间优先-Shortest-Seek-Time-First" class="headerlink" title="(2).最短寻道时间优先(Shortest Seek Time First)"></a>(2).最短寻道时间优先(Shortest Seek Time First)</h3><p>思想：优先选择距当前磁头最近的访问请求进行服务 主要考虑寻道优先</p>
<ul>
<li><p>优点：改善了磁盘平均服务时间</p>
</li>
<li><p>缺点：造成某些访问请求长期等待得不到服务</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/43.png" style="zoom:33%;"></p>
<h3 id="3-扫描算法SCAN-电梯算法"><a href="#3-扫描算法SCAN-电梯算法" class="headerlink" title="(3).扫描算法SCAN(电梯算法)"></a>(3).扫描算法SCAN(电梯算法)</h3><p>思想：当设备无访问请求时，磁头不动;当有访问请求时，磁头 按一个方向移动，在移动过程中对遇到的访问请求进行服 务，然后判断该方向上是否还有访问请求，如果有则继续 扫描;否则改变移动方向，并为经过的访问请求服务，如此反复。</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/44.png" style="zoom:33%;"></p>
<h3 id="4-单向扫描调度算法C-SCAN"><a href="#4-单向扫描调度算法C-SCAN" class="headerlink" title="(4).单向扫描调度算法C-SCAN"></a>(4).单向扫描调度算法C-SCAN</h3><ul>
<li>总是从0号柱面开始向里扫描</li>
<li><p>按柱面(磁道)位置选择访问者</p>
</li>
<li><p>移动臂到达最后一个柱面后，立即带动读写磁头快速 返回到0号柱面</p>
</li>
<li>返回时不为任何的等待访问者服务</li>
<li>返回后可再次进行扫描</li>
</ul>
<p>效果：减少了新请求的最大延迟</p>
<h3 id="5-N-step-SCAN策略"><a href="#5-N-step-SCAN策略" class="headerlink" title="(5).N-step-SCAN策略"></a>(5).N-step-SCAN策略</h3><ul>
<li>把磁盘请求队列分成长度为N的子队列，每一次用SCAN处理一个子队列</li>
<li>在处理某一个队列时，新请求添加到其他子队列中</li>
<li>如果最后剩下的请求数小于N，则它们全都将在下一次扫描时处理</li>
<li>N值比较大时，其性能接近SCAN；当N=1时，即FIFO</li>
</ul>
<p>克服“磁头臂的粘性”</p>
<h3 id="6-FSCAN策略"><a href="#6-FSCAN策略" class="headerlink" title="(6).FSCAN策略"></a>(6).FSCAN策略</h3><ul>
<li>使用两个子队列</li>
</ul>
<ul>
<li>扫描开始时，所有请求都在一个队列中，而另一个队列为空</li>
<li>扫描过程中，所有新到的请求都放入另一个队列中</li>
<li>对新请求的服务延迟到处理完所有老请求之后</li>
</ul>
<h3 id="7-旋转调度算法"><a href="#7-旋转调度算法" class="headerlink" title="(7).旋转调度算法"></a>(7).旋转调度算法</h3><p>旋转调度:根据延迟时间来决定执行次序的调度</p>
<p>三种情况:</p>
<ul>
<li><p>若干等待访问者请求访问同一磁头上的不同扇区</p>
</li>
<li><p>若干等待访问者请求访问不同磁头上的不同编号的扇区</p>
</li>
<li><p>若干等待访问者请求访问不同磁头上具有相同的扇区</p>
</li>
</ul>
<p>解决方案:</p>
<ul>
<li><p>对于前两种情况：总是让首先到达读写磁头位置下的扇区先进行传送操作</p>
</li>
<li><p>对于第三种情况：这些扇区同时到达读写磁头位置下，可任意选择一个读写磁头进行传送操作</p>
</li>
</ul>
<p>例子</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/45.png" style="zoom:33%;"></p>
<h2 id="6-信息的优化分布"><a href="#6-信息的优化分布" class="headerlink" title="6.信息的优化分布"></a>6.信息的优化分布</h2><p><strong>记录在磁道上的排列方式也会影响输入输出操作的时间。</strong></p>
<p>例子:处理程序要求顺序处理8个记录；磁盘旋转一周为20毫秒/周;花5毫秒对记录进行处理。</p>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/46.png" style="zoom:33%;"></p>
<h2 id="7-记录的成组与分解"><a href="#7-记录的成组与分解" class="headerlink" title="7.记录的成组与分解"></a>7.记录的成组与分解</h2><p>记录的成组：把若干个逻辑记录合成一组存放一块的工作</p>
<ul>
<li><p>进行成组操作时必须使用内存缓冲区，缓冲区的 长度等于逻辑记录长度乘以成组的块因子。</p>
</li>
<li><p>成组目的：提高了存储空间的利用率;减少了启 动外设的次数，提高系统的工作效率。</p>
</li>
<li><p>记录的分解从一组逻辑记录中把一个逻辑记录分离出来。</p>
</li>
</ul>
<h2 id="8-RAID技术"><a href="#8-RAID技术" class="headerlink" title="8.RAID技术"></a>8.RAID技术</h2><h3 id="1-基本概念-10"><a href="#1-基本概念-10" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h3><p>RAID(独立磁盘冗余阵列) (Redundant Arrays of Independent Disks) ：多块磁盘按照一定要求构成一个独立的存储设备。</p>
<p><strong>目标：</strong>提高可靠性和性能</p>
<p><strong>考虑：</strong>磁盘存储系统 的 速度、容量、容错、数据 灾难发生后的数据恢复</p>
<p><strong>数据的组织方式：</strong></p>
<ul>
<li><p>通过把多个磁盘组织在一起，作为一个逻辑卷提供磁盘跨越功能</p>
</li>
<li><p>通过把数据分成多个数据块，并行写入/读出多个磁盘，以提高数据传输率(数据分条stripe)</p>
</li>
<li><p>通过镜像或校验操作，提供容错能力(冗余)</p>
</li>
</ul>
<blockquote>
<p>最简单的RAID组织方式:镜像 </p>
<p>最复杂的RAID组织方式:块交错校验</p>
</blockquote>
<h3 id="2-RAID-0-—-条带化"><a href="#2-RAID-0-—-条带化" class="headerlink" title="(2).RAID 0 — 条带化"></a>(2).RAID 0 — 条带化</h3><ul>
<li><p>数据分布在阵列的所有磁盘上</p>
</li>
<li><p>有数据请求时，同时多个磁盘并行操作</p>
</li>
<li><p>充分利用总线带宽，数据吞吐率提高，驱动器负载均衡</p>
</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/47.png" style="zoom:33%;"></p>
<h3 id="3-RAID-1-—-镜像"><a href="#3-RAID-1-—-镜像" class="headerlink" title="(3).RAID 1 — 镜像"></a>(3).RAID 1 — 镜像</h3><ul>
<li>最大限度保证数据安全及可恢复性</li>
<li>所有数据同时存在于两块磁盘的相同位置 </li>
<li>磁盘利用率50%</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/48.png" style="zoom:33%;"></p>
<h3 id="4-RAID-4-—-交错块奇偶校验"><a href="#4-RAID-4-—-交错块奇偶校验" class="headerlink" title="(4).RAID 4 — 交错块奇偶校验"></a>(4).RAID 4 — 交错块奇偶校验</h3><ul>
<li>带奇偶校验</li>
<li>以数据块为单位</li>
</ul>
<p><img src="//ZYBO_o.github.io/2020/08/20/文件系统/49.png" style="zoom:33%;"></p>
<hr>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
</search>
