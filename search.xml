<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构Ⅷ排序</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅶ查找</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅵ图</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅴ树</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅳ串</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p>
<blockquote>
<p><strong>性质：</strong></p>
<ul>
<li>线性表中的数据元素之间是有顺序的。</li>
<li>线性表中的数据元素个数是有限的。</li>
<li>线性表中的数据元素的类型必须相同。</li>
</ul>
</blockquote>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/1.png" style="zoom:50%;">

<br>

<h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div>

<hr>
<br>

<h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/2.png" style="zoom:45%;">

<p>摘录来自: 程杰. “大话数据结构。” Apple Books. </p>
<p><strong>在C中用一维数组来实现顺序存储结构：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div>

<br>

<h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>创建</li>
<li>分配内存</li>
<li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li>
<li>返回表的地址</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/6.png" style="zoom:50%;">

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个新的线性表</span></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建</span></span><br><span class="line">    TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">        ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检验分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;capacity = capacity;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">        ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新建成功的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>直接通过数组下标的方式获取元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ret = <span class="literal">NULL</span>;</span><br><span class="line">  	<span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  	<span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">      	<span class="comment">//3.获取元素</span></span><br><span class="line">        ret = List-&gt;node[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>把最后一个元素到插入位置的元素后移一个位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/3.png" style="zoom:50%;">



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">char</span> node, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">    <span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">    ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">    ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( ret )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">        &#123;</span><br><span class="line">            pos = List-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//4.将新元素插入</span></span><br><span class="line">        List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line">      	<span class="comment">//5.线性表长度加1</span></span><br><span class="line">        List-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断删除位置是否合法</li>
<li>将元素取出</li>
<li>将删除位置后的元素分别向前移动一个位置</li>
<li>线性表长度减1</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/4.png" style="zoom:50%;">



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  	<span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//3.将元素取出</span></span><br><span class="line">      ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//5.线性表长度减1</span></span><br><span class="line">      <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h3 id="3-代码具体实现"><a href="#3-代码具体实现" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><p><strong>SeqList.h</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_SEQLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_SEQLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用void做封装，使用void之后在main函数中不会产生误操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> SeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIST_SEQLIST_H</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>SeqList.c</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> TSeqListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    TSeqListNode * node;</span><br><span class="line">&#125;TSeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的线性表</span></span><br><span class="line"><span class="function">SeqList* <span class="title">SeqList_Create</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建</span></span><br><span class="line">    TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.分配内存</span></span><br><span class="line">        ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检验分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;capacity = capacity;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//新建完的链表的指针指向第一个节点的结尾处</span></span><br><span class="line">        ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新建成功的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Destroy</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SeqList_Clear</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在转换后线性表不为空的情况下，把长度设置为0</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Length</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的长度</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性表的长度</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的容量大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Capacity</span><span class="params">(SeqList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.在线性表不为空的情况下，获取表的容量大小</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.返回线性表的容量大小</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向线性表的指定位置插入值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SeqList_Insert</span><span class="params">(SeqList* <span class="built_in">list</span>, SeqListNode* node, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//2.检查列表不为空</span></span><br><span class="line">    <span class="keyword">int</span> ret = (slist != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.检查线性表长度不大于容量。并且需要插入的值合理</span></span><br><span class="line">    ret = ret&amp;&amp;(slist-&gt;length+<span class="number">1</span> &lt;= slist-&gt;capacity);</span><br><span class="line">    ret = ret&amp;&amp;(<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.在上述条件都合理的情况下进行操作</span></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果需要插入的位置大于等于线性表的长度，则把修改位置为线性表的最后</span></span><br><span class="line">        <span class="keyword">if</span>( pos &gt;= slist-&gt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = slist-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把需要插入位置后的节点都往后移一个单位</span></span><br><span class="line">        <span class="keyword">for</span> (i = slist-&gt;length; i &gt; pos ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i] = slist-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把节点插入需要的位置</span></span><br><span class="line">        slist-&gt;node[pos] = *((TSeqListNode*)node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线性表的长度加1</span></span><br><span class="line">        slist-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回操作结果(成功为1，失败为0)</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表中删除指定的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Delete</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.去除删除元素</span></span><br><span class="line">    SeqListNode* ret = SeqList_Get(slist,pos);</span><br><span class="line">    <span class="comment">//因为上面是指针变量，所以删除后，ret指向的指针会改变，对于的值自然也会变，所以要及时转换成数值类型的变量</span></span><br><span class="line">    TSeqListNode date = *(TSeqListNode*)ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("在为SeqList_Delete函数中:%d\n",*(int*)ret);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.把删除后的元素全部向前移动一个单元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt; slist-&gt;length ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;node[i<span class="number">-1</span>] = slist-&gt;node[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slist-&gt;length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.返回删除的值</span></span><br><span class="line">    <span class="keyword">return</span> &amp;date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//取出线性表对应位置的值</span></span><br><span class="line"><span class="function">SeqListNode* <span class="title">SeqList_Get</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.强制转换类型，把void类型转换成需要的类型</span></span><br><span class="line">    TSeqList* slist = (TSeqList*)<span class="built_in">list</span>;</span><br><span class="line">    SeqListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (slist != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; slist-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">        ret = (SeqListNode*)(&amp;slist-&gt;node[pos]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>main.c</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SeqList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SeqList* <span class="built_in">list</span> = SeqList_Create(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> z = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;i, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;j, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;k, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;x, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;y, <span class="number">0</span>);</span><br><span class="line">    SeqList_Insert(<span class="built_in">list</span>, &amp;z, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>; index&lt;SeqList_Length(<span class="built_in">list</span>); index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)SeqList_Get(<span class="built_in">list</span>, index);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SeqList_Length(<span class="built_in">list</span>) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(<span class="keyword">int</span>*)SeqList_Delete(<span class="built_in">list</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    SeqList_Destroy(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"线性表长度为:%d\n"</span>,SeqList_Length(<span class="built_in">list</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>运行结果：</strong></p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/5.png" style="zoom:50%;">

<br>

<h3 id="4-顺序存储的优缺点"><a href="#4-顺序存储的优缺点" class="headerlink" title="(4).顺序存储的优缺点"></a>(4).顺序存储的优缺点</h3><img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/7.png" style="zoom:40%;">



<hr>
<br>

<h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/8.png" style="zoom:50%;">

<p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/9.png" style="zoom:30%;">



<p><strong>链表的基本概念:</strong></p>
<ul>
<li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li>
<li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li>
<li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/10.png" style="zoom:40%;">





<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/11.png" style="zoom:60%;">



<p><strong>C语言用结构体来定义链表中的结点：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<br>

<h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> <span class="comment">// O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TLinkList* sList = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  	<span class="comment">//2.判断位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">        LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">      	<span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/13.png" style="zoom:45%;">



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Insert</span><span class="params">(LinkList* <span class="built_in">list</span>, LinkListNode* node, <span class="keyword">int</span> pos)</span> <span class="comment">// O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    TLinkList* sList = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">  	<span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  	<span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">    <span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( ret )</span><br><span class="line">    &#123;</span><br><span class="line">        LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">        <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将新元素插入</span></span><br><span class="line">        node-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = node;</span><br><span class="line">        <span class="comment">//5.线性表长度加1</span></span><br><span class="line">        sList-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li><p>判断线性表是否合法</p>
</li>
<li><p>判断插入位置是否合法</p>
</li>
<li><p>获取第pos个元素</p>
</li>
<li><p>将第pos个元素从链表中删除</p>
</li>
<li><p>线性表长度减1</p>
</li>
</ul>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/12.png" style="zoom:45%;">



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Delete</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span> <span class="comment">// O(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TLinkList* sList = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.判断线性表是否合法</span></span><br><span class="line">  	<span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">    &#123;</span><br><span class="line">        LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">        <span class="comment">//3.获取第pos个元素</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">        current-&gt;next = ret-&gt;next;</span><br><span class="line">        <span class="comment">//5.线性表长度减1</span></span><br><span class="line">        sList-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<br>

<h3 id="3-代码具体实现-1"><a href="#3-代码具体实现-1" class="headerlink" title="(3).代码具体实现"></a>(3).代码具体实现</h3><p><strong>LinkList.h</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LIST_LINKLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_LINKLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> LinkList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span> <span class="title">LinkListNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList* <span class="title">LinkList_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Destroy</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Clear</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Length</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Insert</span><span class="params">(LinkList* <span class="built_in">list</span>, LinkListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Delete</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIST_LINKLIST_H</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>LinkList.c</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by ZYB on 2020/6/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function">LinkList* <span class="title">LinkList_Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//动态生成一个表头结点</span></span><br><span class="line">    TLinkList* ret = (TLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TLinkList));</span><br><span class="line">    <span class="comment">//判断是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回创建的链表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Destroy</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList_Clear</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度设置为0，头结点指向空</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;length = <span class="number">0</span>;</span><br><span class="line">        slist-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Length</span><span class="params">(LinkList* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//长度赋给变量然后返回</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = slist-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkList_Insert</span><span class="params">(LinkList* <span class="built_in">list</span>, LinkListNode* node, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">    <span class="keyword">int</span> ret = (slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到需要插入的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入节点</span></span><br><span class="line">        node-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next = node;</span><br><span class="line">        <span class="comment">//链表长度加一</span></span><br><span class="line">        slist-&gt;length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得对应节点的值</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Get</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">   <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到指定的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把对应的节点地址赋给ret</span></span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function">LinkListNode* <span class="title">LinkList_Delete</span><span class="params">(LinkList* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行强制转换</span></span><br><span class="line">    TLinkList* slist = (TLinkList*)<span class="built_in">list</span>;</span><br><span class="line">    LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//进行条件检测</span></span><br><span class="line">    <span class="keyword">if</span>((slist != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (pos &lt; slist-&gt;length))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义一个插入指针指向头结点</span></span><br><span class="line">        LinkListNode* current = (LinkListNode*)slist;</span><br><span class="line">        <span class="comment">//移动指针到指定的地方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; (i &lt; pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行删除操作</span></span><br><span class="line">        ret = current-&gt;next;</span><br><span class="line">        current-&gt;next = ret-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链表长度减一</span></span><br><span class="line">        slist-&gt;length--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>main.c</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LinkList.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* run this program using the console pauser or add your own getch, system("pause") or input loop */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkListNode header;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList*  <span class="built_in">list</span> = LinkList_Create();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v3</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> <span class="title">v5</span>;</span></span><br><span class="line"></span><br><span class="line">    v1.v = <span class="number">1</span>;</span><br><span class="line">    v2.v = <span class="number">2</span>;</span><br><span class="line">    v3.v = <span class="number">3</span>;</span><br><span class="line">    v4.v = <span class="number">4</span>;</span><br><span class="line">    v5.v = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v1, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v2, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v3, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v4, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line">    LinkList_Insert(<span class="built_in">list</span>, (LinkListNode*)&amp;v5, LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; LinkList_Length(<span class="built_in">list</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Value</span>* <span class="title">pv</span> = (<span class="title">struct</span> <span class="title">Value</span>*)<span class="title">LinkList_Get</span>(<span class="title">list</span>, <span class="title">i</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点%d的值为:%d\n"</span>, i, pv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( LinkList_Length(<span class="built_in">list</span>) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Value</span>* <span class="title">pv</span> = (<span class="title">struct</span> <span class="title">Value</span>*)<span class="title">LinkList_Delete</span>(<span class="title">list</span>, 0);</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除的节点的值为:%d\n"</span>, pv-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"链表长度为:%d\n"</span>,LinkList_Length(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">    LinkList_Destroy(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>运行结果：</strong></p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅱ线性表/14.png" style="zoom:40%;">

<hr>
<br>

<h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<blockquote>
<p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p>
<ul>
<li>可以输入到计算机中。</li>
<li>能被计算机程序处理。</li>
</ul>
</blockquote>
<p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p>
<blockquote>
<p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p>
</blockquote>
<p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p>
<blockquote>
<p>性质相同，是指数据元素具有相同数量和类型的数据项。</p>
</blockquote>
<p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<blockquote>
<p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p>
</blockquote>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/1.png" style="zoom:50%;">





<h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote>
<p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p>
</blockquote>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/2.png" style="zoom:50%;">

<h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p>
<blockquote>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p>
</blockquote>
<p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/3.png" style="zoom:50%;">



<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p>
<img src="//zybtree.github.io/2020/04/12/数据结构Ⅰ绪论/4.png" style="zoom:40%;">







<h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<blockquote>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
</blockquote>
<p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>
<h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<hr>
<br>



<h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>数据结构绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅸ C预处理器和C库</title>
    <url>/2020/04/10/C-Program-%E2%85%A8-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅷ  位操作</title>
    <url>/2020/04/10/C-Program-%E2%85%A7-%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅶ 结构体和其他数据形式</title>
    <url>/2020/04/10/C-Program-%E2%85%A6-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅵ 文件</title>
    <url>/2020/04/10/C-Program-%E2%85%A5-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅴ 存储类,链接和内存管理</title>
    <url>/2020/04/10/C-Program-%E2%85%A4-%E5%AD%98%E5%82%A8%E7%B1%BB-%E9%93%BE%E6%8E%A5%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 程序员通过 C的内存管理系统指定变量的作用域和生命期，实现对程序的控制。合理使用内存储存数据是设计程序的一个要点。</p>
</blockquote>
<h1 id="一-存储类别"><a href="#一-存储类别" class="headerlink" title="一.存储类别"></a>一.存储类别</h1><p><strong>硬件方面来看：</strong>被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<code>对象(object)</code>。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小(面向对象编程中的对象指的是类对象，其定义包括数据和允许对数据进行的操作，C不是面向对象编程语言)。</p>
<p><strong>软件方面来看：</strong>程序需要一种方法访问对象。这可以通过声明变量来完成。</p>
<p>以下面的例子作为分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>

<p>该声明创建了一个名为<code>entity</code>的<code>标识符(identifier)</code>。标识符是一个名称，在这种情况下，标识符可以用来指定(designate)特定对象的内容。标识符遵循变量的命名规则。在该例中，标识符<code>entity</code>即是软件(即C程序)指定<strong>硬件内存中的对象的方式</strong>。该声明还提供了<strong>储存在对象中的值</strong>。</p>
<p>但是变量名不是指定对象的唯一途径。以下面的例子作为分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt = &amp;entity;</span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>第1行声明中，<code>pt</code>是一个标识符，它指定了一个储存地址的对象。但是，表达式<code>pt</code>不是标识符，因为它不是一个名称。然而，它确实指定了一个对象，在这种情况下，它与 <code>entity</code>指定的对象相同。一般而言，那些指定对象的表达式被称为<em>左值<em>。所以，<code>entity</code>既是标识符也是左值；`</em>pt<code>既是表达式也是左值。按照这个思路，</code>ranks + 2 * entity<code>既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式</code></em>(ranks + 2 * entity)`是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。顺带一提，ranks的声明创建了一个可容纳10个int类型元素的对象，该数组的每个元素也是一个对象。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅳ 字符串和字符串函数</title>
    <url>/2020/04/10/C-Program-%E2%85%A3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="五-字符串函数"><a href="#五-字符串函数" class="headerlink" title="五.字符串函数"></a>五.字符串函数</h1><h2 id="1-strlen-函数"><a href="#1-strlen-函数" class="headerlink" title="1.strlen()函数"></a>1.strlen()函数</h2><p>strlen()函数用于统计字符串的长度。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* test_fit.c -- try the string-shrinking function */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; /* contains string function prototypes */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> mesg[] = <span class="string">"Things should be as simple as possible,"</span></span><br><span class="line">    <span class="string">" but not simpler."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    fit(mesg,<span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Let's look at some more of the string."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(mesg + <span class="number">39</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size)</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/1.png" style="zoom:50%;">

<p><code>fit()</code>函数把第39个元素的逗号替换成<code>&#39;\0&#39;</code>字符。<code>puts()</code>函数在空字符处停止输出，并忽略其余字符。然而，这些字符还在缓冲区中，下面的函数调用把这些字符打印了出来：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(mesg + <span class="number">8</span>);</span><br></pre></td></tr></table></figure></div>

<p>表达式<code>mesg + 39</code>是<code>mesg[39]</code>的地址，该地址上储存的是空格字符。所以<code>put()</code>显示该字符并继续输出直至遇到原来字符串中的空字符.</p>
<p>演示过程如下图所示：</p>
<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/2.png" style="zoom:50%;">

<h2 id="2-strcat-和strncat-函数"><a href="#2-strcat-和strncat-函数" class="headerlink" title="2.strcat()和strncat()函数"></a>2.strcat()和strncat()函数</h2><p><code>strcat()</code>（用于拼接字符串）函数接受两个字符串作为参数。该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，第2个字符串不变。</p>
<p><code>strcat()</code>函数的类型是<code>char *</code>（即，指向char的指针）。<code>strcat()</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p>
<p><code>strcat()</code>的用法:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* str_cat.c -- joins two strings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  /* declares the strcat() function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"End of file encountered!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/3.png" style="zoom:50%;">

<p><code>strcat()</code>函数问题：</p>
<p><font color="red"><code>strcat()</code>函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。</font></p>
<p>解决方法：</p>
<ul>
<li>用<code>strlen()</code>查看第1个数组的长度。注意，要给拼接后的字符串长度加1才够空间存放末尾的空字符。</li>
</ul>
<ul>
<li>用<code>strncat()</code>，该函数的第3 个参数指定了最大添加字符数。</li>
</ul>
<p><code>strncat()</code>例子</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* join_chk.c -- joins two strings, check size first */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUGSIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">"s smell like old shoes."</span>;</span><br><span class="line">    <span class="keyword">char</span> bug[BUGSIZE];</span><br><span class="line">    <span class="keyword">int</span> available;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite flower?"</span>);</span><br><span class="line">    s_gets(flower, SIZE);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(addon) + <span class="built_in">strlen</span>(flower) + <span class="number">1</span>) &lt;= SIZE)</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">    <span class="built_in">puts</span>(flower);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What is your favorite bug?"</span>);</span><br><span class="line">    s_gets(bug, BUGSIZE);</span><br><span class="line">    available = BUGSIZE - <span class="built_in">strlen</span>(bug) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(bug, addon, available);</span><br><span class="line">    <span class="built_in">puts</span>(bug);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">'\n'</span> &amp;&amp; st[i] != <span class="string">'\0'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">'\n'</span>)</span><br><span class="line">            st[i] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// must have words[i] == '\0'</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅳ-字符串和字符串函数/4.png" style="zoom:50%;">

<blockquote>
<p>strcat()和 gets()类似，也会导致缓冲区溢出。为什么 C11 标准不废弃strcat()，只留下strncat()？为何对gets()那么残忍？<strong>这也许是因为gets()造成的安全隐患来自于使用该程序的人，而strcat()暴露的问题是那些粗心的程序员造成的。</strong>无法控制用户会进行什么操作，但是，可以控制你的程序做什么。C语言相信程序员，因此程序员有责任确保strcat()的使用安全。</p>
</blockquote>
<h2 id="三-strcmp-函数"><a href="#三-strcmp-函数" class="headerlink" title="三.strcmp()函数"></a>三.strcmp()函数</h2>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅲ 数组与指针</title>
    <url>/2020/04/10/C-Program-%E2%85%A2-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅱ 函数</title>
    <url>/2020/04/10/C-Program-%E2%85%A1-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>什么是函数？</strong>函数（function）是完成特定任务的独立程序代码单元。</p>
<p><strong>为什么要使用函数？</strong>首先，使用函数可以省去编写重复代码，提高效率。其次，让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。如果不是自己编写函数，根本不用关心黑盒的内部行为；以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上</p>
</blockquote>
<p>以下面程序为例分析：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;            /* for strlen() */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE <span class="meta-string">' '</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spaces;</span><br><span class="line">    </span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);   <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    show_n_char(SPACE, <span class="number">12</span>);    <span class="comment">/* using constants as arguments */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line">    spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* Let the program calculate    */</span></span><br><span class="line">    <span class="comment">/* how many spaces to skip      */</span></span><br><span class="line">    show_n_char(SPACE, spaces);<span class="comment">/* use a variable as argument   */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line">    show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* an expression as argument    */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">    show_n_char(<span class="string">'*'</span>, WIDTH);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* show_n_char() definition */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>程序在3处使用了<code>show_n_char()</code>标识符：<strong>函数原型(function prototype)</strong>告诉编译器函数<code>show_n_char()</code>的类型；<strong>函数调用(function call)</strong>表明在此处执行函数；<strong>函数定义(function definition)</strong>明确地指定了函数要做什么。</p>
<p><strong>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。</strong>因此，在main()函数定义的前面</p>
<h2 id="1-对于函数声明"><a href="#1-对于函数声明" class="headerlink" title="1.对于函数声明"></a>1.对于函数声明</h2><p>出现了下面的ANSI C风格的函数原型：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>圆括号表明<code>show_n_char()</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。后面的<code>char</code>,<code>int</code>（在圆括号中）表明该函数带有两个参数，一个为<code>char</code>类型，一个为<code>int</code>类型。分号表明这是在声明函数，不是定义函数。<font color="red">函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。</font></p>
<blockquote>
<p>程序把 <code>show_n_char()</code>原型置于<code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p>
</blockquote>
<h2 id="2-对于函数参数"><a href="#2-对于函数参数" class="headerlink" title="2.对于函数参数"></a>2.对于函数参数</h2><p>还是以这个有ANSI C风格的函数头为例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure></div>

<p>该行告知编译器<code>show_n_char()</code>使用两个参数ch和num，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数（formal argument，但是最近的标准推荐使用formal parameter）</strong>，简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。</p>
<blockquote>
<p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：void dibs(int x, y, z)　　　　 /* 无效的函数头 */</p>
</blockquote>
<p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，也可以省略变量名：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_n_char</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>在函数调用中，<strong>实际参数（actual argument，简称实参）</strong>提供了ch和num的值。考虑上例中第1次调用<code>show_n_char()</code>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">show_n_char(SPACE, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></div>

<p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，<font color="red">形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。</font></p>
<blockquote>
<p>1.注意 实际参数和形式参数：<strong>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。</strong></p>
<p>2.<font color="red">为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h2 id="3-关于return从函数中返回值"><a href="#3-关于return从函数中返回值" class="headerlink" title="3.关于return从函数中返回值"></a>3.关于return从函数中返回值</h2><p>函数的返回值可以把信息从被调函数传回主调函数。关键字<code>return</code>后面的表达式的值就是函数的返回值。</p>
<p>问题：如果函数返回值的类型与函数声明的类型不匹配会怎样？</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>　<span class="title">what_if</span><span class="params">(<span class="keyword">int</span>　n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">double</span>　z　=　<span class="number">100.0</span>　/　(<span class="keyword">double</span>)　n;</span><br><span class="line">		<span class="keyword">return</span> z; <span class="comment">// 会发生什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">result = what_if(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></div>

<p>虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。</p>
<h2 id="4-查找地址：-amp-运算符"><a href="#4-查找地址：-amp-运算符" class="headerlink" title="4.查找地址：&amp;运算符"></a>4.查找地址：&amp;运算符</h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。</p>
<p>下面例子中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* loccheck.c  -- checks to see where variables are stored  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;                      <span class="comment">/* declare function  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;             <span class="comment">/* local to main()   */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span>                   <span class="comment">/* define function   */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pooh = <span class="number">10</span>;                     <span class="comment">/* local to mikado() */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), pooh = %d and &amp;pooh = %p\n"</span>,</span><br><span class="line">           pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In mikado(), bah = %d and &amp;bah = %p\n"</span>,</span><br><span class="line">           bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/3.png" style="zoom:50%;">

<blockquote>
<p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值 2 传递给形式参数（mikado()中的bah）。<strong>注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。</strong></p>
</blockquote>
<h2 id="5-使用指针在函数间通信"><a href="#5-使用指针在函数间通信" class="headerlink" title="5.使用指针在函数间通信"></a>5.使用指针在函数间通信</h2><p>指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。</p>
<p>声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。<code>long</code>和<code>float</code>可能占用相同的存储空间，但是它们储存数字却大相径庭。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;　　 <span class="comment">// pi是指向int类型变量的指针</span></span><br><span class="line"><span class="keyword">char</span> * pc;　　　　<span class="comment">// pc是指向char类型变量的指针</span></span><br><span class="line"><span class="keyword">float</span> * pf, * pg; <span class="comment">// pf、pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure></div>

<p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int * pi; 声明的意思是pi是一个指针,`</em>pi<code>是</code>int`类型 </p>
<p>pc指向的值（<em>pc）是char类型。pc本身是什么类型？我们描述它的类型是*</em>“指向char类型的指针<strong>。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，</strong>但是不能把两个指针相乘**。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。</p>
<p>下面例子就介绍了指针在函数间通信：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* swap2.c -- researching swap1.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/4.png" style="zoom:50%;">

<p>  该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把           地址作为它们的值。因此，应把它们声明为指针。</p>
<p>在<code>interchange(int *u, int *v)</code>函数中 <code>* u = x, * v = y</code>;即 <code>u = &amp;x, v = &amp;y</code>;</p>
<p><code>*u = *v</code>;——&gt;把 v 的地址赋值给 u; <code>*v = temp</code>;——&gt;把temp的地址赋值给v。</p>
<p><code>u</code>和 <code>v</code> 互换了地址。</p>
<p><strong>猜想：如果直接int * temp;是否也能改变值？</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> *u, <span class="keyword">int</span> *v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Originally x = %d and y = %d.\n"</span>, x , y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In main Now x = %d and y = %d.\n"</span>, x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchange Originally u = %d and v = %d.\n"</span>, *u , *v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"In interchangeo Now u = %d and v = %d.\n"</span>, *u, *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/6.png" style="zoom:50%;">

<p>实践证明是不行的，因为定义指针temp后的交换与定义<code>int temp</code>,然后<code>interchange(int  u, int  v)</code>这样交换是一样的，都是同类型的交换。</p>
<p><strong>对于指针与地址的实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">	p = &amp;n;</span><br><span class="line">	<span class="keyword">int</span> temp = *p;</span><br><span class="line">	<span class="keyword">int</span> *v;</span><br><span class="line">	v = &amp;temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"n = %d,the loacl of n = %p\n"</span>,n,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*p = %d,the loacl of p = %p\n"</span>,*p,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"temp = %d,the loacl of temp = %p\n"</span>,temp,&amp;temp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*v = %d,the loacl of v = %p\n"</span>,*v,v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅱ-函数/7.png" style="zoom:50%;">

<blockquote>
<p>为什么temp的地址与* v的地址不一样呢，因为temp是新定义的变量，编译时给temp新分配了一个地址。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C Program Ⅰ 字符</title>
    <url>/2020/04/10/C-Program-%E2%85%A0-%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-单字符I-O-getchar-和-putchar"><a href="#1-单字符I-O-getchar-和-putchar" class="headerlink" title="1.单字符I/O : getchar() 和 putchar()"></a>1.单字符I/O : getchar() 和 putchar()</h2><blockquote>
<p>getchar() 和 putchar ()每次只能输入和输出一个字符。</p>
</blockquote>
<p>ANSI C 将 <code>stdio.h</code> 头文件与getchar() 和 putchar()相关联，这就是为什么程序中将该文件包含在内的原因。而且，getchar() 和 putchar() 不是真正的函数，而是定义为预处理器宏。</p>
<h3 id="1-getchar-与-scanf-的区分与混用"><a href="#1-getchar-与-scanf-的区分与混用" class="headerlink" title="1.getchar() 与 scanf() 的区分与混用"></a>1.getchar() 与 scanf() 的区分与混用</h3><p>在缓冲输入时需要按下Enter键，这一动作还传输一个程序必须处理的换行符。而<code>getchar()</code> 读取每个字符，包括空格，制表符和换行符；但是 <code>scanf()</code> 在在<strong>读取数字</strong>时会跳过空格，制表符和换行符。举例说明：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">int</span> rows,cols;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols);</span><br><span class="line">		display(ch,rows,cols);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row,col;</span><br><span class="line">		<span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line">				<span class="built_in">putchar</span>(cr);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅰ-字符/1.png" style="zoom:50%;">

<img src style="zoom:50%;">

<blockquote>
<p>程序会在输入之后，没有做出其他输入响应之前就结束了，原因是紧跟在输入3之后的那个换行符。</p>
</blockquote>
<p><strong><code>scanf()</code>函数将该换行符留在输入队列中，与<code>scanf()</code>不同，<code>getchar()</code> 并不跳过换行符。</strong>所以在循环的下一周期，再有机会输入任何其他内容之前，这一换行符由<code>getchar()</code>读出，然后将其赋值为ch，而ch为换行符才是结束循环的条件。</p>
<p>改善程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr, <span class="keyword">int</span> lines, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">int</span> rows,cols;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Enter a character and a integers:\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>((ch = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;rows,&amp;cols) != <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">		display(ch,rows,cols);</span><br><span class="line">    <span class="keyword">while</span>(getchar() != <span class="string">'\n'</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter anthor character and a integers:\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Enter a newline to quit.\n "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> cr,<span class="keyword">int</span> lines,<span class="keyword">int</span> width)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row,col;</span><br><span class="line">		<span class="keyword">for</span>(row = <span class="number">1</span>; row &lt;= lines; row++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(col  = <span class="number">1</span>; col &lt;= width; col++)&#123;</span><br><span class="line">				<span class="built_in">putchar</span>(cr);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<img src="//zybtree.github.io/2020/04/10/C-Program-Ⅰ-字符/2.png" style="zoom:50%;">

<blockquote>
<p>程序跳过了一个输入周期中输入的最后一个数字与下一行开始处输入的字符之间的所有换行符和空格。</p>
</blockquote>
<h3 id="2-输入流和数字"><a href="#2-输入流和数字" class="headerlink" title="2.输入流和数字"></a>2.输入流和数字</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">is 28 12.4</span><br></pre></td></tr></table></figure></div>

<p>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。<font color="red">但是对 C程序而言，这是一个字节流。</font><strong>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等</strong>。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">	<span class="built_in">putchar</span>(ch); <span class="comment">// 处理错误的输入</span></span><br></pre></td></tr></table></figure></div>

<p>虽然输入流由字符组成，但是也可以设置<code>scanf()</code>函数把它们转换成数值。例如，考虑下面的输入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure></div>

<p>如果在<code>scanf()</code>函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，“它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，<code>scanf()</code>同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，<code>scanf()</code>也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。<br><strong>简而言之，输入由字符组成，但是<code>scanf()</code>可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而<code>getchar()</code>和使用%c的<code>scanf()</code>接受所有的字符。</strong></p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb学习</title>
    <url>/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<p>在终端输入以下命令安装 GDB：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install gdb</span><br></pre></td></tr></table></figure></div>

<h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1+2+3+...+%d= %d\n"</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gcc bugging.c -o bugging -g -m64</span><br></pre></td></tr></table></figure></div>

<p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p>
<p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install libc6-dev-i386</span><br></pre></td></tr></table></figure></div>

<p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gdb bugging</span><br></pre></td></tr></table></figure></div>

<p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) run</span><br></pre></td></tr></table></figure></div>

<p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> (gdb) quit</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/03/26/gdb学习/1.png" style="zoom:50%;">

<h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p>
<blockquote>
<p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p>
</blockquote>
<p>部分 gdb 常用命令一览表：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">简写形式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">list</td>
<td align="center">l</td>
<td align="center">查看源码</td>
</tr>
<tr>
<td align="center">backtrace</td>
<td align="center">bt,where</td>
<td align="center">打印函数栈信息</td>
</tr>
<tr>
<td align="center">next</td>
<td align="center">n</td>
<td align="center">执行下一行</td>
</tr>
<tr>
<td align="center">step</td>
<td align="center">s</td>
<td align="center">一次执行一行，遇到函数会进入</td>
</tr>
<tr>
<td align="center">finish</td>
<td align="center"></td>
<td align="center">运行到函数结束</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">c</td>
<td align="center">继续运行</td>
</tr>
<tr>
<td align="center">break</td>
<td align="center">b</td>
<td align="center">设置断点</td>
</tr>
<tr>
<td align="center">info breakpoints</td>
<td align="center"></td>
<td align="center">显示断点信息</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">d</td>
<td align="center">删除断点</td>
</tr>
<tr>
<td align="center">print</td>
<td align="center">p</td>
<td align="center">打印表达式的值</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">r</td>
<td align="center">启动程序</td>
</tr>
<tr>
<td align="center">until</td>
<td align="center">u</td>
<td align="center">执行到指定行</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">i</td>
<td align="center">显示信息</td>
</tr>
<tr>
<td align="center">help</td>
<td align="center">h</td>
<td align="center">帮助信息</td>
</tr>
</tbody></table>
<p>查询用法：</p>
<blockquote>
<p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p>
</blockquote>
<p>执行 Shell 命令：</p>
<blockquote>
<p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span> $ (gdb)!shell 命令</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<p>例如查看当前目录的文件：</p>
<img src="//zybtree.github.io/2020/03/26/gdb学习/2.png" style="zoom:50%;">
</blockquote>
<h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p>
<ul>
<li>list 行号，显示某一行附近的代码：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/3.png" style="zoom:50%;">

<ul>
<li>list 函数名，显示某个函数附近的代码：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/4.png" style="zoom:50%;">

<ul>
<li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li>
</ul>
<h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p>
<ul>
<li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/5.png" style="zoom:50%;">

<ul>
<li>break 文件名 : 行号，适用于有多个源文件的情况。</li>
</ul>
<ul>
<li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/6.png" style="zoom:50%;">

<ul>
<li>break 文件名 : 函数名，适用于有多个源文件的情况。</li>
</ul>
<h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p>
<img src="//zybtree.github.io/2020/03/26/gdb学习/7.png" style="zoom:50%;">

<p>其中每一项的信息：</p>
<blockquote>
<ul>
<li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li>
<li>Type 列代表断点类型，一般为 breakpoint</li>
<li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li>
<li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li>
<li>Address 列代表该断点处虚拟内存的地址</li>
<li>What 列代表该断点在源文件中的信息</li>
</ul>
</blockquote>
<h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p>
<ul>
<li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/8.png" style="zoom:50%;">

<ul>
<li>delete，不带任何参数，默认删除所有断点：</li>
</ul>
<h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p>
<blockquote>
<p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p>
<p><em>enable</em> 命令用于启用断点。</p>
</blockquote>
<ul>
<li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/9.png" style="zoom:50%;">

<ul>
<li><p>disable，不带任何参数，默认关闭所有断点。</p>
</li>
<li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p>
</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/10.png" style="zoom:50%;">

<ul>
<li>enable，不带任何参数，默认启用所有断点。</li>
</ul>
<p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p>
<h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p>
<ul>
<li>enable once Num，断点 hit 一次之后关闭该断点</li>
<li>enable delete Num，断点 hit 一次之后删除该断点</li>
</ul>
<img src="//zybtree.github.io/2020/03/26/gdb学习/11.png" style="zoom:50%;">

<p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p>
<h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol>
<li><strong>打印变量</strong></li>
</ol>
<p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p>
<blockquote>
<ul>
<li><p><code>info locals</code></p>
<p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p>
</li>
<li><p><code>print 变量或表达式</code></p>
<p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p>
<p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>启动程序</strong></li>
</ol>
<p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p>
<blockquote>
<ul>
<li><p><code>run</code></p>
<p>不带任何参数，启动待调试程序，不传递参数。</p>
</li>
<li><p><code>run 参数</code></p>
<p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>单步命令</strong></li>
</ol>
<p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p>
<blockquote>
<ul>
<li><p><code>next</code></p>
<blockquote>
<p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p>
<p>next N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>step</code></p>
<blockquote>
<p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p>
<p>step N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>finish</code></p>
<p>执行程序到当前函数结束</p>
</li>
<li><p><code>continue</code></p>
<p>执行程序到下个断点</p>
</li>
<li><p><code>until</code></p>
<p>until N，执行程序到源代码的某一行</p>
</li>
</ul>
</blockquote>
<h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p>
<blockquote>
<ul>
<li><code>list</code></li>
<li><code>info breakpoints</code></li>
<li><code>break</code></li>
<li><code>delete</code></li>
<li><code>disable</code> 和 <code>enable</code></li>
<li><code>enable once</code> 和 <code>enable delete</code></li>
<li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li>
<li><code>info locals</code> 和 <code>print</code></li>
</ul>
</blockquote>
<p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>算法研究生课程学习笔记</title>
    <url>/2020/03/14/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-算法相关概念"><a href="#一-算法相关概念" class="headerlink" title="一.算法相关概念"></a>一.算法相关概念</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>算法(algorithm)是一个（由人或机器进行）关于某种运算规则的集合。是对特定问题求解步骤的一种描述，是指令的有限序列。</p>
<center><font color="red" size="6">输入——> {规则}——>输出</font></center>

<p><font color="red">确定性：</font>清晰，无歧义</p>
<p><font color="red">有限性：</font>指令执行次数、时间</p>
<p><strong>特点：</strong></p>
<ul>
<li>执行时，不能包含任何主观的决定；</li>
<li>不能有类似直觉/创造力等因素。</li>
</ul>
<p><strong>具有下列5个特性：</strong></p>
<ul>
<li>有穷性：算法有限步结束，指令有限时间完成</li>
<li>确定性：每条指令都是明确的、无二义的</li>
<li>可行性：每条指令都能够被执行</li>
<li>输入：有0个或多个输入量</li>
<li>输出：有1个或多个输出量</li>
</ul>
<h2 id="2-算法的衡量尺度"><a href="#2-算法的衡量尺度" class="headerlink" title="2.算法的衡量尺度"></a>2.算法的衡量尺度</h2><blockquote>
<p>最初，用所需计算时间来衡量算法的好坏,但是，不同的机器相互之间无法比较。所以需要独立于具体计算机的客观衡量标准。如：问题的规模，基本运算，算法的计算量函数。也可以通过时间复杂度(基本运算执行次数)和空间复杂度(需要的存储空间大小)。</p>
</blockquote>
<h3 id="1-问题的规模"><a href="#1-问题的规模" class="headerlink" title="1.问题的规模"></a>1.问题的规模</h3><ul>
<li><p>一个或多个整数，作为输入数据量的测度</p>
</li>
<li><p>数组的长度(数据项的个数)</p>
</li>
<li><p>矩阵的最大维数(阶数)</p>
</li>
</ul>
<h3 id="2-输入规模通常用n来表示"><a href="#2-输入规模通常用n来表示" class="headerlink" title="2.输入规模通常用n来表示"></a>2.输入规模通常用n来表示</h3><ul>
<li>也可有两个以上的参数，如图中的顶点数和边数 (图论中的问题)</li>
</ul>
<h3 id="3-基本运算"><a href="#3-基本运算" class="headerlink" title="3.基本运算"></a>3.基本运算</h3><blockquote>
<ul>
<li>解决给定问题时占支配地位的运算。</li>
<li>在一个表中寻找数据元素x</li>
<li>两个实矩阵的乘法</li>
<li>将一个数组进行排序</li>
</ul>
</blockquote>
<p>通常情况下，讨论一个算法的优劣时，我们只讨论基本运算的执行次数。因为他是占支配地位的，而其他的运算可以忽略不计。</p>
<h3 id="4-算法的计算量函数"><a href="#4-算法的计算量函数" class="headerlink" title="4.算法的计算量函数"></a>4.算法的计算量函数</h3><p>用输入规模的某个函数来表示算法的基本运算量，该函数称为算法的时间复杂性(度)，一般用T(n)或T(n,m)等表示。如：T(n) = 5n,  T(n) = 3n*logn,  T(n) = 4n3,  T(n) = 2n,  T(n,m) = 2(n+m).</p>
<p><strong>最坏情况时间复杂性</strong></p>
<p>规模为n的所有输入中，基本运算执行次数最多的时间复杂性。</p>
<blockquote>
<p>如：在一个顺序表中寻找数据元素x。顺序查找：最坏情况为O(n);  二分查找：最坏情况为O(logn)。</p>
</blockquote>
<p><strong>平均情况时间复杂性</strong></p>
<p>规模为n的所有输入的算法时间复杂度的平均值(一般均假设每种输入情况以等概率出现).</p>
<blockquote>
<p>如：在一个顺序表中寻找数据元素x。顺序查找：评价情况仍为O(n);  二分查找：平均情况仍为O(logn)。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2020/03/12/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="//zybtree.github.io/2020/03/12/Docker学习/1.png" alt></p>
<hr>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，它是由 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发实现的轻量级容器技术，它是基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它隔离的进程，因此也称其为容器。</p>
<img src="//zybtree.github.io/2020/03/12/Docker学习/2.png" style="zoom:50%;">

<hr>
<h2 id="二-概念"><a href="#二-概念" class="headerlink" title="二.概念"></a>二.概念</h2><h3 id="1-概要理解"><a href="#1-概要理解" class="headerlink" title="1.概要理解"></a>1.概要理解</h3><p>Docker支持安装各种软件并做好配置后编译成镜像，最终可以直接运行镜像产生一个或多个运行于宿主机内核上的容器。为了形象的理解容器，可以简单的理解它为运行在操作系统上的独立沙箱系统，这些沙箱系统内部的文件系统和Linux的非常相似，事实上确是如此，因为Docker就是融合了Linux内核而实现的虚拟化技术，由于具有沙箱的特性，所以各个容器之间是隔离运行的、独立的、互不影响的，程序员甚至不用担心容器内部损坏或者崩溃导致宿主机出错，因为只要删除掉这些有问题的容器，而再运行相关的镜像又会得到全新的容器了，只要不进行数据挂载，整个过程甚至干净不留残余。</p>
<h3 id="2-核心内容"><a href="#2-核心内容" class="headerlink" title="2.核心内容"></a>2.核心内容</h3><p><strong>docker主机(Host)：</strong>或者称为docker宿主机，即安装了Docker程序的机器。</p>
<p>**docker客户端(Client)：连接docker主机进行操作的程序。</p>
<p><strong>docker镜像(Images)：</strong>是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p><strong>docker容器(Container)：</strong>运行镜像后产生的实例称为容器，实质是运行于独立的<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>的进程。</p>
<p><strong>docker仓库(Registry)：</strong>集中存储、分发镜像的仓库服务系统，作用是允许用户上传、下载并管理镜像，包括公有仓库和私有仓库。</p>
<img src="//zybtree.github.io/2020/03/12/Docker学习/3.png" style="zoom:80%;">



<h3 id="3-对比传统虚拟机"><a href="#3-对比传统虚拟机" class="headerlink" title="3.对比传统虚拟机"></a>3.对比传统虚拟机</h3><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">虚拟机的架构</th>
<th align="center">容器的架构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">启动</td>
<td align="center">分钟级</td>
<td align="center">秒级</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">弱于原生</td>
<td align="center">接近原生</td>
</tr>
<tr>
<td align="center">硬盘使用</td>
<td align="center">一般为GB</td>
<td align="center">一般为MB</td>
</tr>
<tr>
<td align="center">系统支持量</td>
<td align="center">一般几十个</td>
<td align="center">单机上千个容器</td>
</tr>
</tbody></table>
<p><strong>虚拟机的架构：</strong> 每个虚拟机都包括应用程序、必要的二进制文件和库以及一个完整的客户操作系统(Guest OS)，尽管它们被分离，它们共享并利用主机的硬件资源，将近需要十几个 GB 的大小。</p>
<p><strong>容器的架构：</strong> 容器包括应用程序及其所有的依赖，但与其他容器共享内核。它们以独立的用户空间进程形式运行在宿主机操作系统上。他们也不依赖于任何特定的基础设施，Docker 容器可以运行在任何计算机上，任何基础设施和任何云上。</p>
<img src="//zybtree.github.io/2020/03/12/Docker学习/4.png" style="zoom:100%;">

<img src="//zybtree.github.io/2020/03/12/Docker学习/5.png" style="zoom:100%;">



<h3 id="4-优势"><a href="#4-优势" class="headerlink" title="4.优势"></a>4.优势</h3><p>（1）快速的启动时间</p>
<p>由于Docker容器直接运行于宿主内核，无需启动完整的操作系统即可运行，因此可以做到秒级、甚至毫秒级的启动时间，这大大的节约了开发、测试、部署的时间。</p>
<p>（2）一致的运行环境</p>
<p>开发过程中一个常见的问题是环境一致性问题。由于不同物理机的开发环境不一致，经常出现安装了相同的软件但却有不同的运行效果现象，甚至有的环境下还会出现bug。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，以至于不会再出现 “这段代码在我机器上没问题啊” 这类的问题。</p>
<p>（3）持续交付和部署</p>
<p>Docker可以一次创建或配置镜像，而可以在任意地方正常运行。即”一处构建，到处运行”。</p>
<p>（4）更方便的迁移</p>
<p><code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p>（5）更轻量的维护和扩展</p>
<p><code>Docker</code>使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的<a href="https://hub.docker.com/search/?type=image&image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<h3 id="5-分层存储"><a href="#5-分层存储" class="headerlink" title="5.分层存储"></a>5.分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="6-容器存储层"><a href="#6-容器存储层" class="headerlink" title="6.容器存储层"></a>6.容器存储层</h3><p>镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<h3 id="7-数据卷"><a href="#7-数据卷" class="headerlink" title="7.数据卷"></a>7.数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，当容器内部的目录(文件)映射到宿主机的某目录(文件)时，那么就称这个宿主机的目录(文件)为数据卷。它绕过 UFS，可以提供很多有用的特性，如下：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p>
</blockquote>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用<a href="https://yeasy.gitbooks.io/docker_practice/data_management/volume.html" target="_blank" rel="noopener">数据卷(Volume)</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<hr>
<h2 id="三-安装Docker"><a href="#三-安装Docker" class="headerlink" title="三.安装Docker"></a>三.安装Docker</h2><blockquote>
<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版，EE 即企业版，强调安全，付费使用。</p>
</blockquote>
<ul>
<li>由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get remove docker docker-engine docker-ce docker.io</span><br></pre></td></tr></table></figure></div>

<ul>
<li>更新apt包索引：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></div>

<ul>
<li>安装以下包以使apt可以通过HTTPS使用存储库(repository)：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure></div>

<ul>
<li>添加Docker官方的GPG密钥：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用下面的命令来设置<strong>stable</strong>存储库：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs</span><br></pre></td></tr></table></figure></div>

<ul>
<li>再更新一下apt包索引：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get update</span><br></pre></td></tr></table></figure></div>

<ul>
<li>安装最新版本的Docker CE：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在生产系统上，可能会需要应该安装一个特定版本的Docker CE，而不是总是使用最新版本,列出可用的版本：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> apt-cache madison docker-ce</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/03/12/Docker学习/7.png" style="zoom:50%;">

<p>选择要安装的特定版本，第二列是版本字符串，第三列是存储库名称，它指示包来自哪个存储库，以及扩展它的稳定性级别。要安装一个特定的版本，将版本字符串附加到包名中，并通过等号(=)分隔它们：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>例如：sudo apt-get install docker-ce=5:19.03.7<del>3-0</del>ubuntu-bionic</p>
</blockquote>
<hr>
<h2 id="四-验证Docker"><a href="#四-验证Docker" class="headerlink" title="四.验证Docker"></a>四.验证Docker</h2><ul>
<li>查看docker服务是否启动：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl status docker</span><br></pre></td></tr></table></figure></div>

<ul>
<li>若未启动，则启动docker服务：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo systemctl start docker</span><br></pre></td></tr></table></figure></div>

<ul>
<li>经典的hello world：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo docker pull hello-world</span><br><span class="line"><span class="meta">$</span> sudo docker run hello-world</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/03/12/Docker学习/6.png" style="zoom:50%;">

<hr>
<h2 id="五-镜像下载加速"><a href="#五-镜像下载加速" class="headerlink" title="五.镜像下载加速"></a>五.镜像下载加速</h2><p>鉴于国内网络问题，Docker默认是从官方Docker Hub拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。</p>
<ul>
<li><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 <code>https://dockerhub.azk8s.cn</code></a></li>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li>
<li><a href="https://www.163yun.com/help/documents/56918246390157312" target="_blank" rel="noopener">网易云加速器 <code>https://hub-mirror.c.163.com</code></a></li>
</ul>
<blockquote>
<p>测速：<a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">https://github.com/docker-practice/docker-registry-cn-mirror-test/actions</a></p>
</blockquote>
<p>编辑 <code>/etc/docker/daemon.json</code>（Linux） 或者 <code>%programdata%\docker\config\daemon.json</code>（Windows） 来配置 Daemon（如果文件不存在请新建该文件）。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></div>

<p>添加以下内容：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span>,</span><br><span class="line">    <span class="string">"https://hub-mirror.c.163.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>可以配置多个加速镜像。由于镜像服务可能出现宕机，建议同时配置多个加速镜像。</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>重新加载配制</span><br><span class="line"><span class="meta">$</span> systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span>重启docker</span><br><span class="line"><span class="meta">$</span> service docker restart</span><br><span class="line"><span class="meta">#</span>检查加速器是否生效</span><br><span class="line"><span class="meta">$</span> docker info</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果方便建议使用aliyun的镜像</p>
<p>地址：<a href="https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-shenzhen/instances/mirrors</a></p>
</blockquote>
<p><img src="//zybtree.github.io/2020/03/12/Docker学习/9.png" alt></p>
<hr>
<h2 id="六-镜像操作"><a href="#六-镜像操作" class="headerlink" title="六.镜像操作"></a>六.镜像操作</h2><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>检索	(去https://hub.docker.com上查看镜像的详细信息。eg：docker search redis)</span><br><span class="line"><span class="meta">$</span> docker  search 镜像关键字</span><br><span class="line"><span class="meta">#</span>拉取	(name是镜像名，:tag是可选的，tag表示标签，多为软件的版本，默认是latest)</span><br><span class="line"><span class="meta">$</span> docker pull name[:tag]</span><br><span class="line"><span class="meta">#</span>列出	(查看所有本地镜像)</span><br><span class="line"><span class="meta">$</span> docker images</span><br><span class="line"><span class="meta">#</span>删除	(删除指定的本地镜像,image-id是镜像id)</span><br><span class="line"><span class="meta">$</span> docker rmi image-id</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="七-容器操作"><a href="#七-容器操作" class="headerlink" title="七.容器操作"></a>七.容器操作</h2><p><img src="//zybtree.github.io/2020/03/12/Docker学习/8.png" alt></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git提速代理</title>
    <url>/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>因为平时在Ubuntu虚拟机上使用Git clone的时候速度特别慢，使用干脆写个代理文件进行提速。</p>
</blockquote>
<h2 id="梯子准备"><a href="#梯子准备" class="headerlink" title="梯子准备"></a>梯子准备</h2><p>在主机上挂个梯子，然后查看IP地址与端口(确保能使用)。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">	options=400&lt;CHANNEL_IO&gt;</span><br><span class="line">	ether 38:f9:d3:8d:58:3e</span><br><span class="line">	inet6 fe80::1434:df1:87d5:7e09%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">	inet 192.168.1.4 netmask 0xffffff00 broadcast 192.168.1.255</span><br><span class="line">	nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br></pre></td></tr></table></figure></div>

<img src="//zybtree.github.io/2020/03/11/Git提速代理/1.png" style="zoom:50%;">

<p>我的IP与端口:192.168.1.4:7890</p>
<h2 id="写代理文件"><a href="#写代理文件" class="headerlink" title="写代理文件"></a>写代理文件</h2><p>在Ubuntu上写代理文件，在与Desktop同一级的目录下新建.gitconfig文件并进行编辑。</p>
<p><img src="//zybtree.github.io/2020/03/11/Git提速代理/2.png" alt></p>
<p>这样就可以加速了。实践一下。</p>
<p><img src="//zybtree.github.io/2020/03/11/Git提速代理/3.png" alt></p>
<p>这个速度就爽多！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下C链接Mysql</title>
    <url>/2020/03/02/Linux%E4%B8%8BC%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装数据库"><a href="#1-安装数据库" class="headerlink" title="1.安装数据库"></a>1.安装数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqld-dev</span><br></pre></td></tr></table></figure></div>

<h2 id="2-查看安装包"><a href="#2-查看安装包" class="headerlink" title="2.查看安装包"></a>2.查看安装包</h2><p>2.查看本地有没有安装mysql的开发包。命令是  ‘mysql_config –cflags –libs’如果有安装就会有一串编译选项和连接库。如果没有就自行安装 mysql-devel-*****的rpm包后面是版本号。mysql开发包提供了基本操作接口。安装后头文件在/usr/include/mysql 而动态库在 /usr/lib/mysql 上。</p>
<p><img src="//zybtree.github.io/2020/03/02/Linux下C链接数据库/1.png" alt></p>
<h2 id="3-编写C程序链接数据库"><a href="#3-编写C程序链接数据库" class="headerlink" title="3.编写C程序链接数据库"></a>3.编写C程序链接数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *conn;</span><br><span class="line">    MYSQL_RES *res;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> *server = <span class="string">"localhost"</span>;</span><br><span class="line">   <span class="keyword">char</span> *user = <span class="string">"root"</span>;</span><br><span class="line">   <span class="keyword">char</span> *password = <span class="string">"ZYB110929"</span>; <span class="comment">/* 此处改成你的密码 */</span></span><br><span class="line">   <span class="keyword">char</span> *database = <span class="string">"mysql"</span>;</span><br><span class="line"></span><br><span class="line">    conn = mysql_init(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Connect to database */</span></span><br><span class="line">   <span class="keyword">if</span> (!mysql_real_connect(conn, server,</span><br><span class="line">          user, password, database, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* send SQL query */</span></span><br><span class="line">   <span class="keyword">if</span> (mysql_query(conn, <span class="string">"show tables"</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    res = mysql_use_result(conn);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* output table name */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"MySQL Tables in mysql database:\n"</span>);</span><br><span class="line">   <span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, row[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* close connection */</span></span><br><span class="line">    mysql_free_result(res);</span><br><span class="line">    mysql_close(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test $(mysql_config --cflags) $(mysql_config --libs)</span><br></pre></td></tr></table></figure></div>

<p><img src="//zybtree.github.io/2020/03/02/Linux下C链接数据库/2.png" alt></p>
<p>实践成功。</p>
<p>​            </p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Mysql</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>疫情下的自学计划</title>
    <url>/2020/03/02/%E7%96%AB%E6%83%85%E4%B8%8B%E7%9A%84%E8%87%AA%E5%AD%A6%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>这个情况谁也想不到，谁也没办法，而自己能做的也只有改变心态，坚持奋斗，继续减肥。</p>
</blockquote>
<h2 id="学校课程计划"><a href="#学校课程计划" class="headerlink" title="学校课程计划"></a>学校课程计划</h2><h3 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h3><ul>
<li><p>信息论</p>
<p>​    每周两章，GoodNotes做笔记。</p>
</li>
<li><p>云计算</p>
<p>​    每周三网上网课认真听，为了以后学习Docker打好基础，也许之后走这条路也说不定。</p>
</li>
<li><p>算法</p>
<p>​    第三周上网课，重中之重，争取一年把算法导论这本书看完，并用C++实践。学术英语</p>
</li>
<li><p>学术英语 </p>
<p>​    每周四上午的网课。上完课第二天把PPT笔记精华部分写入GoodNotes，为期末考试做准备。</p>
</li>
</ul>
<h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><p>​    每天上午8:00 - 11:30进行学校课程的学习。中间每隔一个小时跳绳 1000下，上午累计3k</p>
<br>

<h2 id="网络安全计划"><a href="#网络安全计划" class="headerlink" title="网络安全计划"></a>网络安全计划</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>协议栈侧OAM代码学习和文档整理。</p>
<p>要求能掌握代码及TR196协议，并熟悉对接网关侧OAM，阶段性输出相应文档。</p>
<h3 id="工作细分"><a href="#工作细分" class="headerlink" title="工作细分"></a>工作细分</h3><p>（一）OAM的代码分析和流程整理<br>1、OAM接口文档学习</p>
<p>2、CU OAM代码学习及文档整理</p>
<p>​    2.1 OAM任务启动流程</p>
<p>​    2.2 OAM与L3的交互</p>
<p>​    2.3 OAM与RRM的交互</p>
<p>​    2.4 OAM与IPRelay的接口</p>
<p>​    2.5 OAM与PDCP的接口</p>
<p>​    2.6 OAM与网关侧的接口（TBD参考项目需求）</p>
<p>3、DU OAM代码学习及文档整理</p>
<p>​    3.1 OAM任务启动流程</p>
<p>​    3.2 OAM与DUMGR的交互</p>
<p>​    3.3 OAM与RLC的交互</p>
<p>​    3.4 OAM与MAC的接口</p>
<p>​    3.5 OAM与IPRelay的接口</p>
<p>​    3.6 OAM与网关侧的接口（TBD参考项目需求）</p>
<h3 id="时间安排-1"><a href="#时间安排-1" class="headerlink" title="时间安排"></a>时间安排</h3><h4 id="1、CU-OAM模块学习"><a href="#1、CU-OAM模块学习" class="headerlink" title="1、CU-OAM模块学习"></a>1、<strong>CU-OAM模块学习</strong></h4><p>2020.2.24 – 3.8 CU-OAM接口文档学习，熟悉CU-OAM与周围模块L3、RRM、IPRelay、PDCP等的接口流程和参数内容，并结合代码对照分析</p>
<p>3.9 – 3.15 CU-OAM任务启动流程，代码研读并总结文档</p>
<p>3.16 – 3.22 CU-OAM内部数据模型和消息结构处理流程，代码研读并总结文档 </p>
<h4 id="2、-DU-OAM模块学习"><a href="#2、-DU-OAM模块学习" class="headerlink" title="2、 DU-OAM模块学习"></a><strong>2、</strong> <strong>DU-OAM模块学习</strong></h4><p>3.23 – 4.5 DU-OAM接口文档学习，熟悉DU-OAM与周围模块DU-MGR、RLC、MAC、IPRelay等的接口流程和参数内容，并结合代码对照分析</p>
<p>4.6 – 4.12 DU-OAM任务启动流程，代码研读并总结文档</p>
<p>4.13 – 4.19 DU-OAM内部数据模型和消息结构处理流程，代码研读并总结文档</p>
<p>下午1:30-5:00进行协议学习，每天都要看，在GoodNotes上做好笔记。每1小时跳绳一千，累计3k.</p>
<br>

<h2 id="C-自学计划"><a href="#C-自学计划" class="headerlink" title="C++自学计划"></a>C++自学计划</h2><h4 id="C计划"><a href="#C计划" class="headerlink" title="C计划"></a>C计划</h4><p>15天把《C Primer Plus》这本书的重点部分看完，书上代码实现一遍，重点知识点写入博客。</p>
<h3 id="C-计划"><a href="#C-计划" class="headerlink" title="C++计划"></a>C++计划</h3><p>20天把《How to program C++》这本书看完，书上代码实现一遍，重点知识点写入博客，看完还是不是很清楚的部分回头看《C++ Primer Plus》这本书对应的知识点。</p>
<hr>
<blockquote>
<p>没完成对应的部分，用红色字体写下感想，弯路和规划。</p>
</blockquote>
]]></content>
      <categories>
        <category>研究生学习</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>关于方向&关于C++</title>
    <url>/2020/03/01/%E5%85%B3%E4%BA%8E%E6%96%B9%E5%90%91-%E5%85%B3%E4%BA%8EC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>就业与思考</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>雅思口语积累</title>
    <url>/2019/11/20/%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本话题"><a href="#基本话题" class="headerlink" title="基本话题"></a>基本话题</h1><h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><p><strong>What is your name?</strong></p>
<p>My full name is ZhangYongBin,you can call me Bin.</p>
<br>

<p><strong>Who give this name to you?</strong></p>
<p>The name was given by my father.Yong, in chinese, means lasting forever. And Bin, this word,consists of two words: Wen and Wu, which represent intellectual and brave. My parents told me that they wanted me to be knowledgeable and confident.</p>
<br>

<p><strong>Have you ever changed any name before?</strong></p>
<p>Nope, I haven’t. And I have never thought about it. I think my name is the first and one of the most invaluable gifts that i have ever got from my parents. This name is of great sentimental value to me and will accompany me forever.</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>口语练习</tag>
      </tags>
  </entry>
  <entry>
    <title>台湾清华彭明辉教授的研究生手册收获</title>
    <url>/2019/11/11/%E5%8F%B0%E6%B9%BE%E6%B8%85%E5%8D%8E%E5%BD%AD%E6%98%8E%E8%BE%89%E6%95%99%E6%8E%88%E7%9A%84%E7%A0%94%E7%A9%B6%E7%94%9F%E6%89%8B%E5%86%8C%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论文的要求"><a href="#论文的要求" class="headerlink" title="论文的要求"></a>论文的要求</h1><ul>
<li><p>论文的主要内容，是叙述一套<font color="red">方法</font>在特定<font color="red">场合</font>中的应用。</p>
</li>
<li><p>这套方法必须要有所<font color="red">创新或突破</font>，并因而对<font color="red">学术界有所贡献</font>。它或者是解决既有问题的<font color="red">新方法</font>，或者是既有方法的<font color="red">新应用</font>， 或者是以一个新的方法开启一整片新的应用领域。 </p>
</li>
<li><p>在论文中，你必须要有能力<font color="red">提出足够的证据</font>来让读者信服说：针对这个应用场合，你所提出来的方法确实有比文献中一切既有方法更优越之处。 </p>
</li>
<li><p>此外，你必须要能清楚指出这个方法在应用上的限制，并且提出充分证据来说服读者：任何应用场合，只要能够满足你所提出来的<font color="red">假设（前提）条件</font>，你的方法就一定适用，而且你所描述的优点就一定会存在。</p>
</li>
<li><p>你还必须要在论文中清楚指出这个方法的<font color="red">限制和可能的缺点</font>（相对于其它文献上的既有方法，或者在其它应用场合里）。假如这个方法有任何重大缺点，在口试时才会被口试委员会指出来，其后果可能是论文无法通过。</p>
</li>
<li><p>行文风格上，它是一篇论证严谨，逻辑关系清晰，而且结构有条理的专业论述。也就是说，在叙述你的方法的过程，你必须要清清楚楚地交代这个方法的应用程序以及所有仿真或实验结果的过程，<font color="red">使得这个专业领域内的任何读者，都有办法根据你的描述，在他的实验室下复制出你的研究成果</font>，以便确定你的结论确实是可以「在任何时间、任何地点、任何人」都具有可重复性（可重复性是「科学」的根本要求）。 </p>
</li>
<li><p>而且，你对这个方法的<font color="red">每一个步骤都必须要提供充分的理由说明</font>「为什么非如此不可」。 </p>
</li>
<li><p>最后，你的论文必须要在适当位置清楚<font color="red">注明所有和你所研究之题目相关的文献</font>。而且，你必须要记得：只要是和你所研究的问题相关的学术文献（尤其是学术期刊论文），你都有必要全部找出来（如果漏掉就是你的过失），仔细读过。<font color="red">假如你在学位论文口试时，有口试委员指出有一篇既有文献，在你所讨论的问题中处理得比你的方法还好，这就构成你论文无法及格的充分理由。 </font></p>
</li>
<li><p>第（2）款所谓「对学术界的贡献」，指的是：把你的所有研究成果扣除掉学术界已经发表过的所有成果（不管你实际上有没有参考过，没有参考过也算是你的重大过失），剩下的就是你的贡献。<font color="red">假如这个贡献太少，也构成你论文无法及格的充分理由。 </font></p>
</li>
</ul>
<p>　　</p>
<blockquote>
<p>上面所叙述的九款要件中，除第（2）款之外，通通都是必须要做到的，因此没有好坏之分。一篇硕士论文的好坏（以及成绩的评定标准），主要是看第（2）款所谓「对学术界的贡献」的多寡与重要性而定。假如你要申请国外的博士班，最重要的也是看你的硕士论文有什么「贡献」而定（这往往比TOFEL，GRE，GPA还重要）。</p>
</blockquote>
<br>

<hr>
<br>

<h1 id="完成硕士论文所需要的能力"><a href="#完成硕士论文所需要的能力" class="headerlink" title="完成硕士论文所需要的能力"></a>完成硕士论文所需要的能力</h1><blockquote>
<p> 从前面的叙述可以归纳出来，完成硕士论文所需要的能力包括以下数项，依它们的培养先后次序逐项讨论。  </p>
</blockquote>
<ul>
<li><font color="red"><strong>数据检索的能力：</strong></font>在给定（或自己拟定）的题目范围内，你必须有能力利用文资料索引系统，查出所有相关的论文，而无任何遗漏（否则你可能在论文口试时才发现同一个题目已经有人发表过了）。<font color="red">你到底要用什么样的关键词和查所程序去保证你已经找出所有相关的文献？这是第一个大的挑战。</font>每一组关键词（包含联集与交集）代表一个论文所构成的集合，假如你用的关键词不恰当，你可能找到的集合太小，没有涵盖所有的相关文献；假如你用的关键词太一般化（譬如「image」），通常你找到的集合会太大，除了所有相关文献之外还加上好几十倍的毫不相关的文献。 </li>
</ul>
<ul>
<li><font color="red"><strong>资料筛选的能力</strong></font>：即使你使用了恰当的搜寻策略，通常找到的文献集合都还是明显地比你所需要的集合大，而且通常文献比数大概在一两百篇或数百篇之间，而其中会和你的的研究子题直接且密切相关的论文，通常只有廿、卅篇左右。你如何可以<font color="red">只读论文的题目、摘要、简介和结论</font>，而还没有完全看懂内文，就准确地判断出这篇论文中是否有值得你进一步参考的内容，以便快速地把需要仔细读完的论文从数百篇降低到廿、卅篇？这考验着你从事资料筛选的能力。</li>
</ul>
<ul>
<li><font color="red"><strong>期刊论文的阅读能力</strong></font>：期刊论文和大学部的课本截然不同。大学部的课本是寻次渐进地从最基本的知识背景逐步交代出整套有系统的知识，中间没有任何的跳跃，只要你逐页读下去，就可以整本都读懂，不需要在去别的地方找参考资料。但是期刊论文是没头没尾的十几页文献，只交代最核心的创意，并援引许多其它论文的研究成果（但只注明文献出处，而完全没有交代其内容）。因此，要读懂一篇论文，一定要同时读懂数篇或十数篇被援引的其它论文。偏偏，这十几篇被援引的论文又各自援引十数篇其它论文。<strong>因此，相对于大学部的教科书而言，期刊论文是一个极端没有系统的知识，必须要靠读者自己从几十篇论文中撷取出相关的片段，自己组织成一个有系统的知识，然后才有办法开始阅读与吸收。</strong><font color="red">要培养出这种自己组织知识的能力，需要在学校靠着大量而持续的时间去摸索、体会，而不可能只利用业余的零星时间去培养。</font>因此，一个大学毕业后就不再念研究所的学生，不管他在大学有多优秀，都很难在工业界利用业余的时间去培养这种能力。所以，<font color="red">*<em>硕士毕业生和大学毕业生最大的差别，就是：学士只学习过吸收系统知识的能力（也就是读别人整理、组织好的知识，典型的就是课本）；但硕士则学习过自己从无组织的知识中检索、筛选、组织知识的能力。 *</em></font></li>
</ul>
<ul>
<li><font color="red"><strong>期刊论文的分析能力</strong></font>：<strong>为了确定你的学位论文研究成果确实比所有相关的学术期刊论文都更适合处理你所拟定的应用场域，首先你必须要有能力逐篇分析出所有相关期刊论文的优点与缺点，以及自己的研究成果的优点与缺点，然后再拿他们来做比较，总结出你的论文的优点和缺点（限制）。</strong>但是，好的期刊论文往往是国外著名学府的名师和一流的博士生共同的研究成果，假如你要在锁定的应用场域上「打败」他们，突出自己的优点，这基本上是一个极端困难的挑战。即使只是要找出他们的缺点，都已经是一个相当困难的工作了。一个大学毕业生，四年下来都是假定「课本是对的」这样地学下来的，从来没有学习如何分析课本知识的优缺点，也就是<font color="red">「只有理解的能力，而没有批判的能力」。硕士生则必须要有「对一切既有进行精确批判」的能力。</font>但是，这个批判并非个人好恶或情绪化的批判，而是真的找得到充分理由去支持的批判。这个批判的能力，让你有能力自己找到自己的优、缺点，因此也有机会自己精益求精。所以，一个大学毕业生在业界做事的时候，需要有人指导他（从事批判性检验），帮他找出缺点和建议改进的可能性。但是，<font color="red">一个严格训练过的合格硕士，他做事的时候应该是不需要有人在背后替他做检证，他自己就应该要有能力分析自己的优、缺点，主动向上级或平行单位要求支持。其实，至少要能够完成这个能力，才勉强可以说你是有「独立自主的判断能力」。 </font></li>
</ul>
<ul>
<li><font color="red"><strong>创新的能力</strong></font>：许多大学毕业的工程师也能创新，但是硕士的创新是和全世界同一个学术团体内所有的名师和博士生挑战。因此，两者是站在不同的比较基础上在进行的：前者往往是一个企业内部的「闭门造车」，后者是一个全球的开放性竞争。其次，工程师的创新往往是无法加以明确证明其适用条件，但是学术的创新却必须要能够在创新的同时厘清这个创新的有效条件。因此，<font color="red">大学毕业生的主要能力是吸收既有知识，但硕士毕业生却应该要有能力创造知识。</font>此外，台湾历年来工业产品的价位偏低，这一部分是因为国际大厂的打压以及国际消费者的信任不易建立。但是，另一方面，这是因为台湾的产品在品质上无法控制，因此只好被当作最粗糙的商品来贩卖。台湾的产品之所以无法有稳定的品质，背后的技术原因就是：各种创新都是只凭一时偶然的巧思，却没有办法进一步有系统地厘清这些巧思背后可以成立的条件。但是，创新其实是可以有一套「有迹可寻」的程序的，这是我最得意的心得，也是我最想教的。 </li>
</ul>
<br>

<hr>
<br>

<h1 id="为什么要坚持培养阅读与分析期刊论文的能力"><a href="#为什么要坚持培养阅读与分析期刊论文的能力" class="headerlink" title="为什么要坚持培养阅读与分析期刊论文的能力"></a>为什么要坚持培养阅读与分析期刊论文的能力</h1><p>​    只要能够充分掌握阅读与分析期刊论文的技巧，就可以水到渠成地轻松进行「创新」的工作。所以，<font color="red"><strong>只要深入掌握到阅读与分析期刊论文的技巧</strong></font>，<font color="blue">就可以掌握到大学生不曾研习过的三种能力</font>：<font color="red">（1）自己从无组织的知识中检索、筛选、组织知识的能力、（2）对一切既有进行精确批判的独立自主判断能力、（3）创造新知识的能力。  </font></p>
<br>

<hr>
<br>

<h1 id="期刊论文的分析技巧和程序"><a href="#期刊论文的分析技巧和程序" class="headerlink" title="期刊论文的分析技巧和程序"></a>期刊论文的分析技巧和程序</h1><blockquote>
<p> 一般来讲，好的期刊论文有较多的创意。虽然读起来较累，但收获较多而深入，因此比较值得花心思去分析。读论文之前，参考SCI Impact Factor 及学长的意见是必要的。  </p>
</blockquote>
<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>​    说明这篇论文的主要贡献、方法特色与主要内容。最慢硕二上学期必须要学会只看 Abstract 和Introduction便可以判断出这篇论文的重点和你的研究有没有直接关连，从而决定要不要把它给读完。<font color="red">假如你有能力每三十篇论文只根据摘要和简介便能筛选出其中最密切相关的五篇论文，你就比别人的效率高五倍以上。以后不管是做事或做学术研究，都比别人有能力从更广泛的文献中挑出最值得参考的资料。  </font></p>
<h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>​    Introduction 的功能是介绍问题的背景和起源，交代前人在这个题目上已经有过的主要贡献，说清楚前人留下来的未解问题，以及在这个背景下这篇论文的想解决的问题和它的重要性。对初学的学生而言，从这里可以了解以前研究的概况。<strong>通常我会建议初学的学生，对你的题目不熟时，先把跟你题目可能相关的论文收集个 30～40篇，每篇都只读Abstract 和 Introduction，而不要读 Main Body（本文），只在必要时稍微参考一下后面的 Illustrative examples和 Conclusions，直到你能回答下面这三个问题：</strong><font color="red">（2A）在这领域内最常被引述的方法有哪些？（2B）这些方法可以分成哪些主要派别？（2C）每个派别的主要特色（含优点和缺点）是什么？</font></p>
<p>　　问题是，你怎么去找到这最初的30～40篇论文？有一种期刊论文叫做「review paper」，专门在一个题目下面整理出所有相关的论文，并且做简单的回顾。你可以在搜寻 Compendex 时在 keywords 中加一个「review」而筛选出这类论文。然后从相关的数篇review paper 开始，从中根据 title 与 Abstract 找出你认为跟你研究题目较相关的30～40篇论文。 </p>
<p>　　通常只要你反复读过该领域内30～40篇论文的Abstract 和 Introduction，你就应该可以从Introduction的评论中回答（2A）和（2B）这两个问题。<strong>尤其要记得，当你阅读的目的是要回答（2A）和（2B）这两个问题时，你一定要先挑那些 Introduction写得比较有观念的论文念（很多论文的Introduction 写得像流水帐，没有观念，这种论文刚开始时不要去读它）。</strong>假如你读过假如30～40篇论文的 Abstract 和 Introduction之后，还是回答不了（2C），先做下述的工作。 </p>
<p>　　你先根据（2A）的答案，把这领域内最常被引述的论文找齐，再把他们根据（2B）的答案分成派别，每个派别按日期先后次序排好。然后，你每次只重新读一派的 Abstract 和 Introduction（必要时简略参考内文，但目的只是读懂Introduction内与这派有关的陈述，而不需要真的看懂所有内文），照日期先后读 ，读的时候只企图回答一个问题：<font color="red">这一派的创意与主要诉求是什么？</font>这样，你逐派逐派地把每一派的Abstract 和 Introduction 给读完，总结出这一派主要的诉求 、方法特色和优点（每一篇论文都会说出自己的优点，仔细读就不会漏掉）。 </p>
<p>　　其次，你再把这些论文拿出来，但是只读Introduction，认真回答下述问题：<font color="red">「每篇论文对其它派别有什么批评？」然后你把读到的重点逐一记录到各派别的「缺点」栏内。 </font></p>
<p>　　通过以上程序，你就应该可以掌握到（2A）、（2B）、和（2C）三个问题的答案。这时你对该领域内主要方法、文献之间的关系算是相当熟捻了，但是你还是只仔细 读完Abstract 和 Introduction而已，内文则只是笼统读过。<br>　　这时候，你已经掌握到这领域主要的论文，你可以用这些论文测试看看你用来搜寻这领域论文的 keywords 到底恰不恰当，并且用修正过的 keywords 再搜寻一次论文，把这领域的主要文献补齐，也把原来30～40篇论文中后来发现关系较远的论文给筛选掉，只保留大概20篇左右确定跟你关系较近的文献。如果有把握，可以甚至删除一两个你不想用的派别（要有充分的理由），只保留两、三个派别（也要有充分的理由）继续做完以下工作。 </p>
<p>　　然后你应该利用（2C）的答案，再进一步回答一个问题<font color="red">（2D）：「这个领域内大家认为重要的关键问题有哪些？有哪些特性是大家重视的优点？有哪些特性是大家在意的缺点？这些优点与缺点通常在哪些应用场合时会比较被重视？在哪些应用场合时比较不会被重视？」</font>然后，你就可以整理出这个领域（研究题目）主要的应用场合，以及这些应用场合上该注意的事项。 </p>
<p>　　最后，*<em>在你真正开始念论文的 main body 之前，你应该要先根据（2A）和（2C的答案，把各派别内的论文整理在同一个档案夹里，并照时间先后次序排好。然后依照这些派别与你的研究方向的关系远近，一个派别一个派别地逐一把各派一次念完一派的 main bodies。 *</em></p>
<h2 id="3-Main-body（含simulation-and-or-experimental-examples）："><a href="#3-Main-body（含simulation-and-or-experimental-examples）：" class="headerlink" title="3. Main body（含simulation and/or experimental examples）："></a>3. Main body（含simulation and/or experimental examples）：</h2><p>　　在你第一次有系统地念某派别的论文 main bodies 时，你只需要念懂：</p>
<ul>
<li><p><font color="red">（3A）这篇论文的主要假设是什么（在什么条件下它是有效的），并且评估一下这些假设在现实条件下有多容易（或多难）成立。愈难成立的假设，愈不好用，参考价值也愈低。</font></p>
</li>
<li><p><font color="red">（3B）在这些假设下，这篇论文主要有什么好处。</font></p>
</li>
<li><p><font color="red">（3C）这些好处主要表现在哪些公式的哪些项目的简化上。</font></p>
<p>​    至于整篇论文详细的推导过程，你不需要懂。除了三、五个关键的公式（最后在应用上要使用的公式，你可以从这里评估出这个方法使用上的方便程度或计算效率，以及在非理想情境下这些公式使用起来的可靠度或稳定性）之外，其它公式都不懂也没关系，公式之间的恒等式推导过程可以完全略过去。<font color="red">假如你要看公式，重点是看公式推导过程中引入的假设条件，而不是恒等式的转换。</font> </p>
</li>
</ul>
<p>​    但是，在你开始根据前述问题念论文之前，你应该先把这派别所有的论文都拿出来，逐篇粗略地浏览过去（不要勉强自己每篇或每行都弄到懂，而是轻松地读，能懂就懂，不懂就不懂），从中挑出容易念懂的 papers，以及经常被引述的论文。然后把这些论文照时间先后次序依序念下去。记得：你念的时候只要回答（3A）、（ 3B）、（3C）三个问题就好，不要念太细。<br>　　这样念完以后，你应该把这一派的主要发展过程，主要假设、主要理论依据、以及主要的成果做一个完整的整理。其次，你还要在根据（2D）的答案以及这一派的主要假设，进一步回答下一个问题：<font color="red">（3D）这一派主要的缺点有哪些。</font>最后，根据（ 3A）、（3B）、（3C）、（3D）的答案综合整理出：这一派最适合什么时候使用，最不适合什么场合使用。 </p>
<p>　　<font color="red">记住：回答完这些问题时，你还是不应该知道恒等式是怎么导出来的！ </font></p>
<p>　　当你是生手的时候，你要评估一个方法的优缺点时，往往必须要参考它Examples。但是，要记得：老练的论文写作高手会故意只 present 成功的案例而遮掩失败的案例。所以，simulation examples and/or experiments 很棒不一定表示这方法真的很好。你必须要回到这个方法的基本假设上去，以及他在应用时所使用的主要公式（resultant equations）去，凭自己的思考能力， 并且参考（2C）和（2D）的答案，自己问问看：当某某假设在某些实用场合上无法成立时，这个方法会不会出什么状况？猜一猜，预测一下这个方法应该会在哪些条件下（应用场合）表现优异，又会在哪些条件下（应用场合）出状况？根据这个猜测再检验一次simulation examples and/or experiments，看它的长处与短处是不是确实在这些examples 中充分被检验，且充分表现出来。 </p>
<p>　　<font color="red">那么，你什么时候才需要弄懂一篇论文所有的恒等式推导过程，或者把整篇论文细细读完？NEVER！你只需要把确定会用到的部分给完全搞懂就好，</font>不确定会不会用到的部分，只需要了解它主要的点子就够了。 </p>
<p>　　硕士生和大学生最主要的差别：大学生读什么都必须要从头到尾都懂，硕士生只需要懂他用得着的部分就好了！大学生因为面对的知识是有固定的范围，所以他那样念。硕士生面对的知识是没有范围的，因此他只需要懂他所需要的细腻度就够了。<font color="red">硕士生必须学会选择性的阅读，而且必须锻炼出他选择时的准确度以及选择的速度，不要浪费时间在学用不着的细节知识！多吸收「点子」比较重要，而不是细部的知识。 </font></p>
<p><img src="//zybtree.github.io/2019/11/11/台湾清华彭明辉教授的研究生手册收获/1.png" alt>)<img src="//zybtree.github.io/2019/11/11/台湾清华彭明辉教授的研究生手册收获/2.png" alt></p>
<br>

<hr>
<br>

<h1 id="论文阅读的补充说明"><a href="#论文阅读的补充说明" class="headerlink" title="论文阅读的补充说明"></a>论文阅读的补充说明</h1><p>​       硕士生开始学读期刊论文时，就容易犯的毛病就是戒除不掉大学部的习惯：<font color="red">（1）老是想逐行读懂，有一行读不懂就受不了。（2）不敢发挥自己的想象，读论文像在读教科书，论文没写的就不会，瘫痪在那里；被我逼着去自己猜测或想象时，老怕弄错作者的意思，神经绷紧，脑筋根本动不了。 </font></p>
<p>　　大学毕业后（不管是念硕、博士或工作），可以参考的资料都没有秩序地交错成一团，而且永远都读不完。用大学生的心态读书，结果一定时间永远不够用。<strong>因此，每次读论文都一定要带着问题去读，每次读的时候都只是图回答你要回答的问题。因此，一定是选择性地阅读，一定要逐渐由粗而细地一层一层去了解。上面所规划的读论文的次序，就是由粗而细，每读完一轮，你对这问题的知识就增加一层。根据这一层知识就可以问出下一层更细致的问题，再根据这些更细致的问题去重读，就可以理解到更多的内容。</strong><font color="red">因此，一定是一整批一起读懂到某个层次，而不是逐篇逐篇地整篇一次读懂。 </font></p>
<p>　　这样读还有一个好处：<strong>第一轮读完后，可以根据第一轮所获得的知识判断出哪些论文与你的议题不相关，不相关的就不需要再读下去了。</strong>这样才可以从广泛的论文里逐层准确地筛选出你真正非懂不可的部分。<font color="red">不要读不会用到的东西，白费的力气必须被极小化！其实，绝大部分论文都只需要了解它的主要观念（这往往比较容易），而不需要了解它的详细推导过程（这反而比较费时）。 </font></p>
<p>　　其次，一整批一起读还有一个好处：同一派的观念，有的作者说得较易懂，有的说得不清楚。<font color="red">整批读略过一次之后，就可以规划出一个你以为比较容易懂的阅读次序，而不要硬碰硬地在那里撞墙壁。你可以从甲论文帮你弄懂以论文的一个段落，没人说读懂甲论文只能靠甲论文的信息。所以，整批阅读很像在玩跳棋，你要去规划出你自己阅读时的「最省力路径」。 </font></p>
<p>　　大学部学生读东西一定要循规蹈矩，你还没修过机械视觉相关课程之前可能也只好循规蹈矩地逐行去念。但是一旦修过机械视觉相关课程，许多论文中没被交代的段落你也已经可以有一些属于你的想象（虽然有可能猜错，尤其刚开始时经常猜错，但没关系，下面详述）。这些想象往往补足论文跳跃处最快速的解决方案。其实，一个大学毕业生所学已经很多了，对许多是都可以有一个不太离谱的想象能力。但是大部分学生却根本不敢去想象。<font color="red">我读论文远比学生快，分析远比学生深入，主要的是我敢想象与猜测，而且多年训练下来想象与猜测的准确度很高。所以，许多论文我根本不是「读懂」的，而是「猜对」了！ </font></p>
<p>　　假如猜错了怎么办？不用怕！猜完一后要根据你的猜测在论文里找证据，用以判断你的猜测对不对。猜对了，就用你的猜测（其实是你的推理架构）去吸收作者的资讯与创意（这会比从头硬生生地去迁就作者的思路轻松而容易）；猜错了，论文理会有一些信息告诉你说你错了，而且因为猜错所以你读到对的答案时反而印象更深刻。 </p>
<br>

<hr>
<br>

<h1 id="论文报告的要求与技巧"><a href="#论文报告的要求与技巧" class="headerlink" title="论文报告的要求与技巧"></a>论文报告的要求与技巧</h1><p>报告一篇论文，我要求做到以下部分（依报告次序排列）： </p>
<ul>
<li><p>投影片第一页必须列出论文的题目、作者、论文出处与年份。 </p>
</li>
<li><p>以下每一页投影片只能讲一个观念，不可以在 一张投影片里讲两个观念。 </p>
</li>
<li><p>说明这篇论文所研究的问题的重点，以及这个问题可能和工业界的哪些应用相关。 </p>
</li>
<li><p>清楚交代这篇论文的主要假设，主要公式，与主要应用方式（以及应用上可能的解题流程）。 </p>
</li>
<li><p>说明这篇论文的范例（simulation examples and/or experiments），预测这个方法在不同场合时可能会有的准确度或好用的程度.</p>
</li>
<li><p>你个人的分析、评价与批评，包括：<font color="red">（6A）这篇论文最主要的创意是什么？（6B）这些创意在应用上有什么好处？（6C）这些创意和应用上的好处是在     哪些条件下才能成立？（6D）这篇论文最主要的缺点或局限是什么？（6E）这些缺点或局限在应用上有什么坏处？（6F）这些缺点和应用上的坏处是因为哪些因素而引入的？（6G）你建议学长学弟什么时候参考这篇论文的哪些部分（点子）？ </font></p>
<p>​     一般来讲，刚开始报告论文（硕一上学期）时只要做到能把前四项要素说清楚就好了，但是硕一结束后（暑假开始）必须要设法做到六项要素都能触及。硕二下学期开始的时候，必须要做到六项都能说清楚。 </p>
<p>​     注意：读论文和报告论文时，最重要的是它的创意和观念架构，而不是数学上恒等式推导过程的细节（顶多只要抓出关键的 equation 去弩懂以及说明清楚即可）。你报告观念与分析创意，别人容易听懂又觉得有趣；你讲恒等式，大家不耐烦又浪费时间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>研究生学习</category>
      </categories>
      <tags>
        <tag>论文积累与想法</tag>
      </tags>
  </entry>
  <entry>
    <title>减脂塑性规划</title>
    <url>/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-健身部位与动作"><a href="#一-健身部位与动作" class="headerlink" title="一.健身部位与动作"></a>一.健身部位与动作</h1><h2 id="1-胸部"><a href="#1-胸部" class="headerlink" title="1.胸部"></a>1.胸部</h2><ul>
<li><p><strong>俯卧撑</strong></p>
<blockquote>
<p>可以练到胸肌、肱三头肌，甚至可以练到我们的肩部，是一个非常经典的自重动作。</p>
</blockquote>
</li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/1.jpg" alt></p>
<ul>
<li><strong>平板杠铃卧推（宽握）：</strong></li>
</ul>
<blockquote>
<p>需要注意三点，一是卧推时杠铃需要自然推起（下放在胸部而顶点在肩关节上方），二是杠铃要尽量下放到贴近胸部的位置再推起，三是卧推时杠铃下放触及的应该是乳头附近的位置。 </p>
<p>很多新手卧推时，推起放下往往不是垂直的，下放往往放到肩部附近，这就是错误的推法，这样卧推是刺激不到胸肌的。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/2.jpg" alt></p>
<ul>
<li><strong>上斜板杠铃卧推（宽握</strong></li>
</ul>
<blockquote>
<p>其实就是将平板的角度向上倾斜45~60度<br>上斜板卧推需要注意的是，下放的位置不是乳头附近，而是下放到锁骨即可。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/3.jpg" alt></p>
<ul>
<li><strong>下斜板哑铃卧推（宽握）</strong></li>
</ul>
<blockquote>
<p>下斜卧推杠铃是下放到乳头往下3cm的位置，但是远没有到腹部。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/4.jpg" alt></p>
<ul>
<li><strong>窄握</strong></li>
</ul>
<blockquote>
<p>下面这是平板杠铃卧推（窄握）。窄握是提高卧推力量的很好的方法，和宽握相比，窄握中肱三头肌受力更大，卧推力量遇到瓶颈时，可以用窄握来突破。上斜和下斜的窄握就不贴了。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/5.jpg" alt></p>
<ul>
<li><strong>绳索飞鸟</strong></li>
</ul>
<blockquote>
<p>这应该是对胸肌中缝刺激最大的动作了。</p>
<p>这个动作需要注意的是，手要尽量打开，肘关节微曲，不要用腰背过分的借力。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/6.jpg" alt></p>
<ul>
<li><strong>哑铃飞鸟</strong></li>
</ul>
<blockquote>
<p>做哑铃飞鸟时你去想象你前面有个人，你要去「拥抱」他，就是用那种拥抱的感觉去练飞鸟就对了。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/7.jpg" alt></p>
<ul>
<li><strong>双臂杆屈伸</strong></li>
</ul>
<blockquote>
<p>这是在飞鸟和卧推之外的动作，根据身体倾向状况，刺激的肌肉部位也不同，身体越前倾，胸大肌的刺激越大，越直立，就越容易刺激肱三头肌。</p>
</blockquote>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/8.jpg" alt></p>
<hr>
<h2 id="2-腹部"><a href="#2-腹部" class="headerlink" title="2.腹部"></a>2.腹部</h2><ul>
<li><strong>上腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/9.jpg" alt></p>
<blockquote>
<p>注意不是做全程,而是双臂托着头向上抬起,感觉上面有个鱼饵要去吃的感觉.(60+)</p>
</blockquote>
<ul>
<li><strong>中腹肌、下腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/10.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/11.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/12.jpg" alt></p>
<blockquote>
<p>对于下腹肌有非常好的效果,坚持一段时间会出现V字型的线条</p>
<p>注意：腿部不要碰到地面。50+</p>
</blockquote>
<ul>
<li><strong>侧腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/13.jpg" alt></p>
<blockquote>
<p>注意点，全程上胸处于抬起状态，而不是躺下再起来，快速交替触碰.(100+)</p>
</blockquote>
<ul>
<li><strong>中腹肌</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/14.jpg" alt></p>
<blockquote>
<p>注意这个动作要水平的打开,而不是向下去打开,完全可以在地上做以臀部为支点.(60+)</p>
</blockquote>
<ul>
<li>中腹肌</li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/15.jpg" alt></p>
<blockquote>
<p>这个动作完全可以不负重,空手快速进行.(60+)</p>
</blockquote>
<hr>
<h2 id="3-腿"><a href="#3-腿" class="headerlink" title="3.腿"></a>3.腿</h2><ul>
<li><strong>颈后杠铃深蹲</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/16.gif" alt></p>
<blockquote>
<p>一个合格的负重深蹲动作，需要让你有顺畅的感觉，不别扭，可以自由发力的感觉，膝盖不要内扣，快起慢下，感受大腿燃烧的绷感.</p>
<p><strong>站距</strong>：稍微比肩膀宽一点，八字步站开，30度左右.</p>
<p><strong>膝盖的朝向和脚一样，朝外，无论多大重量，绝对不能内扣！！</strong></p>
</blockquote>
<ul>
<li><strong>箭步深蹲</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/17.gif" alt></p>
<blockquote>
<p>十分有效的动作，深蹲的一种，对塑造臀部也十分有帮助。</p>
<p>要领：膝盖要中立，不要出现单侧内扣.</p>
</blockquote>
<hr>
<h2 id="4-背"><a href="#4-背" class="headerlink" title="4.背"></a>4.背</h2><ul>
<li><strong>无敌黄金引体向上</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/18.jpg" alt></p>
<blockquote>
<p>主要可以锻炼到的肌群有：背阔肌，大圆肌，小园肌，肱二头肌。次要肌肉：三角肌后束，胸肌，腹肌，斜方肌等。</p>
</blockquote>
<ul>
<li><p><strong>高位下拉</strong> </p>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/19.jpg" alt></p>
</li>
</ul>
<blockquote>
<p> 需要注意：背要直，可以稍微向后仰一点，调整膝垫至合适位置。膝垫可以避免身体因为阻力而上升。吐气的同时将肩膀和上臂向后下方拉动，拉下把手直至碰到上胸。</p>
<p>提示：完全收紧时集中注意力收缩后背肌肉。动作中上躯应保持固定，只有手臂运动。前臂只需抓握杠杆，没有其他动作，不要用前臂拉动把手。</p>
<p>呼吸：用力下拉时呼气，还原时吸气</p>
</blockquote>
<ul>
<li><strong>宽度动作三直臂下拉</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/20.jpg" alt></p>
<blockquote>
<ol>
<li>正握握住宽把，掌心向下，双臂距离超过肩宽。后退60厘米左右。</li>
<li>上身向前，弯向前倾斜30度，双手在前方伸直,手肘略弯.。手臂无法完全伸直就继续后退，直到手臂完全伸直，弯腰，背阔肌绷紧，准备开始。</li>
<li>保持手臂伸直,收缩背阔肌下拉把手直至大腿,</li>
</ol>
</blockquote>
<ul>
<li><strong>哑铃划船</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/21.jpg" alt></p>
<blockquote>
<p>这个动作会让你的鼠蹊部（就是腹股沟，还是不懂就叫：腚沟子）处于一个容易受伤的状态.</p>
</blockquote>
<ul>
<li><strong>坐姿划船：</strong></li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/22.jpg" alt></p>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/23.gif" alt></p>
<blockquote>
<p>1 两腿踩住前方的踏板，<strong>微屈膝，腿不可伸直</strong>，两手紧握三角形（或其他形状的）手柄，双臂前伸，<strong>腰腹固定</strong>,挺胸抬头。</p>
<p>2.收缩背部肌肉，加紧肩胛骨，用这股力量，将手柄拉至腹部，尽可能地向后牵拉你的双肩和双肘，直到手柄接触到你的身体中部。可以保持顶峰收缩1-2秒，努力挤压你的肩胛骨，得到最大程度的刺激.</p>
<p>3.以背阔肌的力量控制还原，所谓的快拉慢回，控制速度，但是！不需要过慢。</p>
</blockquote>
<ul>
<li>硬拉</li>
</ul>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/24.gif" alt></p>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/25.jpg" alt></p>
<p><img src="//zybtree.github.io/2019/10/18/减脂塑性规划/26.jpg" alt></p>
<blockquote>
<p>这是一个垂直运动的轨迹，沉肩，核心收紧。发力的时候，感受力从地起，腘绳肌，大腿，臀部，下背，一气呵成，感受力从地起，屁股夹紧的感觉。</p>
<p>呼吸：硬拉在上了大重量以后（4-6RM甚至更重）用普通的呼吸方法是会出现危险的，为什么？</p>
<p>因为，在大重量的硬拉训练中，脊椎面临很大的压力，普通的呼吸造成的压力很难维持脊椎中立稳定，所以要憋气！就是所谓瓦式呼吸。先在动作进行前吸一口气，将气回压在下腹创造腹内压（往内挤压），努力紧绷你的腰椎周围肌群，想象别人要在你肚子上打一拳。直到完成一次动作后才进行吐气，动作全程是憋气的。再说一遍：准备动作深吸一口气，并且在发力的时候紧闭声门hold住这一口气。</p>
</blockquote>
]]></content>
      <categories>
        <category>减脂塑形</category>
      </categories>
      <tags>
        <tag>减脂塑形</tag>
      </tags>
  </entry>
  <entry>
    <title>东大一个月以来的反思</title>
    <url>/2019/10/04/%E4%B8%9C%E5%A4%A7%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BB%A5%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1 跑步已进入瓶颈期，6km以下已经不怎么出汗。改变有氧运动为跳绳后发现10mins就能汗如雨下，搭配着来很重要。其次，不能间断超过三天，否则要浪费一天时间去重新适应。现在又办理了健身卡，今天晚上也要制定减脂增肌的健身与饮食计划，一定要在元旦之前减到65kg以下。</p>
<hr>
<p>2 以后就算是和老师们聚餐也要控制酒精摄入。更要学会委婉的拒绝。</p>
<hr>
<p>3 事实证明自己之前的胡思乱想归根结底还是闲的，让自己有计划有节奏的忙碌起来。爱情这东西命里有时终须有，命里无时也莫强求，对现在的自己而言没有那么重要。</p>
<hr>
<p>4 至于以后到底读不读博，就业是否留在实验室得等到寒假之后再思考，这个学期主要是找到物理层安全的价值点与兴趣点所在，多读论文。</p>
<hr>
<p>5 不要过于自卑，自己也没有那么弱，运气只会对努力的，有准备的人奏效，它也是实力的一种，不然自己也不会在这进修了!</p>
<hr>
<p>6 体态和肤质只需坚持一个季度就能改变，并不难。细细想来和当初考研异曲同工，只要稳扎稳打一年就能改变所在平台，这是回报率很高的“交易”。等到11月发了奖学金可以试着买一套护肤的保养保养，毕竟自己的皮肤也需要保护，自己的形象也很重要。</p>
<hr>
<p>7 年少时觉得那些大道理似乎很空，所以忘得很快。现在读的书慢慢多了，经历的慢慢丰富了，身边却很少有人那么“苦口婆心”的教导自己，很感谢随机过程老师每节课这么督促我们，仔细琢磨后觉得既兴奋有懊悔，以后要把所以空闲时间都用在学习与思考上。</p>
<hr>
<p>8 老师们都说如果能把高考时的拼劲放到现在，没有什么是解决不了的。不过高三时的自己并没有那么拼命，也让自己刻意忘记了那时的日子。所以自己不妨试着再找回考研时候的拼劲，时刻思考，时刻背诵。我相信自己一定会有所成的。</p>
<hr>
<p>9 如切如磋，如琢如磨，战战兢兢，如履薄冰。希望不负“百载文枢江左，东南辈出英豪。”的期望!</p>
]]></content>
      <categories>
        <category>感悟与反思</category>
      </categories>
      <tags>
        <tag>感悟与反思</tag>
      </tags>
  </entry>
</search>
