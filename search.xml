<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git提速代理</title>
    <url>/2024/11/09/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>因为平时在Ubuntu虚拟机上使用Git clone的时候速度特别慢，使用干脆写个代理文件进行提速。</p>
</blockquote>
<h2 id="梯子准备"><a href="#梯子准备" class="headerlink" title="梯子准备"></a>梯子准备</h2><p>在主机上挂个梯子，然后查看IP地址与端口(确保能使用)。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">	options=400&lt;CHANNEL_IO&gt;</span><br><span class="line">	ether 38:f9:d3:8d:58:3e</span><br><span class="line">	inet6 fe80::1434:df1:87d5:7e09%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">	inet 192.168.1.4 netmask 0xffffff00 broadcast 192.168.1.255</span><br><span class="line">	nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br></pre></td></tr></table></figure></div>
<p><img src="/2024/11/09/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/1.png" style="zoom:50%;"></p>
<p>我的IP与端口:192.168.1.4:7890</p>
<h2 id="写代理文件"><a href="#写代理文件" class="headerlink" title="写代理文件"></a>写代理文件</h2><p>在Ubuntu上写代理文件，在与Desktop同一级的目录下新建.gitconfig文件并进行编辑。</p>
<p><img src="/2024/11/09/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/2.png" alt></p>
<p>这样就可以加速了。实践一下。</p>
<p><img src="/2024/11/09/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/3.png" alt></p>
<p>这个速度就爽多！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-为什么使用Makefile"><a href="#一-为什么使用Makefile" class="headerlink" title="一.为什么使用Makefile"></a>一.为什么使用Makefile</h1><p>假设有一个如图所示的C工程：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/1.png" alt></p>
<p>如果要编译出可执行程序project_demo，必须执行以下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤1：编译主程序模块</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;100个主程序模块的o文件&gt; -c &lt;100个主程序模块的c文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤2：编译功能模块a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块a的o文件&gt; &lt;1000个功能模块a的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs liba.a &lt;1000个功能模块a的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤3：编译功能模块b</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块b的o文件&gt; &lt;1000个功能模块b的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libb.a &lt;1000个功能模块b的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤4：生成可执行文件demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o demo &lt;100个主程序模块的o文件&gt; -L. -la -lb</span></span><br></pre></td></tr></table></figure></div>
<p><strong>这样就出现了两个问题：</strong></p>
<blockquote>
<ul>
<li>上述4个编译步骤中，几乎每个步骤都有亢长的文件名列表需要输入而且有些还是重复的，这种工作枯燥而又费时，且极易因人为疏忽而出现错误；</li>
<li>假设demo项目每次编译所需的时间都比较长，那么如果之就前已经成功编译过了demo项目，而此后当我们修改了某些源文件需要更新的demo文件时，理论上我们是不希望也不需要去重新编译整个项目的，我们只需要仅分析其中的依赖关系，仅执行需要重新编译链接的命令，以节省编译时间，但是对于依赖关系非常复杂的工程而言，分析源文件涉及到的依赖关系是个非常复杂且容易出错的过程。</li>
</ul>
</blockquote>
<p><strong>而make和Makefile的出现就是为了解决这两个问题的：</strong></p>
<blockquote>
<ul>
<li>makefile文件帮助我们<strong>记录了整个项目工程的所有需要编译的文件列表</strong>，这样我们在编译时仅需要输入简单的make命令就能编译出我们期望的结果。</li>
<li>makefile文件<strong>反映了整个项目中各个模块的依赖关系</strong>，这样我们改动了某些源文件后，仅需简单的输入make命令，<strong>make工具就会根据makefile文件里描述的依赖关系帮助我们分析哪些模块需要重新编译</strong>，并执行相应的操作。</li>
</ul>
</blockquote>
<p><strong>在linux/unix开发环境中，makefile文件则是描述了一个特定编译系统所需要的策略，而make工具则是通过解析makefile文件并执行相应的命令来帮助我们构建其编译系统。</strong></p>
<p>所以主要围绕着下面两个问题来学习Makefile和Make：</p>
<ol>
<li><font color="red">makefile如何记录整个项目工程的所有需要编译的文件列表及如何反映整个项目中各个模块的依赖关系?</font></li>
<li><font color="red">提供了makefile策略描述后，make工具又是是如何解析makefile文件来帮助我们构建其编译系统的？</font>

</li>
</ol>
<hr>
<h1 id="二-关于Makefile"><a href="#二-关于Makefile" class="headerlink" title="二.关于Makefile"></a>二.关于Makefile</h1><h2 id="1-Makefile简介"><a href="#1-Makefile简介" class="headerlink" title="1.Makefile简介"></a>1.Makefile简介</h2><p>makefile就是一个简单的文本文件，它基本上就是由一条条的<code>规则</code>构成。了解一下makefile里的最基本的语法单元，<strong>规则</strong>。</p>
<p>一条makefile的规则构成如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target:prerequisites</span></span><br><span class="line">&lt;tab&gt; command1</span><br><span class="line">&lt;tab&gt; command2</span><br><span class="line">.....</span><br><span class="line">&lt;tab&gt; commandN</span><br></pre></td></tr></table></figure></div>
<ul>
<li>target：<font color="red">规则的目标</font>，可以简单理解为<strong>这条规则存在的目的是什么</strong>。通常是<strong>程序中间或者最后需要生成的文件名</strong>，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。</li>
<li>prerequisites：<font color="red">规则的依赖列表</font>，可以简单的理解为<strong>要达到本条规则的目标所需要的先决条件是什么</strong>。可以是文件名，也可以是其他规则的目标；</li>
<li>command：<font color="red">规则的命令</font>，可以简单的理解为<strong>当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标</strong>。规则的命令其实就是shell命令。一条规则中可以有多行命令，<strong>特别注意：每行命令都必须以tab键开始！</strong></li>
</ul>
<p>实践一个简单的makefile例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的makefile文件</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span>  <span class="comment">#注意：每行命令都必须以tab键开始！</span></span><br></pre></td></tr></table></figure></div>
<p>这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(<strong>规则不可以没有目标但是可以没有依赖</strong>)，以及一条命令(其实规则也是可以不需要任何命令的)。</p>
<p>在终端执行Makefile文件：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p>
<h2 id="2-Make的工作原理"><a href="#2-Make的工作原理" class="headerlink" title="2.Make的工作原理"></a>2.Make的工作原理</h2><p>通过回答下面三个问题来解释make的工作原理：</p>
<blockquote>
<ol>
<li>make命令如何使用</li>
<li>make从哪读取Makefile</li>
<li>make如何解析执行Makefile文件的规则</li>
</ol>
</blockquote>
<p>make命令的基本使用范式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make [ -f makefile ] [ options ] ... [ targets ] ...</span><br></pre></td></tr></table></figure></div>
<p>使用make命令的最简单的方式主要有如下四种形式:</p>
<ol>
<li>简单粗暴，不带任何参数，直接执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile文件：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f &lt;makefile_name&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile目标：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定目录下执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -C &lt;subdir&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<p>在执行make的时候，我们可以带上<code>-f &lt;文件名&gt;</code>参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为<strong>GNUmakefile, makefile,和 Makefile</strong>的文件来作为其makefile文件。</p>
<p>在读取完makefile的内容后，make工具<strong>并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。</strong><font color="red">而这条作为突破口的规则的目标，称为<strong>终极目标</strong></font> 。我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。</p>
<p>一般情况下，make执行一条规则的具体过程是这样的：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/3.png" alt></p>
<p><strong>make解析makefile的流程如下：</strong></p>
<p>假设有makefile内容如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">终极目标：依赖A  依赖B 依赖C</span><br><span class="line">    终极目标命令</span><br><span class="line"></span><br><span class="line">依赖A：子依赖A1 子依赖A2 </span><br><span class="line">    依赖A命令</span><br><span class="line"></span><br><span class="line">依赖B：子依赖B1 子依赖B2 </span><br><span class="line">    依赖B命令</span><br><span class="line"></span><br><span class="line">依赖C：子依赖C1 子依赖C2 </span><br><span class="line">    依赖C命令</span><br></pre></td></tr></table></figure></div>
<p><strong>过程一，以终极目标为树根，解析出整颗依赖树：</strong></p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/4.png" alt></p>
<p><strong>过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则：</strong></p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/5.png" alt></p>
<hr>
<h1 id="三-Makefile基本概念实例"><a href="#三-Makefile基本概念实例" class="headerlink" title="三.Makefile基本概念实例"></a>三.Makefile基本概念实例</h1><p>通过构建一个简单的c语言项目工程(project_simple)来理解makefile的基本概念。</p>
<p>project_simple的整体目录结构：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/6.png" alt></p>
<h2 id="1-编写文件代码"><a href="#1-编写文件代码" class="headerlink" title="1.编写文件代码"></a>1.编写文件代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple.c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is simple project!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-Makefile文件编写"><a href="#2-Makefile文件编写" class="headerlink" title="2.Makefile文件编写"></a>2.Makefile文件编写</h2><p>最后就是要编写makefile了，一般在编写makefile之前都需要先分析清楚整个工程各个模块的依赖关系，及相应的生成命令。project_simple工程最终生产的是一个叫simple的可执行文件，而该可执行文件是使用gcc命令编译main.c和simple.c生成的。</p>
<p>因此整个工程的关系依赖图，如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/7.png" alt></p>
<p>因此Makefile这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">simple: main.c simple.c</span></span><br><span class="line">    gcc -o simple main.c simple.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-运行验证Makefile"><a href="#3-运行验证Makefile" class="headerlink" title="3.运行验证Makefile"></a>3.运行验证Makefile</h2><h3 id="能否编译出可执行的simple"><a href="#能否编译出可执行的simple" class="headerlink" title="能否编译出可执行的simple"></a>能否编译出可执行的simple</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">pwd</span>        <span class="comment">#查看当前路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译前当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make       <span class="comment">#编译simple项目</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译结果</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./simple   <span class="comment">#执行simple可执行文件</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/8.png" alt></p>
<h3 id="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"><a href="#已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作" class="headerlink" title="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"></a>已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt <span class="comment">#查看当前项目中各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make   <span class="comment">#再次执行编译，查看是否会执行编译命令</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/9.png" alt></p>
<h3 id="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"><a href="#已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件" class="headerlink" title="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"></a>已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#对比当前项目各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch main.c <span class="comment">#将main.c文件的时间戳修改至最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看main.c的时间戳是否最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make         <span class="comment">#执行编译命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看simple的时间戳是否被更新至最新</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/10.png" alt></p>
<hr>
<h1 id="四-Makefile语法"><a href="#四-Makefile语法" class="headerlink" title="四.Makefile语法"></a>四.Makefile语法</h1><p>完整的makefile所包含的语法模块：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/11.png" alt></p>
<h2 id="1-通过complicated项目来进行学习Makefile语法"><a href="#1-通过complicated项目来进行学习Makefile语法" class="headerlink" title="1.通过complicated项目来进行学习Makefile语法"></a>1.通过complicated项目来进行学习Makefile语法</h2><p>构建一个名为project_complicated的项目工程，目录结构如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/12.png" alt></p>
<p>编写源代码文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, HELLO_STRING);</span><br><span class="line">    complicated();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_STRING <span class="meta-string">&quot;Hello !&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_NAME <span class="meta-string">&quot;complicated&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a %s porject!\n&quot;</span>, PROJECT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>项目依赖关系：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/13.png" alt></p>
<p>对比simple项目，发现complicated项目貌似只是多了一个头文件，但是依赖关系图却多了一层.o文件。</p>
<blockquote>
<p>在用gcc 编译出可执行文件的过程中是包含两个阶段的：编译阶段和链接阶段。</p>
</blockquote>
<p>上述的依赖关系图更加准确的反映出了整个项目的构建过程，这样据此写出来的makefile才能更加灵活及更具可扩展性，<strong>精确的分析清楚项目的依赖关系，是编写一个好的makefile的关键。</strong></p>
<p>编写Makefile文件:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<p>验证过程及结果如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/14.png" alt></p>
<h2 id="2-使用注解提高可维护性"><a href="#2-使用注解提高可维护性" class="headerlink" title="2.使用注解提高可维护性"></a>2.使用注解提高可维护性</h2><ul>
<li>makefile中<code>#</code>字符后的内容被作为是注释内容（和shell脚本一样）处理。</li>
<li>注释行的结尾如果存在反斜线<code>\</code>，那么下一行也被作为注释行。</li>
<li>当在makefile中如果需要使用字符<code>#</code>时，可以使用反斜线加<code>#</code>（<code>\#</code>）来实现，其表示将<code>#</code>作为一字符而不是注释的开始标志。</li>
</ul>
<p>写一个例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个演示注释语法的makefile</span></span><br><span class="line"><span class="section">all: test #关于依赖的注释</span></span><br><span class="line"><span class="comment">#    echo &quot;Makefile for comment 1&quot;   这里是注释，不是命令</span></span><br><span class="line">    echo <span class="string">&quot;Makefile for comment 2&quot;</span> </span><br><span class="line"><span class="comment"># 这是一个关于test规则的 \</span></span><br><span class="line">  多行注释</span><br><span class="line"><span class="section">test:</span></span><br><span class="line"><span class="comment"># 没有反斜线\, #被当作注释的开始</span></span><br><span class="line">    echo this is a <span class="comment"># test rule1 </span></span><br><span class="line"><span class="comment"># 加上反斜线\, #被当作普通字符</span></span><br><span class="line">    echo this is a \<span class="comment"># test rule2 </span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/15.png" alt></p>
<blockquote>
<p>可以看出make在执行时一般情况下对于makefile中以<code>#</code>开始到行尾的内容都是直接忽略不做任何处理的。</p>
</blockquote>
<p>complicated项目Makefile:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.1</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。</p>
<p>变量定义的基本格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">变量名 赋值符 变量值</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ul>
<li>变量名指的就是该变量的名字，是不包括<code>:</code>、<code>#</code>、<code>=</code>、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但<strong>定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义</strong>，并且这样命名的变量对于一些shell来说不能作为环境变量使用。<strong>变量名是大小写敏感的。</strong>变量<code>foo</code>、<code>Foo</code>和<code>FOO</code>指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。</li>
<li>变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。</li>
<li>赋值符，有<code>=</code> 、 <code>:=</code> 、 <code>?=</code>和 <code>+=</code>四种格式，其中<code>=</code> 和 <code>:=</code> 为基本定义类型， <code>?=</code>和 <code>+=</code>为基于<code>=</code>的扩展定义类型</li>
</ul>
</blockquote>
<p>一个在makefile中定义变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br></pre></td></tr></table></figure></div>
<h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>当我们定义了一个变量之后，我们就可以在makfile中的<strong>目标</strong>、<strong>依赖</strong>、<strong>命令</strong>中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量<strong>被展开的过程</strong> )，替换掉变量的名字。</p>
<p>变量的引用有以下几种方式：</p>
<blockquote>
<ol>
<li><code>$&#123;变量名&#125;</code></li>
<li><code>$（变量名）</code></li>
<li><code>$单字符变量名</code> ，变量名仅包含一个字符，如<code>$@</code> 、<code>$^</code>等</li>
</ol>
</blockquote>
<p>一个在makefile中引用变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program : <span class="variable">$(objects)</span>          <span class="comment">#在依赖中引用变量</span></span><br><span class="line">    gcc -o program $&#123;objects&#125; <span class="comment">#在命令中引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h           <span class="comment">#在目标中引用变量</span></span><br></pre></td></tr></table></figure></div>
<h3 id="变量的分类与赋值"><a href="#变量的分类与赋值" class="headerlink" title="变量的分类与赋值"></a>变量的分类与赋值</h3><p>根据变量定义时所使用的<strong>赋值操作符的不同</strong>，可以将变量分成两种类型(或者说是两种风格)：</p>
<p><code>递归展开式变量</code>和<code>直接展开式变量</code>；</p>
<blockquote>
<p>使用赋值操作符<code>=</code> 、 <code>+=</code> 和 <code>?=</code>定义的变量都是<strong>递归展开式变量</strong>，使用赋值操作符 <code>:=</code>定义的变量为<strong>直接展开式变量</strong> 。</p>
<p>两种变量类型的的最根本区别在于：<strong>变量值的求值时机</strong>，递归式变量的求值时机在于<strong>变量被引用时</strong>，直接展开式的求值时机在于<strong>变量被定义时</strong>。</p>
</blockquote>
<p>编写Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">foo1 = <span class="variable">$(bar)</span>   <span class="comment">#递归展开式变量</span></span><br><span class="line">foo2 := <span class="variable">$(bar)</span>  <span class="comment">#直接展开式变量</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;foo1 is <span class="variable">$(foo1)</span>, foo2 is <span class="variable">$(foo2)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>然后，使用 <code>$ make -f variabletype.mk</code> 执行variabletype.mk，演示及结果如下：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/16.png" alt></p>
<p>由于变量<code>foo1</code>的变量值是在执行<code>echo</code>命令时才求的值，所以<code>foo1</code>的值被递归的展开为<code>Huh?</code>； 而变量<code>foo2</code>的变量值在定义时就被求值了，此时由于变量<code>bar</code>的值为空，因此<code>foo2</code>的值也为空。</p>
<blockquote>
<p><strong>注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败</strong></p>
</blockquote>
<p><code>+=</code> 和 <code>?=</code>是基于<code>=</code>扩展而来的两种变量赋值操作符；</p>
<p><code>+=</code> 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar = foo1   </span><br><span class="line">bar += foo2  <span class="comment">#追加赋值，bar的值将为 foo1 foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure></div>
<p><code>?=</code>称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar1 = foo1</span><br><span class="line">bar1 ?= foo2  <span class="comment"># bar1 的值还是foo1</span></span><br><span class="line">bar2 ?= foo2  <span class="comment"># bar2 的值为foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:  </span></span><br><span class="line">    echo <span class="string">&quot;bar1 is <span class="variable">$(bar1)</span>, bar2 is <span class="variable">$(bar2)</span>&quot;</span> </span><br></pre></td></tr></table></figure></div>
<h3 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h3><p>在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。</p>
<ul>
<li>自动化变量</li>
</ul>
<p>所谓自动化变量，<strong>就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量</strong>，一般情况下常用的有以下几个自动化变量：</p>
<blockquote>
<p><code>$@</code> — 代表规则中的目标文件名</p>
<p><code>$&lt;</code> — 代表规则的第一个依赖的文件名</p>
<p><code>$^</code> — 代表规则中所有依赖文件的列表，文件名用空格分割</p>
</blockquote>
<p>Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: first second third</span></span><br><span class="line">    echo <span class="string">&quot;\$<span class="variable">$@</span> = <span class="variable">$@</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$^</span> = <span class="variable">$^</span>&quot;</span></span><br><span class="line"></span><br><span class="line">first second third:</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ol>
<li><script type="math/tex; mode=display">`字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给`echo`命令执行，需要使用`$</script></li>
<li><code>$@</code>在bash shell中也有特殊用途，因此如果希望<code>echo</code>命令在bash中正常输出<code>$@</code>， 需要加上<code>\</code>字符</li>
<li>该makefile的最后一行<code>first second third:</code> 看起来有点奇怪，这是一条<strong>没有依赖和命令的多目标规则</strong>，读者可自行将它删除看有什么效果，并思考原因。</li>
</ol>
</blockquote>
<p>运行结果:</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/17.png" alt></p>
<p>删除<code>first second third</code>后的运行结果:</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/18.png" alt></p>
<h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul>
<li>变量的分类与赋值</li>
</ul>
<p>对于一个c已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为<code>$(VAR:A=B)</code>或者<code>$&#123;VAR:A=B&#125;</code>，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := a.c b.c c.c d.d</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;objects = <span class="variable">$(objects)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/19.png" alt></p>
<p>使用变量改进complicated项目的makefile(v1.2)：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.2</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="多目标规则与多规则目标"><a href="#多目标规则与多规则目标" class="headerlink" title="多目标规则与多规则目标"></a>多目标规则与多规则目标</h3><h4 id="多目标规则"><a href="#多目标规则" class="headerlink" title="多目标规则"></a>多目标规则</h4><p>多目标规则，可以简单的理解为是一种将多条具有</p>
<ul>
<li><strong>相同依赖</strong></li>
<li><strong>相同生成命令</strong></li>
</ul>
<p>的规则，合并成一条规则的语法，其基本格式为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets...: prerequisites...</span></span><br><span class="line">    commands</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>假设有以下Makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target1: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target2: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>利用多目标规则，可以将makefile改写成 makefile 文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用多目标规则合并 target1 和target2的规则</span></span><br><span class="line">target1 target2: dep</span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果:</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/20.png" alt></p>
<p>可以观察到，虽然多目标规则中要求命令必须相同，但是配合上自动化变量的使用，就是可以针对不同的目标有不同的执行结果。</p>
<h4 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h4><p>Makefile中，一个目标可以同时出现在多条规则中。</p>
<blockquote>
<p>这种情况下，此目标文件的所有依赖文件将会被合并成此目标一个依赖文件列表，其中任何一个依赖文件比目标更新（比较目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目标。</p>
<p>对于一个多规则的目标，<strong>重建此目标的命令只能出现在一个规则中</strong>（可以是多条命令）。</p>
<p>如果多个规则同时给出重建此目标的命令，make将使用最后一个规则的命令，同时提示错误信息。</p>
</blockquote>
<h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>仔细观察complicated项目中的两条子规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<p>首先<strong>它们的命令是一样的</strong>，其次它们目标依赖关系有点相似(目标都是以.o结尾的文件，依赖都是以.c结尾的文件)。<font color="red">对于这种长得很像的规则，makefile提供了一种称为<strong>静态模式规则</strong>的规则来帮助我们简化规则的编写。</font></p>
<p>静态模式规则：</p>
<blockquote>
<p>可以理解为一种特殊的多目标规则，它仅要求多条规则具有相同的命令，而依赖可以不完全一样。</p>
</blockquote>
<p>静态模式规则，其基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...</span><br><span class="line">    COMMANDS</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>其大致意思就是，用<code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>描述的模式，从<code>TARGETS ...</code>取值来形成一条条规则，所有规则的命令都用<code>COMMANDS</code>。</p>
<p><code>TARGETS ...</code>代表具有相同模式的规则的目标列表，在我们的项目中就是main.o和complicated.o，我们可以直接引用我们先前定义的objects变量。</p>
<p><code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>部分定义了，如何为目标列表中的目标，生成依赖；<code>TARGET-PATTERN</code>称为目标模式，<code>PREREQ-PATTERNS</code>称为依赖模式；目标模式和依赖模式中，一般需要包含模式字符<code>%</code>。</p>
<p>目标模式的作用就是从目标列表中的目标匹配过滤出需要的值，目标模式中的字符<code>%</code>表示在匹配过滤的过程中不做过滤的部分，目标模式中的其他字符表示要与目标列表中的目标精确匹配，例如，目标模式<code>%.o</code>， 表示从目标列表的目标中匹配所有以<code>.o</code>结尾的目标，然后过滤掉匹配目标的<code>.o</code>部分， 因此目标<code>main.o</code>经过目标模式<code>%.o</code>匹配过滤后，得到的输出就是<code>main</code>。</p>
<p>依赖模式的作用就是表示要如何生成依赖文件。具体的生成过程，就是使用目标模式过滤出来的值，替换依赖模式字符<code>%</code>所表示的位置。因此，如果依赖模式为<code>%.c</code>， 则使用上述例子过滤出来的<code>main</code>来替换字符<code>%</code>， 最终得到依赖文件<code>main.c</code></p>
<p>因此，可以用静态模式规则来简化我们的complicated项目：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态模式规则简化complicated makefile</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>complicated项目编译完成后，会有可执行文件及中间目标文件，有时出于某些需求，需要将编译生成的文件都删除，让整个项目回到最初的状态。修改后的Makefile如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">executbale := complicated</span><br><span class="line">sources := main.c complicated.c</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(object)</span>:%.o:%.c</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p> 运行结果:</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/21.png" alt></p>
<p>上述的clean规则，貌似能正常工作，但其实是存在bug的，当目录下刚好存在一个叫做clean的文件时，事情就没那么顺利了：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/22.png" alt></p>
<blockquote>
<p>出现以上问题的原因是，当编译目录下存在clean文件时，由于clean规则没有依赖，所以clean文件的时间戳永远显得都是最新的，故其命令也无法被执行，这时我们就得请伪目标出手帮助了。</p>
</blockquote>
<p>当我们将一个目标定义成伪目标时，意味着它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。</p>
<p>定义一个伪目标的基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: &lt;伪目标&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>因此我们以定义complicated项目的clean目标，为伪目标，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p>这样目标<code>clean</code>就是一个伪目标，无论当前目录下是否存在<code>clean</code>这个文件。我们输入<code>make clean</code>之后。<code>rm</code>命令都会被执行。</p>
<p>运行结果：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/23.png" alt></p>
<h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><h3 id="命令的回显"><a href="#命令的回显" class="headerlink" title="命令的回显"></a>命令的回显</h3><p>通常，make在执行命令行之前会把要执行的命令行进行输出，如以下makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>在执行make时，其输出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">  echo &quot;Hello world!&quot;</span><br><span class="line">  Hello world!</span><br></pre></td></tr></table></figure></div>
<p><strong>关闭命令回显有以下几种方式：</strong></p>
<ol>
<li>每个需要关闭回显的命令行前加上”@”字符，上述例子关闭回显：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>执行make时带上参数<code>-s</code>或<code>--slient</code>禁止所有执行命令的显示</li>
<li>在Makefile中使用没有依赖的特殊目标<code>.SILENT</code>也可以禁止所有命令的回显</li>
</ol>
<h3 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>在Makefile中<strong>书写在同一行中的多个命令属于一个完整的shell命令行</strong>，<strong>书写在独立行的一条命令是一个独立的shell命令行</strong>。所以需要注意：在一个规则的命令中，命令行<code>cd</code>改变目录不会对其后的命令的执行产生影响。就是说其后的命令执行的工作目录不会是之前使用<code>cd</code>进入的那个目录。如果要实现这个目的<strong>，</strong>就不能把<code>cd</code>和其后的命令放在两行来书写。而应该把这两条命令写在一行上，用分号分隔。这样它们才是一个完整的shell命令行。</p>
<p>对比以下例子两个规则的输出，编写makefile 文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target1:</span></span><br><span class="line">    @echo <span class="string">&quot;target1&quot;</span></span><br><span class="line">    @cd ~</span><br><span class="line">    @pwd</span><br><span class="line"></span><br><span class="line"><span class="section">target2:</span></span><br><span class="line">    @echo <span class="string">&quot;target2&quot;</span></span><br><span class="line">    @cd ~; pwd</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/24.png" alt></p>
<h3 id="命令执行的错误处理"><a href="#命令执行的错误处理" class="headerlink" title="命令执行的错误处理"></a>命令执行的错误处理</h3><p>通常情况下，规则中的每一条命令在运行结束后，make都会检测命令执行的返回状态，如果返回成功，就执行下一条命令；命令出错（返回状态非0），make就会放弃对当前规则的执行，或者终止对当前makefile的解析执行。</p>
<p>在一些情况下，规则中的一个命令的执行失败并不代表规则执行的错误。为了忽略一些无关紧要的命令执行失败的情况，我们可以在命令之前加一个减号<code>-</code>，来告诉make忽略此命令的执行失败检查。</p>
<p>在更加深入的认识了makefile的规则后，我们complicated项目的makefile(v1.3)就可以这样写了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.3</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<h2 id="5-内嵌函数"><a href="#5-内嵌函数" class="headerlink" title="5.内嵌函数"></a>5.内嵌函数</h2><p>make的内嵌函数为我们提供了处理文件名、变量、文本和命令的方法。使我们的Makefile更为灵活和健壮。我们可以在需要的地方调用函数来处理指定的文本（参数），函数在调用它的地方被替换为它的处理结果。函数调用（引用）的展开和变量引用的展开方式类似：</p>
<p>函数调用方式1:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(FUNCTION ARGUMENTS)</span></span><br></pre></td></tr></table></figure></div>
<p>函数调用方式2：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;FUNCTION ARGUMENTS&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="内嵌函数的分类"><a href="#内嵌函数的分类" class="headerlink" title="内嵌函数的分类"></a>内嵌函数的分类</h3><p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/25.png" alt></p>
<p><strong>使用wildcard函数改进complicated项目makefile:</strong></p>
<p>wildcard函数，其使用范式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>函数名称：wildcard</p>
<p>函数功能：列出当前目录下所有符合模式“PATTERN”格式的文件名。</p>
<p>返回值：空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</p>
<p>函数说明：“PATTERN”使用shell可识别的通配符，包括<code>?</code>（单字符）、<code>*</code>（多字符）等。</p>
</blockquote>
<p>示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure></div>
<p>返回值为当前目录下所有.c源文件列表。</p>
<p>我们可以引进wildcard函数，改进complicated项目的makefile，使其能够自动扫描当前目录下的源文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.4</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 引进wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sourcecs := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> </span><br></pre></td></tr></table></figure></div>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/26.png" alt></p>
<h2 id="6-自动生成依赖关系"><a href="#6-自动生成依赖关系" class="headerlink" title="6.自动生成依赖关系"></a>6.自动生成依赖关系</h2><p>complicated项目的makefile已经完成的比较完善了，但还存在一个问题，当更新头文件complicated.h的内容后，执行make时，项目并不会重新编译。</p>
<p>出现以上问题的根本原因是，我们的makefile还没能精确的反映整个项目工程的依赖关系！很明显，项目的依赖关系应该加入对于头文件的依赖，即如下图：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/27.png" alt></p>
<p>根据上述依赖关系，我们可以在makefile加上如下规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(objects)</span>: complicated.h</span><br></pre></td></tr></table></figure></div>
<p>上述新增规则，是一条多目标规则，它与之前的静态模式规则，又组成了多规则目标，可自行思考其工作原理。</p>
<p>上述规则加入虽然能解决我们的问题，但是对于大型复杂的项目，这种需要我们逐个去分析头文件被依赖的关系，几乎是不可能的。所以我们需要工具来帮我们做这个事。下面我们来介绍如何实现自动生成依赖关系。</p>
<p>gcc提供了这样的功能，帮助我们分析一个文件对其他文件的依赖关系列表。在执行gcc时带上<code>-MM</code>选项时，gcc工具就会列出指定文件对其他文件的依赖关系列表。直接来看例子：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/28.png" alt></p>
<p>接下来要考虑的问题就是如何将gcc的输出导入到makefile中了。</p>
<p>makefile支持使用<code>sinclude</code>关键字将指定文件导入到当前的makefile当中，它的作用与C语言的<code>#include</code>预处理命令是一样的。使用方式<code>sinclude &lt;other_makefiles&gt;</code>。</p>
<p>因此，可以将gcc对于源文件的依赖关系分析输出到某个文件(可以称为依赖描述文件，一般命名为与源文件同名但以.d结尾的文件)当中，然后再将依赖描述文件导入到makefile中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖描述文件列表</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br></pre></td></tr></table></figure></div>
<p>当使用<code>sinclude</code>关键字向当前makefile导入文件时，如果所导入的文件不存在，make会试图去执行可以生产导入文件的规则去生产被导入的文件，然后再执行导入。</p>
<p>因此可以使用静态模式规则，让make在执行时，去调用gcc生成依赖关系文件，可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    gcc -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>因此，complicated项目的最终makefile可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.5</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"><span class="comment"># 6. 加入自动规则依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sources := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动规则依赖</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="/2024/11/09/Makefile%E5%AD%A6%E4%B9%A0/29.png" alt></p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty线程模型</title>
    <url>/2024/11/10/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Netty 的线程模型是基于 Reactor 模型改进而来的，因此需要先熟悉 Reactor 模型，帮助对于 Netty 线程模型的理解。</p>
</blockquote>
<h1 id="一-Reactor-模型"><a href="#一-Reactor-模型" class="headerlink" title="一. Reactor 模型"></a><strong>一. Reactor 模型</strong></h1><h2 id="1-为什么需要-Reactor-模型"><a href="#1-为什么需要-Reactor-模型" class="headerlink" title="1.为什么需要 Reactor 模型"></a><strong>1.为什么需要 Reactor 模型</strong></h2><p> 传统阻塞 IO 模型具有设计上的不足之处：</p>
<ul>
<li>每个连接都需要独立线程处理，当并发数大时，创建线程数多，占用资源</li>
<li>采用阻塞IO模型，连接建立后，若当前线程没有数据可读，线程会阻塞在读操作上，造成资源浪费</li>
</ul>
<p>针对传统阻塞IO模型的两个问题，可以采用如下的方案：</p>
<ul>
<li>基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理</li>
<li>基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理</li>
</ul>
<h2 id="2-什么是-Reactor-模型"><a href="#2-什么是-Reactor-模型" class="headerlink" title="2.什么是 Reactor 模型"></a><strong>2.什么是 Reactor 模型</strong></h2><p>The reactor design_pattern is an event_handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p>
<p>Reactor 设计模型是一种事件处理模式，用于处理通过一个或多个输入同时传递给服务处理程序的服务请求。然后，服务处理程序对传入的请求进行多路分解，并将它们同步分派给关联的请求处理程序。Reactor 模式也被称作 Dispatcher 模式。它的核心是 <strong>多路复用器</strong> ，多路复用器收到事件后会进行分发，这点是网络服务器高并发的关键。Reacotr 模型主要分为三个角色：</p>
<ol>
<li><strong>Reactor</strong> ：把 IO 事件分配给对应的 handler 处理</li>
<li><strong>Acceptor</strong> ：处理客户端连接事件</li>
<li><strong>Handler</strong> ：处理非阻塞的任务</li>
</ol>
<p>通过这三个角色的配合，实现了高并发的操作。而Reactor 模型分为三种：</p>
<ol>
<li><strong>单 Reactor 单线程</strong></li>
<li><strong>单 Reactor 多线程</strong></li>
<li><strong>多 Reactor 多线程</strong></li>
</ol>
<p>这三种模型按顺序来看理解起来复杂度不断提升，也会更接近 Netty 的线程模型，下面来分别看看这三种模型。</p>
<h3 id="1-单-Reactor-单线程"><a href="#1-单-Reactor-单线程" class="headerlink" title="(1). 单 Reactor 单线程"></a><strong>(1). 单 Reactor 单线程</strong></h3><p>这个最好理解，只有 <strong>一个线程</strong> ，只是会把 <strong>建立连接</strong> 和 <strong>处理请求</strong> 这两种任务分发给不同的类去处理，如下图所示：</p>
<center class="half"> 
    <img src="/2024/11/10/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.PNG" width="70%">
    <div>图1:单Reactor单线程</div>
</center>

<p>整个流程简单来讲就是：</p>
<ol>
<li>Reactor 通过 Selector 监听事件</li>
<li>收到事件使用 dispatch 对事件进行分发<ul>
<li>如果是连接事件就由 Acceptor 进行处理，处理完成会创建一个 Handler 对后续业务进行处理。</li>
<li>后面的数据请求都会由 Handler 进行处理</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>模型简单，不会有多线程的那些问题</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>性能问题：单线程无法发挥多核 CPU 的性能</li>
<li>可靠性问题：处理业务时往往容易出问题，当 Handler 出问题了，由于只有一个线程，整个节点也挂了</li>
</ul>
<h3 id="2-单-Reactor-多线程"><a href="#2-单-Reactor-多线程" class="headerlink" title="(2). 单 Reactor 多线程"></a>(2). 单 Reactor 多线程</h3><p>这个线程模型针对前面的问题作出了一定的优化，多出了处理业务的线程池，如下图所示：</p>
<center class="half"> 
    <img src="/2024/11/10/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/2.PNG" width="90%">
    <div>图2:单Reactor多线程</div>
</center>

<p>前面的流程与单 Reactor 单线程是一致的，到 Handler 这一步就不一样了：</p>
<ul>
<li>这个模型 <strong>Handler 只负责读取数据和发送数据部分，业务处理交给了 Worker 线程</strong>，而 Worker 线程是由 Worker 线程池统一管理的。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可以充分利用多核 CPU 的处理能力</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多线程资源共享和访问处理会比较复杂，在主线程处理所有的连接、监听和响应也会出现性能瓶颈</li>
</ul>
<h3 id="3-主从-Reactor-多线程"><a href="#3-主从-Reactor-多线程" class="headerlink" title="(3). 主从 Reactor 多线程"></a>(3). 主从 Reactor 多线程</h3><p>主从 Reactor 多线程模型又在前面的模型基础上做了进一步优化， <strong>增加了子 Reactor</strong> ，如下图所示：</p>
<center class="half"> 
    <img src="/2024/11/10/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/3.png" width="80%">
    <div>图3:多Reactor多线程</div>
</center>

<p><strong>整个流程大概可以分为以下几步</strong>：</p>
<ul>
<li>主线程的 <code>MainReactor</code> 负责监听连接请求，收到连接请求会由 <code>Acceptor</code> 进行处理，成功建立连接之后 <code>MainReactor</code> 会把连接分派给 <code>SubReactor</code> ，由 <code>SubReactor</code> 监听和处理数据请求；</li>
<li><code>SubReactor</code> 监听到数据请求，会派发给 Handler 处理，Handler 只会处理读取数据和发送数据部分，中间业务处理部分也是放在线程池中完成。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><code>MainReactor</code> 与 <code>SubReactor</code> 职责分明，一个处理连接事件，一个处理数据请求；</li>
<li><code>MainReactor</code> 与 <code>SubReactor</code> 交互逻辑比较简单，<code>MainReactor</code> 单向地将建立好的连接传递出去；</li>
<li>多 Reactor 设计能在高并发场景拥有更好的性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>编程复杂度较高</li>
</ul>
<p>主从 Reactor 多线程模式是业界非常成熟的服务器程序设计模式，在很多中间件中都使用到了这种模式，像 Nginx、Memcached、Netty 等。这种模式也被称为 1 + M + N 模式，分别代指相对少的连接线程（不一定为 1 ），多个 I/O 线程和多个业务处理线程。</p>
<h1 id="二-Netty-线程模型"><a href="#二-Netty-线程模型" class="headerlink" title="二. Netty 线程模型"></a>二. Netty 线程模型</h1><p>Netty 线程模型是基于主从 Reactor 多线程模型优化而来的，整体架构如下图所示：</p>
<center class="half"> 
    <img src="/2024/11/10/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/4.png" width="100%">
    <div>图4:Netty线程</div>
</center>

<p>Netty 的线程模型主要分为两部分，分别是 <code>BossGroup</code> 和 <code>WorkerGroup</code>，它们都分别管理一个或多个 <code>NioEventLoop</code>。每个 <code>NioEventLoop</code> 对应着一个线程，一个 <code>Selector</code>，一个 <code>Executor</code> 和一个 <code>TaskQueue</code>。<code>NioEventLoop</code> 可以理解成一个事件循环：</p>
<ul>
<li>当程序启动后每个 <code>NioEventLoop</code> 都会通过 <code>Executor</code> 启动一个线程，开始执行事件循环。</li>
<li>在循环中 <code>Selector</code> 会通过 select 方法阻塞并监听就绪事件，当有事件到来时通过 <code>processSeelectedKeys</code> 方法处理 Selector 事件。</li>
<li>之后再通过 <code>runAllTasks</code> 方法处理其他的任务。</li>
</ul>
<p>与前面介绍的 主从 Reactor 多线程模型类似：</p>
<ul>
<li><code>BossGoup</code> 负责连接事件，当建立连接之后会生成一个 <code>NioSocketChannel</code> 并注册到 <code>WorkGroup</code> 其中一个 <code>NioEventLoop</code> 的 Selector 上。</li>
<li><code>WokerGroup</code> 中的 <code>NioEventLoop</code> 负责处理数据请求，当请求到来时会调用 <code>processSelectedKeys</code> 方法，其中的业务处理会依次经过 Pipeline 中的多个 Handler。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb学习</title>
    <url>/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<p>在终端输入以下命令安装 GDB：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gdb</span></span><br></pre></td></tr></table></figure></div>
<h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2+3+...+%d= %d\n&quot;</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc bugging.c -o bugging -g -m64</span></span><br></pre></td></tr></table></figure></div>
<p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p>
<p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libc6-dev-i386</span></span><br></pre></td></tr></table></figure></div>
<p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb bugging</span></span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) run</span></span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) quit</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/1.png" style="zoom:50%;"></p>
<h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p>
<blockquote>
<p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p>
</blockquote>
<p>部分 gdb 常用命令一览表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">简写形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">l</td>
<td style="text-align:center">查看源码</td>
</tr>
<tr>
<td style="text-align:center">backtrace</td>
<td style="text-align:center">bt,where</td>
<td style="text-align:center">打印函数栈信息</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">n</td>
<td style="text-align:center">执行下一行</td>
</tr>
<tr>
<td style="text-align:center">step</td>
<td style="text-align:center">s</td>
<td style="text-align:center">一次执行一行，遇到函数会进入</td>
</tr>
<tr>
<td style="text-align:center">finish</td>
<td style="text-align:center"></td>
<td style="text-align:center">运行到函数结束</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">c</td>
<td style="text-align:center">继续运行</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">b</td>
<td style="text-align:center">设置断点</td>
</tr>
<tr>
<td style="text-align:center">info breakpoints</td>
<td style="text-align:center"></td>
<td style="text-align:center">显示断点信息</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">d</td>
<td style="text-align:center">删除断点</td>
</tr>
<tr>
<td style="text-align:center">print</td>
<td style="text-align:center">p</td>
<td style="text-align:center">打印表达式的值</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">r</td>
<td style="text-align:center">启动程序</td>
</tr>
<tr>
<td style="text-align:center">until</td>
<td style="text-align:center">u</td>
<td style="text-align:center">执行到指定行</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">i</td>
<td style="text-align:center">显示信息</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">h</td>
<td style="text-align:center">帮助信息</td>
</tr>
</tbody>
</table>
</div>
<p>查询用法：</p>
<blockquote>
<p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p>
</blockquote>
<p>执行 Shell 命令：</p>
<blockquote>
<p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb)!shell 命令</span></span><br></pre></td></tr></table></figure></div>
<p>例如查看当前目录的文件：</p>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p>
</blockquote>
<h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p>
<ul>
<li>list 行号，显示某一行附近的代码：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/3.png" style="zoom:50%;"></p>
<ul>
<li>list 函数名，显示某个函数附近的代码：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/4.png" style="zoom:50%;"></p>
<ul>
<li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li>
</ul>
<h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p>
<ul>
<li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/5.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 行号，适用于有多个源文件的情况。</li>
</ul>
<ul>
<li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/6.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 函数名，适用于有多个源文件的情况。</li>
</ul>
<h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/7.png" style="zoom:50%;"></p>
<p>其中每一项的信息：</p>
<blockquote>
<ul>
<li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li>
<li>Type 列代表断点类型，一般为 breakpoint</li>
<li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li>
<li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li>
<li>Address 列代表该断点处虚拟内存的地址</li>
<li>What 列代表该断点在源文件中的信息</li>
</ul>
</blockquote>
<h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p>
<ul>
<li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/8.png" style="zoom:50%;"></p>
<ul>
<li>delete，不带任何参数，默认删除所有断点：</li>
</ul>
<h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p>
<blockquote>
<p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p>
<p><em>enable</em> 命令用于启用断点。</p>
</blockquote>
<ul>
<li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/9.png" style="zoom:50%;"></p>
<ul>
<li><p>disable，不带任何参数，默认关闭所有断点。</p>
</li>
<li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p>
</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/10.png" style="zoom:50%;"></p>
<ul>
<li>enable，不带任何参数，默认启用所有断点。</li>
</ul>
<p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p>
<h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p>
<ul>
<li>enable once Num，断点 hit 一次之后关闭该断点</li>
<li>enable delete Num，断点 hit 一次之后删除该断点</li>
</ul>
<p><img src="/2024/11/09/gdb%E5%AD%A6%E4%B9%A0/11.png" style="zoom:50%;"></p>
<p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p>
<h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol>
<li><strong>打印变量</strong></li>
</ol>
<p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p>
<blockquote>
<ul>
<li><p><code>info locals</code></p>
<p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p>
</li>
<li><p><code>print 变量或表达式</code></p>
<p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p>
<p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>启动程序</strong></li>
</ol>
<p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p>
<blockquote>
<ul>
<li><p><code>run</code></p>
<p>不带任何参数，启动待调试程序，不传递参数。</p>
</li>
<li><p><code>run 参数</code></p>
<p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>单步命令</strong></li>
</ol>
<p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p>
<blockquote>
<ul>
<li><p><code>next</code></p>
<blockquote>
<p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p>
<p>next N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>step</code></p>
<blockquote>
<p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p>
<p>step N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>finish</code></p>
<p>执行程序到当前函数结束</p>
</li>
<li><p><code>continue</code></p>
<p>执行程序到下个断点</p>
</li>
<li><p><code>until</code></p>
<p>until N，执行程序到源代码的某一行</p>
</li>
</ul>
</blockquote>
<h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p>
<blockquote>
<ul>
<li><code>list</code></li>
<li><code>info breakpoints</code></li>
<li><code>break</code></li>
<li><code>delete</code></li>
<li><code>disable</code> 和 <code>enable</code></li>
<li><code>enable once</code> 和 <code>enable delete</code></li>
<li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li>
<li><code>info locals</code> 和 <code>print</code></li>
</ul>
</blockquote>
<p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
</search>
