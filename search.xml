<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APUE基础介绍</title>
    <url>/2020/11/11/APUE%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
  </entry>
  <entry>
    <title>Git提速代理</title>
    <url>/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>因为平时在Ubuntu虚拟机上使用Git clone的时候速度特别慢，使用干脆写个代理文件进行提速。</p>
</blockquote>
<h2 id="梯子准备"><a href="#梯子准备" class="headerlink" title="梯子准备"></a>梯子准备</h2><p>在主机上挂个梯子，然后查看IP地址与端口(确保能使用)。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">	options=400&lt;CHANNEL_IO&gt;</span><br><span class="line">	ether 38:f9:d3:8d:58:3e</span><br><span class="line">	inet6 fe80::1434:df1:87d5:7e09%en0 prefixlen 64 secured scopeid 0x6</span><br><span class="line">	inet 192.168.1.4 netmask 0xffffff00 broadcast 192.168.1.255</span><br><span class="line">	nd6 options=201&lt;PERFORMNUD,DAD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/1.png" style="zoom:50%;"></p>
<p>我的IP与端口:192.168.1.4:7890</p>
<h2 id="写代理文件"><a href="#写代理文件" class="headerlink" title="写代理文件"></a>写代理文件</h2><p>在Ubuntu上写代理文件，在与Desktop同一级的目录下新建.gitconfig文件并进行编辑。</p>
<p><img src="/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/2.png" alt></p>
<p>这样就可以加速了。实践一下。</p>
<p><img src="/2020/03/11/Git%E6%8F%90%E9%80%9F%E4%BB%A3%E7%90%86/3.png" alt></p>
<p>这个速度就爽多！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下C链接Mysql</title>
    <url>/2020/03/02/Linux%E4%B8%8BC%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-安装数据库"><a href="#1-安装数据库" class="headerlink" title="1.安装数据库"></a>1.安装数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqld-dev</span><br></pre></td></tr></table></figure></div>
<h2 id="2-查看安装包"><a href="#2-查看安装包" class="headerlink" title="2.查看安装包"></a>2.查看安装包</h2><p>2.查看本地有没有安装mysql的开发包。命令是  ‘mysql_config —cflags —libs’如果有安装就会有一串编译选项和连接库。如果没有就自行安装 mysql-devel-<strong>*</strong>的rpm包后面是版本号。mysql开发包提供了基本操作接口。安装后头文件在/usr/include/mysql 而动态库在 /usr/lib/mysql 上。</p>
<p><img src="/2020/03/02/Linux%E4%B8%8BC%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/1.png" alt></p>
<h2 id="3-编写C程序链接数据库"><a href="#3-编写C程序链接数据库" class="headerlink" title="3.编写C程序链接数据库"></a>3.编写C程序链接数据库</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MYSQL *conn;</span><br><span class="line">    MYSQL_RES *res;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">char</span> *server = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> *user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> *password = <span class="string">&quot;ZYB110929&quot;</span>; <span class="comment">/* 此处改成你的密码 */</span></span><br><span class="line">   <span class="keyword">char</span> *database = <span class="string">&quot;mysql&quot;</span>;</span><br><span class="line"></span><br><span class="line">    conn = mysql_init(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Connect to database */</span></span><br><span class="line">   <span class="keyword">if</span> (!mysql_real_connect(conn, server,</span><br><span class="line">          user, password, database, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* send SQL query */</span></span><br><span class="line">   <span class="keyword">if</span> (mysql_query(conn, <span class="string">&quot;show tables&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, mysql_error(conn));</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    res = mysql_use_result(conn);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* output table name */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;MySQL Tables in mysql database:\n&quot;</span>);</span><br><span class="line">   <span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, row[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* close connection */</span></span><br><span class="line">    mysql_free_result(res);</span><br><span class="line">    mysql_close(conn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test $(mysql_config --cflags) $(mysql_config --libs)</span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/02/Linux%E4%B8%8BC%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/2.png" alt></p>
<p>实践成功。</p>
<p>​            </p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile学习</title>
    <url>/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-为什么使用Makefile"><a href="#一-为什么使用Makefile" class="headerlink" title="一.为什么使用Makefile"></a>一.为什么使用Makefile</h1><p>假设有一个如图所示的C工程：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/1.png" alt></p>
<p>如果要编译出可执行程序project_demo，必须执行以下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 步骤1：编译主程序模块</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;100个主程序模块的o文件&gt; -c &lt;100个主程序模块的c文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤2：编译功能模块a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块a的o文件&gt; &lt;1000个功能模块a的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs liba.a &lt;1000个功能模块a的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤3：编译功能模块b</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o &lt;1000个功能模块b的o文件&gt; &lt;1000个功能模块b的c文件&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ar rcs libb.a &lt;1000个功能模块b的o文件&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 步骤4：生成可执行文件demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -o demo &lt;100个主程序模块的o文件&gt; -L. -la -lb</span></span><br></pre></td></tr></table></figure></div>
<p><strong>这样就出现了两个问题：</strong></p>
<blockquote>
<ul>
<li>上述4个编译步骤中，几乎每个步骤都有亢长的文件名列表需要输入而且有些还是重复的，这种工作枯燥而又费时，且极易因人为疏忽而出现错误；</li>
<li>假设demo项目每次编译所需的时间都比较长，那么如果之就前已经成功编译过了demo项目，而此后当我们修改了某些源文件需要更新的demo文件时，理论上我们是不希望也不需要去重新编译整个项目的，我们只需要仅分析其中的依赖关系，仅执行需要重新编译链接的命令，以节省编译时间，但是对于依赖关系非常复杂的工程而言，分析源文件涉及到的依赖关系是个非常复杂且容易出错的过程。</li>
</ul>
</blockquote>
<p><strong>而make和Makefile的出现就是为了解决这两个问题的：</strong></p>
<blockquote>
<ul>
<li>makefile文件帮助我们<strong>记录了整个项目工程的所有需要编译的文件列表</strong>，这样我们在编译时仅需要输入简单的make命令就能编译出我们期望的结果。</li>
<li>makefile文件<strong>反映了整个项目中各个模块的依赖关系</strong>，这样我们改动了某些源文件后，仅需简单的输入make命令，<strong>make工具就会根据makefile文件里描述的依赖关系帮助我们分析哪些模块需要重新编译</strong>，并执行相应的操作。</li>
</ul>
</blockquote>
<p><strong>在linux/unix开发环境中，makefile文件则是描述了一个特定编译系统所需要的策略，而make工具则是通过解析makefile文件并执行相应的命令来帮助我们构建其编译系统。</strong></p>
<p>所以主要围绕着下面两个问题来学习Makefile和Make：</p>
<ol>
<li><font color="red">makefile如何记录整个项目工程的所有需要编译的文件列表及如何反映整个项目中各个模块的依赖关系?</font></li>
<li><font color="red">提供了makefile策略描述后，make工具又是是如何解析makefile文件来帮助我们构建其编译系统的？</font>

</li>
</ol>
<hr>
<h1 id="二-关于Makefile"><a href="#二-关于Makefile" class="headerlink" title="二.关于Makefile"></a>二.关于Makefile</h1><h2 id="1-Makefile简介"><a href="#1-Makefile简介" class="headerlink" title="1.Makefile简介"></a>1.Makefile简介</h2><p>makefile就是一个简单的文本文件，它基本上就是由一条条的<code>规则</code>构成。了解一下makefile里的最基本的语法单元，<strong>规则</strong>。</p>
<p>一条makefile的规则构成如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target:prerequisites</span></span><br><span class="line">&lt;tab&gt; command1</span><br><span class="line">&lt;tab&gt; command2</span><br><span class="line">.....</span><br><span class="line">&lt;tab&gt; commandN</span><br></pre></td></tr></table></figure></div>
<ul>
<li>target：<font color="red">规则的目标</font>，可以简单理解为<strong>这条规则存在的目的是什么</strong>。通常是<strong>程序中间或者最后需要生成的文件名</strong>，也可以不对应具体的文件，而仅仅就是个概念上的规则目标。</li>
<li>prerequisites：<font color="red">规则的依赖列表</font>，可以简单的理解为<strong>要达到本条规则的目标所需要的先决条件是什么</strong>。可以是文件名，也可以是其他规则的目标；</li>
<li>command：<font color="red">规则的命令</font>，可以简单的理解为<strong>当目标所需要的先决条件的满足了之后，需要执行什么动作来达成规则的目标</strong>。规则的命令其实就是shell命令。一条规则中可以有多行命令，<strong>特别注意：每行命令都必须以tab键开始！</strong></li>
</ul>
<p>实践一个简单的makefile例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的makefile文件</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span>  <span class="comment">#注意：每行命令都必须以tab键开始！</span></span><br></pre></td></tr></table></figure></div>
<p>这个简单的makefile文件，只有一条规则，规则的目标是all，没有任何依赖(<strong>规则不可以没有目标但是可以没有依赖</strong>)，以及一条命令(其实规则也是可以不需要任何命令的)。</p>
<p>在终端执行Makefile文件：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p>
<h2 id="2-Make的工作原理"><a href="#2-Make的工作原理" class="headerlink" title="2.Make的工作原理"></a>2.Make的工作原理</h2><p>通过回答下面三个问题来解释make的工作原理：</p>
<blockquote>
<ol>
<li>make命令如何使用</li>
<li>make从哪读取Makefile</li>
<li>make如何解析执行Makefile文件的规则</li>
</ol>
</blockquote>
<p>make命令的基本使用范式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">make [ -f makefile ] [ options ] ... [ targets ] ...</span><br></pre></td></tr></table></figure></div>
<p>使用make命令的最简单的方式主要有如下四种形式:</p>
<ol>
<li>简单粗暴，不带任何参数，直接执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile文件：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f &lt;makefile_name&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定makefile目标：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>指定目录下执行make：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">make -C &lt;subdir&gt; &lt;target&gt;</span><br></pre></td></tr></table></figure></div>
<p>在执行make的时候，我们可以带上<code>-f &lt;文件名&gt;</code>参数，来指定make命令从哪里读取makefile文件；而如果我们不显式指定，则make就会在当前目录下依次查找名字为<strong>GNUmakefile, makefile,和 Makefile</strong>的文件来作为其makefile文件。</p>
<p>在读取完makefile的内容后，make工具<strong>并不是逐条去执行makefile里的规则，而是以某条规则为突破口，多米诺骨牌效应式的去执行makefile里的规则。</strong><font color="red">而这条作为突破口的规则的目标，称为<strong>终极目标</strong></font> 。我们可以在执行make时以参数的形式指定终极目标，从而执行作为突破口的规则，如果我们不显式指定终极目标，make一般情况下将选择makefile的第一条规则的目标作为终极目标。</p>
<p>一般情况下，make执行一条规则的具体过程是这样的：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/3.png" alt></p>
<p><strong>make解析makefile的流程如下：</strong></p>
<p>假设有makefile内容如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">终极目标：依赖A  依赖B 依赖C</span><br><span class="line">    终极目标命令</span><br><span class="line"></span><br><span class="line">依赖A：子依赖A1 子依赖A2 </span><br><span class="line">    依赖A命令</span><br><span class="line"></span><br><span class="line">依赖B：子依赖B1 子依赖B2 </span><br><span class="line">    依赖B命令</span><br><span class="line"></span><br><span class="line">依赖C：子依赖C1 子依赖C2 </span><br><span class="line">    依赖C命令</span><br></pre></td></tr></table></figure></div>
<p><strong>过程一，以终极目标为树根，解析出整颗依赖树：</strong></p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/4.png" alt></p>
<p><strong>过程二，对整颗依赖树以从底到上，从左到右的顺序，解析执行每一条规则：</strong></p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/5.png" alt></p>
<hr>
<h1 id="三-Makefile基本概念实例"><a href="#三-Makefile基本概念实例" class="headerlink" title="三.Makefile基本概念实例"></a>三.Makefile基本概念实例</h1><p>通过构建一个简单的c语言项目工程(project_simple)来理解makefile的基本概念。</p>
<p>project_simple的整体目录结构：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/6.png" alt></p>
<h2 id="1-编写文件代码"><a href="#1-编写文件代码" class="headerlink" title="1.编写文件代码"></a>1.编写文件代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c文件</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple.c文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is simple project!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-Makefile文件编写"><a href="#2-Makefile文件编写" class="headerlink" title="2.Makefile文件编写"></a>2.Makefile文件编写</h2><p>最后就是要编写makefile了，一般在编写makefile之前都需要先分析清楚整个工程各个模块的依赖关系，及相应的生成命令。project_simple工程最终生产的是一个叫simple的可执行文件，而该可执行文件是使用gcc命令编译main.c和simple.c生成的。</p>
<p>因此整个工程的关系依赖图，如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/7.png" alt></p>
<p>因此Makefile这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">simple: main.c simple.c</span></span><br><span class="line">    gcc -o simple main.c simple.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-运行验证Makefile"><a href="#3-运行验证Makefile" class="headerlink" title="3.运行验证Makefile"></a>3.运行验证Makefile</h2><h3 id="能否编译出可执行的simple"><a href="#能否编译出可执行的simple" class="headerlink" title="能否编译出可执行的simple"></a>能否编译出可执行的simple</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">pwd</span>        <span class="comment">#查看当前路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译前当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make       <span class="comment">#编译simple项目</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ls         <span class="comment">#查看编译结果</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./simple   <span class="comment">#执行simple可执行文件</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/8.png" alt></p>
<h3 id="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"><a href="#已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作" class="headerlink" title="已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作"></a>已经编译出simple后，不改变任何源文件再次执行编译，是否不再执行任何操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt <span class="comment">#查看当前项目中各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make   <span class="comment">#再次执行编译，查看是否会执行编译命令</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/9.png" alt></p>
<h3 id="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"><a href="#已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件" class="headerlink" title="已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件"></a>已经编译出simple后，修改任一源文件是否能再次生成新的simple可执行文件</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#对比当前项目各文件时间戳</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch main.c <span class="comment">#将main.c文件的时间戳修改至最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看main.c的时间戳是否最新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make         <span class="comment">#执行编译命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lt       <span class="comment">#查看simple的时间戳是否被更新至最新</span></span></span><br></pre></td></tr></table></figure></div>
<p>过程及结果如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/10.png" alt></p>
<hr>
<h1 id="四-Makefile语法"><a href="#四-Makefile语法" class="headerlink" title="四.Makefile语法"></a>四.Makefile语法</h1><p>完整的makefile所包含的语法模块：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/11.png" alt></p>
<h2 id="1-通过complicated项目来进行学习Makefile语法"><a href="#1-通过complicated项目来进行学习Makefile语法" class="headerlink" title="1.通过complicated项目来进行学习Makefile语法"></a>1.通过complicated项目来进行学习Makefile语法</h2><p>构建一个名为project_complicated的项目工程，目录结构如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/12.png" alt></p>
<p>编写源代码文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, HELLO_STRING);</span><br><span class="line">    complicated();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLICATED_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_STRING <span class="meta-string">&quot;Hello !&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_NAME <span class="meta-string">&quot;complicated&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//complicated.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;complicated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complicated</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a %s porject!\n&quot;</span>, PROJECT_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>项目依赖关系：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/13.png" alt></p>
<p>对比simple项目，发现complicated项目貌似只是多了一个头文件，但是依赖关系图却多了一层.o文件。</p>
<blockquote>
<p>在用gcc 编译出可执行文件的过程中是包含两个阶段的：编译阶段和链接阶段。</p>
</blockquote>
<p>上述的依赖关系图更加准确的反映出了整个项目的构建过程，这样据此写出来的makefile才能更加灵活及更具可扩展性，<strong>精确的分析清楚项目的依赖关系，是编写一个好的makefile的关键。</strong></p>
<p>编写Makefile文件:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<p>验证过程及结果如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/14.png" alt></p>
<h2 id="2-使用注解提高可维护性"><a href="#2-使用注解提高可维护性" class="headerlink" title="2.使用注解提高可维护性"></a>2.使用注解提高可维护性</h2><ul>
<li>makefile中<code>#</code>字符后的内容被作为是注释内容（和shell脚本一样）处理。</li>
<li>注释行的结尾如果存在反斜线<code>\</code>，那么下一行也被作为注释行。</li>
<li>当在makefile中如果需要使用字符<code>#</code>时，可以使用反斜线加<code>#</code>（<code>\#</code>）来实现，其表示将<code>#</code>作为一字符而不是注释的开始标志。</li>
</ul>
<p>写一个例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个演示注释语法的makefile</span></span><br><span class="line"><span class="section">all: test #关于依赖的注释</span></span><br><span class="line"><span class="comment">#    echo &quot;Makefile for comment 1&quot;   这里是注释，不是命令</span></span><br><span class="line">    echo <span class="string">&quot;Makefile for comment 2&quot;</span> </span><br><span class="line"><span class="comment"># 这是一个关于test规则的 \</span></span><br><span class="line">  多行注释</span><br><span class="line"><span class="section">test:</span></span><br><span class="line"><span class="comment"># 没有反斜线\, #被当作注释的开始</span></span><br><span class="line">    echo this is a <span class="comment"># test rule1 </span></span><br><span class="line"><span class="comment"># 加上反斜线\, #被当作普通字符</span></span><br><span class="line">    echo this is a \<span class="comment"># test rule2 </span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/15.png" alt></p>
<blockquote>
<p>可以看出make在执行时一般情况下对于makefile中以<code>#</code>开始到行尾的内容都是直接忽略不做任何处理的。</p>
</blockquote>
<p>complicated项目Makefile:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.1</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="section">complicated: main.o complicated.o</span></span><br><span class="line">    gcc -o complicated main.o complicated.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -o main.o -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    gcc -o complicated.o -c complicated.c</span><br></pre></td></tr></table></figure></div>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>makefile中的变量，与C语言中的宏类似，它为一个文本字符串（变量的值，其类型只能是字符串类型）提供了一个名字(变量名)。</p>
<p>变量定义的基本格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">变量名 赋值符 变量值</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ul>
<li>变量名指的就是该变量的名字，是不包括<code>:</code>、<code>#</code>、<code>=</code>、前置空白和尾空白的任何字符串。需要注意的是，尽管在GNU make中没有对变量的命名有其它的限制，但<strong>定义一个包含除字母、数字和下划线以外的变量的做法也是不可取的，因为除字母、数字和下划线以外的其它字符可能会在以后的make版本中被赋予特殊含义</strong>，并且这样命名的变量对于一些shell来说不能作为环境变量使用。<strong>变量名是大小写敏感的。</strong>变量<code>foo</code>、<code>Foo</code>和<code>FOO</code>指的是三个不同的变量。Makefile传统做法是变量名是全采用大写的方式。推荐的做法是在对于内部定义定义的一般变量（例如：目标文件列表objects）使用小写方式，而对于一些参数列表（例如：编译选项CFLAGS）采用大写方式。</li>
<li>变量值，指的是变量所代表的内容，可以是一个文件名列表、编译选项列表、程序运行的选项参数列表、搜索源文件的目录列表、编译输出的目录列表和所有我们能够想到的事物。变量的值，其本质就是一个字符串。</li>
<li>赋值符，有<code>=</code> 、 <code>:=</code> 、 <code>?=</code>和 <code>+=</code>四种格式，其中<code>=</code> 和 <code>:=</code> 为基本定义类型， <code>?=</code>和 <code>+=</code>为基于<code>=</code>的扩展定义类型</li>
</ul>
</blockquote>
<p>一个在makefile中定义变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br></pre></td></tr></table></figure></div>
<h3 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h3><p>当我们定义了一个变量之后，我们就可以在makfile中的<strong>目标</strong>、<strong>依赖</strong>、<strong>命令</strong>中引用我们的变量；而所谓的变量引用，就是在引用变量名的地方，用变量所代表的内容，执行一个严格的文本替换过程(该过程也称为变量<strong>被展开的过程</strong> )，替换掉变量的名字。</p>
<p>变量的引用有以下几种方式：</p>
<blockquote>
<ol>
<li><code>$&#123;变量名&#125;</code></li>
<li><code>$（变量名）</code></li>
<li><code>$单字符变量名</code> ，变量名仅包含一个字符，如<code>$@</code> 、<code>$^</code>等</li>
</ol>
</blockquote>
<p>一个在makefile中引用变量的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">objects = program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program : <span class="variable">$(objects)</span>          <span class="comment">#在依赖中引用变量</span></span><br><span class="line">    gcc -o program $&#123;objects&#125; <span class="comment">#在命令中引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h           <span class="comment">#在目标中引用变量</span></span><br></pre></td></tr></table></figure></div>
<h3 id="变量的分类与赋值"><a href="#变量的分类与赋值" class="headerlink" title="变量的分类与赋值"></a>变量的分类与赋值</h3><p>根据变量定义时所使用的<strong>赋值操作符的不同</strong>，可以将变量分成两种类型(或者说是两种风格)：</p>
<p><code>递归展开式变量</code>和<code>直接展开式变量</code>；</p>
<blockquote>
<p>使用赋值操作符<code>=</code> 、 <code>+=</code> 和 <code>?=</code>定义的变量都是<strong>递归展开式变量</strong>，使用赋值操作符 <code>:=</code>定义的变量为<strong>直接展开式变量</strong> 。</p>
<p>两种变量类型的的最根本区别在于：<strong>变量值的求值时机</strong>，递归式变量的求值时机在于<strong>变量被引用时</strong>，直接展开式的求值时机在于<strong>变量被定义时</strong>。</p>
</blockquote>
<p>编写Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">foo1 = <span class="variable">$(bar)</span>   <span class="comment">#递归展开式变量</span></span><br><span class="line">foo2 := <span class="variable">$(bar)</span>  <span class="comment">#直接展开式变量</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;foo1 is <span class="variable">$(foo1)</span>, foo2 is <span class="variable">$(foo2)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>然后，使用 <code>$ make -f variabletype.mk</code> 执行variabletype.mk，演示及结果如下：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/16.png" alt></p>
<p>由于变量<code>foo1</code>的变量值是在执行<code>echo</code>命令时才求的值，所以<code>foo1</code>的值被递归的展开为<code>Huh?</code>； 而变量<code>foo2</code>的变量值在定义时就被求值了，此时由于变量<code>bar</code>的值为空，因此<code>foo2</code>的值也为空。</p>
<blockquote>
<p><strong>注意：使用递归展开式的变量定义，可能会由于出现变量的递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败</strong></p>
</blockquote>
<p><code>+=</code> 和 <code>?=</code>是基于<code>=</code>扩展而来的两种变量赋值操作符；</p>
<p><code>+=</code> 称为追加赋值操作符，它实现对于一个已经存在定义的变量进行追加赋值，如下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar = foo1   </span><br><span class="line">bar += foo2  <span class="comment">#追加赋值，bar的值将为 foo1 foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure></div>
<p><code>?=</code>称为条件赋值的赋值操作符，被称为条件赋值为：只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。看一下例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">bar1 = foo1</span><br><span class="line">bar1 ?= foo2  <span class="comment"># bar1 的值还是foo1</span></span><br><span class="line">bar2 ?= foo2  <span class="comment"># bar2 的值为foo2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:  </span></span><br><span class="line">    echo <span class="string">&quot;bar1 is <span class="variable">$(bar1)</span>, bar2 is <span class="variable">$(bar2)</span>&quot;</span> </span><br></pre></td></tr></table></figure></div>
<h3 id="特殊的变量"><a href="#特殊的变量" class="headerlink" title="特殊的变量"></a>特殊的变量</h3><p>在makefile 中用户除了可以自定义变量外，还可以使用make工具为我们提供的一些特殊的变量及用法。</p>
<ul>
<li>自动化变量</li>
</ul>
<p>所谓自动化变量，<strong>就是在每条规则中，make自动为我们提供的用于指定规则各个组成部分的变量</strong>，一般情况下常用的有以下几个自动化变量：</p>
<blockquote>
<p><code>$@</code> — 代表规则中的目标文件名</p>
<p><code>$&lt;</code> — 代表规则的第一个依赖的文件名</p>
<p><code>$^</code> — 代表规则中所有依赖文件的列表，文件名用空格分割</p>
</blockquote>
<p>Makefile实例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: first second third</span></span><br><span class="line">    echo <span class="string">&quot;\$<span class="variable">$@</span> = <span class="variable">$@</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line">    echo <span class="string">&quot;$<span class="variable">$^</span> = <span class="variable">$^</span>&quot;</span></span><br><span class="line"></span><br><span class="line">first second third:</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ol>
<li><script type="math/tex; mode=display">`字符在makefile中有特殊用途，因此如果要取消其特殊用途当成一个普通字符传递给`echo`命令执行，需要使用`$</script></li>
<li><code>$@</code>在bash shell中也有特殊用途，因此如果希望<code>echo</code>命令在bash中正常输出<code>$@</code>， 需要加上<code>\</code>字符</li>
<li>该makefile的最后一行<code>first second third:</code> 看起来有点奇怪，这是一条<strong>没有依赖和命令的多目标规则</strong>，读者可自行将它删除看有什么效果，并思考原因。</li>
</ol>
</blockquote>
<p>运行结果:</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/17.png" alt></p>
<p>删除<code>first second third</code>后的运行结果:</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/18.png" alt></p>
<h3 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h3><ul>
<li>变量的分类与赋值</li>
</ul>
<p>对于一个c已经定义的变量，可以使用“替换引用”将其值使用指定的字符（字符串）进行替换。格式为<code>$(VAR:A=B)</code>或者<code>$&#123;VAR:A=B&#125;</code>，意思是，将变量“VAR”所表示的值中所有字符串“A”结尾的字符替换为“B”的字。“结尾”的含义是空格之前（变量值的多个字以空格分开）。而对于变量其它部分的“A”字符不进行替换。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">sources := a.c b.c c.c d.d</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;objects = <span class="variable">$(objects)</span>&quot;</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/19.png" alt></p>
<p>使用变量改进complicated项目的makefile(v1.2)：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.2</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="多目标规则与多规则目标"><a href="#多目标规则与多规则目标" class="headerlink" title="多目标规则与多规则目标"></a>多目标规则与多规则目标</h3><h4 id="多目标规则"><a href="#多目标规则" class="headerlink" title="多目标规则"></a>多目标规则</h4><p>多目标规则，可以简单的理解为是一种将多条具有</p>
<ul>
<li><strong>相同依赖</strong></li>
<li><strong>相同生成命令</strong></li>
</ul>
<p>的规则，合并成一条规则的语法，其基本格式为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets...: prerequisites...</span></span><br><span class="line">    commands</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>假设有以下Makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target1: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">target2: dep</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>利用多目标规则，可以将makefile改写成 makefile 文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: target1 target2</span></span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用多目标规则合并 target1 和target2的规则</span></span><br><span class="line">target1 target2: dep</span><br><span class="line">    echo <span class="string">&quot;This is a rule for <span class="variable">$@</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">dep:</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果:</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/20.png" alt></p>
<p>可以观察到，虽然多目标规则中要求命令必须相同，但是配合上自动化变量的使用，就是可以针对不同的目标有不同的执行结果。</p>
<h4 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h4><p>Makefile中，一个目标可以同时出现在多条规则中。</p>
<blockquote>
<p>这种情况下，此目标文件的所有依赖文件将会被合并成此目标一个依赖文件列表，其中任何一个依赖文件比目标更新（比较目标文件和依赖文件的时间戳）时，make将会执行特定的命令来重建这个目标。</p>
<p>对于一个多规则的目标，<strong>重建此目标的命令只能出现在一个规则中</strong>（可以是多条命令）。</p>
<p>如果多个规则同时给出重建此目标的命令，make将使用最后一个规则的命令，同时提示错误信息。</p>
</blockquote>
<h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><p>仔细观察complicated项目中的两条子规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 子规则1, main.o的生成规则</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则2，complicated.o的生成规则</span></span><br><span class="line"><span class="section">complicated.o: complicated.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<p>首先<strong>它们的命令是一样的</strong>，其次它们目标依赖关系有点相似(目标都是以.o结尾的文件，依赖都是以.c结尾的文件)。<font color="red">对于这种长得很像的规则，makefile提供了一种称为<strong>静态模式规则</strong>的规则来帮助我们简化规则的编写。</font></p>
<p>静态模式规则：</p>
<blockquote>
<p>可以理解为一种特殊的多目标规则，它仅要求多条规则具有相同的命令，而依赖可以不完全一样。</p>
</blockquote>
<p>静态模式规则，其基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGETS ...: TARGET-PATTERN: PREREQ-PATTERNS ...</span><br><span class="line">    COMMANDS</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div>
<p>其大致意思就是，用<code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>描述的模式，从<code>TARGETS ...</code>取值来形成一条条规则，所有规则的命令都用<code>COMMANDS</code>。</p>
<p><code>TARGETS ...</code>代表具有相同模式的规则的目标列表，在我们的项目中就是main.o和complicated.o，我们可以直接引用我们先前定义的objects变量。</p>
<p><code>TARGET-PATTERN: PREREQ-PATTERNS ...</code>部分定义了，如何为目标列表中的目标，生成依赖；<code>TARGET-PATTERN</code>称为目标模式，<code>PREREQ-PATTERNS</code>称为依赖模式；目标模式和依赖模式中，一般需要包含模式字符<code>%</code>。</p>
<p>目标模式的作用就是从目标列表中的目标匹配过滤出需要的值，目标模式中的字符<code>%</code>表示在匹配过滤的过程中不做过滤的部分，目标模式中的其他字符表示要与目标列表中的目标精确匹配，例如，目标模式<code>%.o</code>， 表示从目标列表的目标中匹配所有以<code>.o</code>结尾的目标，然后过滤掉匹配目标的<code>.o</code>部分， 因此目标<code>main.o</code>经过目标模式<code>%.o</code>匹配过滤后，得到的输出就是<code>main</code>。</p>
<p>依赖模式的作用就是表示要如何生成依赖文件。具体的生成过程，就是使用目标模式过滤出来的值，替换依赖模式字符<code>%</code>所表示的位置。因此，如果依赖模式为<code>%.c</code>， 则使用上述例子过滤出来的<code>main</code>来替换字符<code>%</code>， 最终得到依赖文件<code>main.c</code></p>
<p>因此，可以用静态模式规则来简化我们的complicated项目：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态模式规则简化complicated makefile</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>complicated项目编译完成后，会有可执行文件及中间目标文件，有时出于某些需求，需要将编译生成的文件都删除，让整个项目回到最初的状态。修改后的Makefile如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">executbale := complicated</span><br><span class="line">sources := main.c complicated.c</span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(object)</span>:%.o:%.c</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p> 运行结果:</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/21.png" alt></p>
<p>上述的clean规则，貌似能正常工作，但其实是存在bug的，当目录下刚好存在一个叫做clean的文件时，事情就没那么顺利了：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/22.png" alt></p>
<blockquote>
<p>出现以上问题的原因是，当编译目录下存在clean文件时，由于clean规则没有依赖，所以clean文件的时间戳永远显得都是最新的，故其命令也无法被执行，这时我们就得请伪目标出手帮助了。</p>
</blockquote>
<p>当我们将一个目标定义成伪目标时，意味着它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。</p>
<p>定义一个伪目标的基本语法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: &lt;伪目标&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>因此我们以定义complicated项目的clean目标，为伪目标，如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># complicated项目添加clean 规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf complicated complicated.o main.o</span><br></pre></td></tr></table></figure></div>
<p>这样目标<code>clean</code>就是一个伪目标，无论当前目录下是否存在<code>clean</code>这个文件。我们输入<code>make clean</code>之后。<code>rm</code>命令都会被执行。</p>
<p>运行结果：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/23.png" alt></p>
<h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4. 命令"></a>4. 命令</h2><h3 id="命令的回显"><a href="#命令的回显" class="headerlink" title="命令的回显"></a>命令的回显</h3><p>通常，make在执行命令行之前会把要执行的命令行进行输出，如以下makefile：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div>
<p>在执行make时，其输出：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">  echo &quot;Hello world!&quot;</span><br><span class="line">  Hello world!</span><br></pre></td></tr></table></figure></div>
<p><strong>关闭命令回显有以下几种方式：</strong></p>
<ol>
<li>每个需要关闭回显的命令行前加上”@”字符，上述例子关闭回显：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="string">&quot;Hello world!&quot;</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li>执行make时带上参数<code>-s</code>或<code>--slient</code>禁止所有执行命令的显示</li>
<li>在Makefile中使用没有依赖的特殊目标<code>.SILENT</code>也可以禁止所有命令的回显</li>
</ol>
<h3 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h3><p>在Makefile中<strong>书写在同一行中的多个命令属于一个完整的shell命令行</strong>，<strong>书写在独立行的一条命令是一个独立的shell命令行</strong>。所以需要注意：在一个规则的命令中，命令行<code>cd</code>改变目录不会对其后的命令的执行产生影响。就是说其后的命令执行的工作目录不会是之前使用<code>cd</code>进入的那个目录。如果要实现这个目的<strong>，</strong>就不能把<code>cd</code>和其后的命令放在两行来书写。而应该把这两条命令写在一行上，用分号分隔。这样它们才是一个完整的shell命令行。</p>
<p>对比以下例子两个规则的输出，编写makefile 文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target1:</span></span><br><span class="line">    @echo <span class="string">&quot;target1&quot;</span></span><br><span class="line">    @cd ~</span><br><span class="line">    @pwd</span><br><span class="line"></span><br><span class="line"><span class="section">target2:</span></span><br><span class="line">    @echo <span class="string">&quot;target2&quot;</span></span><br><span class="line">    @cd ~; pwd</span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/24.png" alt></p>
<h3 id="命令执行的错误处理"><a href="#命令执行的错误处理" class="headerlink" title="命令执行的错误处理"></a>命令执行的错误处理</h3><p>通常情况下，规则中的每一条命令在运行结束后，make都会检测命令执行的返回状态，如果返回成功，就执行下一条命令；命令出错（返回状态非0），make就会放弃对当前规则的执行，或者终止对当前makefile的解析执行。</p>
<p>在一些情况下，规则中的一个命令的执行失败并不代表规则执行的错误。为了忽略一些无关紧要的命令执行失败的情况，我们可以在命令之前加一个减号<code>-</code>，来告诉make忽略此命令的执行失败检查。</p>
<p>在更加深入的认识了makefile的规则后，我们complicated项目的makefile(v1.3)就可以这样写了：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.3</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 定义源文件列表变量</span></span><br><span class="line">sources := main.c complicated.c</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></div>
<h2 id="5-内嵌函数"><a href="#5-内嵌函数" class="headerlink" title="5.内嵌函数"></a>5.内嵌函数</h2><p>make的内嵌函数为我们提供了处理文件名、变量、文本和命令的方法。使我们的Makefile更为灵活和健壮。我们可以在需要的地方调用函数来处理指定的文本（参数），函数在调用它的地方被替换为它的处理结果。函数调用（引用）的展开和变量引用的展开方式类似：</p>
<p>函数调用方式1:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(FUNCTION ARGUMENTS)</span></span><br></pre></td></tr></table></figure></div>
<p>函数调用方式2：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line">$&#123;FUNCTION ARGUMENTS&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="内嵌函数的分类"><a href="#内嵌函数的分类" class="headerlink" title="内嵌函数的分类"></a>内嵌函数的分类</h3><p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/25.png" alt></p>
<p><strong>使用wildcard函数改进complicated项目makefile:</strong></p>
<p>wildcard函数，其使用范式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> PATTERN)</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>函数名称：wildcard</p>
<p>函数功能：列出当前目录下所有符合模式“PATTERN”格式的文件名。</p>
<p>返回值：空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。</p>
<p>函数说明：“PATTERN”使用shell可识别的通配符，包括<code>?</code>（单字符）、<code>*</code>（多字符）等。</p>
</blockquote>
<p>示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure></div>
<p>返回值为当前目录下所有.c源文件列表。</p>
<p>我们可以引进wildcard函数，改进complicated项目的makefile，使其能够自动扫描当前目录下的源文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.4</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># 引进wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sourcecs := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> </span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/26.png" alt></p>
<h2 id="6-自动生成依赖关系"><a href="#6-自动生成依赖关系" class="headerlink" title="6.自动生成依赖关系"></a>6.自动生成依赖关系</h2><p>complicated项目的makefile已经完成的比较完善了，但还存在一个问题，当更新头文件complicated.h的内容后，执行make时，项目并不会重新编译。</p>
<p>出现以上问题的根本原因是，我们的makefile还没能精确的反映整个项目工程的依赖关系！很明显，项目的依赖关系应该加入对于头文件的依赖，即如下图：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/27.png" alt></p>
<p>根据上述依赖关系，我们可以在makefile加上如下规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(objects)</span>: complicated.h</span><br></pre></td></tr></table></figure></div>
<p>上述新增规则，是一条多目标规则，它与之前的静态模式规则，又组成了多规则目标，可自行思考其工作原理。</p>
<p>上述规则加入虽然能解决我们的问题，但是对于大型复杂的项目，这种需要我们逐个去分析头文件被依赖的关系，几乎是不可能的。所以我们需要工具来帮我们做这个事。下面我们来介绍如何实现自动生成依赖关系。</p>
<p>gcc提供了这样的功能，帮助我们分析一个文件对其他文件的依赖关系列表。在执行gcc时带上<code>-MM</code>选项时，gcc工具就会列出指定文件对其他文件的依赖关系列表。直接来看例子：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/28.png" alt></p>
<p>接下来要考虑的问题就是如何将gcc的输出导入到makefile中了。</p>
<p>makefile支持使用<code>sinclude</code>关键字将指定文件导入到当前的makefile当中，它的作用与C语言的<code>#include</code>预处理命令是一样的。使用方式<code>sinclude &lt;other_makefiles&gt;</code>。</p>
<p>因此，可以将gcc对于源文件的依赖关系分析输出到某个文件(可以称为依赖描述文件，一般命名为与源文件同名但以.d结尾的文件)当中，然后再将依赖描述文件导入到makefile中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入依赖描述文件列表</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br></pre></td></tr></table></figure></div>
<p>当使用<code>sinclude</code>关键字向当前makefile导入文件时，如果所导入的文件不存在，make会试图去执行可以生产导入文件的规则去生产被导入的文件，然后再执行导入。</p>
<p>因此可以使用静态模式规则，让make在执行时，去调用gcc生成依赖关系文件，可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    gcc -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>因此，complicated项目的最终makefile可以这么写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 描述：complicated 项目 makefile文件</span></span><br><span class="line"><span class="comment"># 版本：v1.5</span></span><br><span class="line"><span class="comment"># 修改记录：</span></span><br><span class="line"><span class="comment"># 1. 为complicated项目makefile添加注释</span></span><br><span class="line"><span class="comment"># 2. 使用变量改进我们complicated项目的makefile</span></span><br><span class="line"><span class="comment"># 3. 使用静态模式规则，简化makefile</span></span><br><span class="line"><span class="comment"># 4. 使用伪目标，加上clean规则</span></span><br><span class="line"><span class="comment"># 5. 引进wildcard函数，自动扫描当前目录下的源文件</span></span><br><span class="line"><span class="comment"># 6. 加入自动规则依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义可执行文件变量</span></span><br><span class="line">executbale := complicated</span><br><span class="line"><span class="comment"># wildcard函数扫描源文件，定义列表变量</span></span><br><span class="line">sources := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义object文件列表</span></span><br><span class="line">objects := $(sources:.c=.o)</span><br><span class="line"><span class="comment"># 使用变量的引用替换，定义依赖描述文件列表</span></span><br><span class="line">deps := $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义编译命令变量</span></span><br><span class="line">CC := gcc</span><br><span class="line">RM := rm -rf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终极目标规则，生成complicated可执行文件</span></span><br><span class="line"><span class="variable">$(executbale)</span>: <span class="variable">$(objects)</span></span><br><span class="line"><span class="comment">#  使用自动化变量改造我们的编译命令</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子规则, main.o和complicated.o的生成规则，使用静态模式规则</span></span><br><span class="line"><span class="variable">$(objects)</span>:%.o:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span>  -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean规则</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(executbale)</span> <span class="variable">$(objects)</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动规则依赖</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(deps)</span>:%.d:%.c</span><br><span class="line">    <span class="variable">$(CC)</span> -MM <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></div>
<p>运行结果：</p>
<p><img src="/2020/03/15/Makefile%E5%AD%A6%E4%B9%A0/29.png" alt></p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty线程模型</title>
    <url>/2023/02/18/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Netty 的线程模型是基于 Reactor 模型改进而来的，因此需要先熟悉 Reactor 模型，帮助对于 Netty 线程模型的理解。</p>
</blockquote>
<h1 id="一-Reactor-模型"><a href="#一-Reactor-模型" class="headerlink" title="一. Reactor 模型"></a><strong>一. Reactor 模型</strong></h1><h2 id="1-为什么需要-Reactor-模型"><a href="#1-为什么需要-Reactor-模型" class="headerlink" title="1.为什么需要 Reactor 模型"></a><strong>1.为什么需要 Reactor 模型</strong></h2><p> 传统阻塞 IO 模型具有设计上的不足之处：</p>
<ul>
<li>每个连接都需要独立线程处理，当并发数大时，创建线程数多，占用资源</li>
<li>采用阻塞IO模型，连接建立后，若当前线程没有数据可读，线程会阻塞在读操作上，造成资源浪费</li>
</ul>
<p>针对传统阻塞IO模型的两个问题，可以采用如下的方案：</p>
<ul>
<li>基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给线程池处理</li>
<li>基于IO复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理</li>
</ul>
<h2 id="2-什么是-Reactor-模型"><a href="#2-什么是-Reactor-模型" class="headerlink" title="2.什么是 Reactor 模型"></a><strong>2.什么是 Reactor 模型</strong></h2><p>The reactor design_pattern is an event_handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</p>
<p>Reactor 设计模型是一种事件处理模式，用于处理通过一个或多个输入同时传递给服务处理程序的服务请求。然后，服务处理程序对传入的请求进行多路分解，并将它们同步分派给关联的请求处理程序。Reactor 模式也被称作 Dispatcher 模式。它的核心是 <strong>多路复用器</strong> ，多路复用器收到事件后会进行分发，这点是网络服务器高并发的关键。Reacotr 模型主要分为三个角色：</p>
<ol>
<li><strong>Reactor</strong> ：把 IO 事件分配给对应的 handler 处理</li>
<li><strong>Acceptor</strong> ：处理客户端连接事件</li>
<li><strong>Handler</strong> ：处理非阻塞的任务</li>
</ol>
<p>通过这三个角色的配合，实现了高并发的操作。而Reactor 模型分为三种：</p>
<ol>
<li><strong>单 Reactor 单线程</strong></li>
<li><strong>单 Reactor 多线程</strong></li>
<li><strong>多 Reactor 多线程</strong></li>
</ol>
<p>这三种模型按顺序来看理解起来复杂度不断提升，也会更接近 Netty 的线程模型，下面来分别看看这三种模型。</p>
<h3 id="1-单-Reactor-单线程"><a href="#1-单-Reactor-单线程" class="headerlink" title="(1). 单 Reactor 单线程"></a><strong>(1). 单 Reactor 单线程</strong></h3><p>这个最好理解，只有 <strong>一个线程</strong> ，只是会把 <strong>建立连接</strong> 和 <strong>处理请求</strong> 这两种任务分发给不同的类去处理，如下图所示：</p>
<center class="half"> 
    <img src="/2023/02/18/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/1.PNG" width="70%">
    <div>图1:单Reactor单线程</div>
</center>

<p>整个流程简单来讲就是：</p>
<ol>
<li>Reactor 通过 Selector 监听事件</li>
<li>收到事件使用 dispatch 对事件进行分发<ul>
<li>如果是连接事件就由 Acceptor 进行处理，处理完成会创建一个 Handler 对后续业务进行处理。</li>
<li>后面的数据请求都会由 Handler 进行处理</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>模型简单，不会有多线程的那些问题</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>性能问题：单线程无法发挥多核 CPU 的性能</li>
<li>可靠性问题：处理业务时往往容易出问题，当 Handler 出问题了，由于只有一个线程，整个节点也挂了</li>
</ul>
<h3 id="2-单-Reactor-多线程"><a href="#2-单-Reactor-多线程" class="headerlink" title="(2). 单 Reactor 多线程"></a>(2). 单 Reactor 多线程</h3><p>这个线程模型针对前面的问题作出了一定的优化，多出了处理业务的线程池，如下图所示：</p>
<center class="half"> 
    <img src="/2023/02/18/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/2.PNG" width="90%">
    <div>图2:单Reactor多线程</div>
</center>

<p>前面的流程与单 Reactor 单线程是一致的，到 Handler 这一步就不一样了：</p>
<ul>
<li>这个模型 <strong>Handler 只负责读取数据和发送数据部分，业务处理交给了 Worker 线程</strong>，而 Worker 线程是由 Worker 线程池统一管理的。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>可以充分利用多核 CPU 的处理能力</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多线程资源共享和访问处理会比较复杂，在主线程处理所有的连接、监听和响应也会出现性能瓶颈</li>
</ul>
<h3 id="3-主从-Reactor-多线程"><a href="#3-主从-Reactor-多线程" class="headerlink" title="(3). 主从 Reactor 多线程"></a>(3). 主从 Reactor 多线程</h3><p>主从 Reactor 多线程模型又在前面的模型基础上做了进一步优化， <strong>增加了子 Reactor</strong> ，如下图所示：</p>
<center class="half"> 
    <img src="/2023/02/18/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/3.png" width="80%">
    <div>图3:多Reactor多线程</div>
</center>

<p><strong>整个流程大概可以分为以下几步</strong>：</p>
<ul>
<li>主线程的 <code>MainReactor</code> 负责监听连接请求，收到连接请求会由 <code>Acceptor</code> 进行处理，成功建立连接之后 <code>MainReactor</code> 会把连接分派给 <code>SubReactor</code> ，由 <code>SubReactor</code> 监听和处理数据请求；</li>
<li><code>SubReactor</code> 监听到数据请求，会派发给 Handler 处理，Handler 只会处理读取数据和发送数据部分，中间业务处理部分也是放在线程池中完成。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><code>MainReactor</code> 与 <code>SubReactor</code> 职责分明，一个处理连接事件，一个处理数据请求；</li>
<li><code>MainReactor</code> 与 <code>SubReactor</code> 交互逻辑比较简单，<code>MainReactor</code> 单向地将建立好的连接传递出去；</li>
<li>多 Reactor 设计能在高并发场景拥有更好的性能。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>编程复杂度较高</li>
</ul>
<p>主从 Reactor 多线程模式是业界非常成熟的服务器程序设计模式，在很多中间件中都使用到了这种模式，像 Nginx、Memcached、Netty 等。这种模式也被称为 1 + M + N 模式，分别代指相对少的连接线程（不一定为 1 ），多个 I/O 线程和多个业务处理线程。</p>
<h1 id="二-Netty-线程模型"><a href="#二-Netty-线程模型" class="headerlink" title="二. Netty 线程模型"></a>二. Netty 线程模型</h1><p>Netty 线程模型是基于主从 Reactor 多线程模型优化而来的，整体架构如下图所示：</p>
<center class="half"> 
    <img src="/2023/02/18/Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/4.png" width="100%">
    <div>图4:Netty线程</div>
</center>

<p>Netty 的线程模型主要分为两部分，分别是 <code>BossGroup</code> 和 <code>WorkerGroup</code>，它们都分别管理一个或多个 <code>NioEventLoop</code>。每个 <code>NioEventLoop</code> 对应着一个线程，一个 <code>Selector</code>，一个 <code>Executor</code> 和一个 <code>TaskQueue</code>。<code>NioEventLoop</code> 可以理解成一个事件循环：</p>
<ul>
<li>当程序启动后每个 <code>NioEventLoop</code> 都会通过 <code>Executor</code> 启动一个线程，开始执行事件循环。</li>
<li>在循环中 <code>Selector</code> 会通过 select 方法阻塞并监听就绪事件，当有事件到来时通过 <code>processSeelectedKeys</code> 方法处理 Selector 事件。</li>
<li>之后再通过 <code>runAllTasks</code> 方法处理其他的任务。</li>
</ul>
<p>与前面介绍的 主从 Reactor 多线程模型类似：</p>
<ul>
<li><code>BossGoup</code> 负责连接事件，当建立连接之后会生成一个 <code>NioSocketChannel</code> 并注册到 <code>WorkGroup</code> 其中一个 <code>NioEventLoop</code> 的 Selector 上。</li>
<li><code>WokerGroup</code> 中的 <code>NioEventLoop</code> 负责处理数据请求，当请求到来时会调用 <code>processSelectedKeys</code> 方法，其中的业务处理会依次经过 Pipeline 中的多个 Handler。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb学习</title>
    <url>/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-GDB-的基本介绍"><a href="#1-GDB-的基本介绍" class="headerlink" title="1.GDB 的基本介绍"></a>1.GDB 的基本介绍</h1><p>GDB, 是 <code>The GNU Project Debugger</code> 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<p>在终端输入以下命令安装 GDB：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install gdb</span></span><br></pre></td></tr></table></figure></div>
<h2 id="1-GDB的进入和退出"><a href="#1-GDB的进入和退出" class="headerlink" title="1.GDB的进入和退出"></a>1.GDB的进入和退出</h2><p>首先用bugging.c作为实验例子。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum+i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    result = foo(N);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2+3+...+%d= %d\n&quot;</span>, N, result);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>如果要调试程序，需要在 gcc 编译可执行程序时加上 <code>-g</code> 参数，首先我们编译 <code>bugging.c</code> 程序，生成可执行文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc bugging.c -o bugging -g -m64</span></span><br></pre></td></tr></table></figure></div>
<p>其中 <code>-o</code> 指定输出文件名, 虚拟机的环境是 64 位的操作系统，所以默认会编译为 64 位的程序，添加 -m64 选项可以编译为 64 位。</p>
<p>如果在你的环境里编译报错，请安装 <code>libc6-dev-i386</code> 后再次编译：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install libc6-dev-i386</span></span><br></pre></td></tr></table></figure></div>
<p>输入 <code>gdb bugging</code> 进入 gdb 调试 bugging 程序的界面：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb bugging</span></span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>run</code> 执行待调试程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) run</span></span><br></pre></td></tr></table></figure></div>
<p>在 gdb 命令行界面，输入<code>quit</code> 退出 gdb：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb) quit</span></span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/1.png" style="zoom:50%;"></p>
<h2 id="2-GDB-命令行界面使用技巧"><a href="#2-GDB-命令行界面使用技巧" class="headerlink" title="2.GDB 命令行界面使用技巧"></a>2.GDB 命令行界面使用技巧</h2><p>命令补全：</p>
<blockquote>
<p>任何时候都可以使用 <code>TAB</code> 进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合 <code>TAB</code> 即可快速输入命令。</p>
</blockquote>
<p>部分 gdb 常用命令一览表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">简写形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">l</td>
<td style="text-align:center">查看源码</td>
</tr>
<tr>
<td style="text-align:center">backtrace</td>
<td style="text-align:center">bt,where</td>
<td style="text-align:center">打印函数栈信息</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">n</td>
<td style="text-align:center">执行下一行</td>
</tr>
<tr>
<td style="text-align:center">step</td>
<td style="text-align:center">s</td>
<td style="text-align:center">一次执行一行，遇到函数会进入</td>
</tr>
<tr>
<td style="text-align:center">finish</td>
<td style="text-align:center"></td>
<td style="text-align:center">运行到函数结束</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">c</td>
<td style="text-align:center">继续运行</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">b</td>
<td style="text-align:center">设置断点</td>
</tr>
<tr>
<td style="text-align:center">info breakpoints</td>
<td style="text-align:center"></td>
<td style="text-align:center">显示断点信息</td>
</tr>
<tr>
<td style="text-align:center">delete</td>
<td style="text-align:center">d</td>
<td style="text-align:center">删除断点</td>
</tr>
<tr>
<td style="text-align:center">print</td>
<td style="text-align:center">p</td>
<td style="text-align:center">打印表达式的值</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">r</td>
<td style="text-align:center">启动程序</td>
</tr>
<tr>
<td style="text-align:center">until</td>
<td style="text-align:center">u</td>
<td style="text-align:center">执行到指定行</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">i</td>
<td style="text-align:center">显示信息</td>
</tr>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">h</td>
<td style="text-align:center">帮助信息</td>
</tr>
</tbody>
</table>
</div>
<p>查询用法：</p>
<blockquote>
<p>在 gdb 命令行界面，输入 <code>help command</code> 可以查看命令的用法，command 是你想要查询的命令。</p>
</blockquote>
<p>执行 Shell 命令：</p>
<blockquote>
<p>在 gdb 命令行界面可以执行外部的 Shell 命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (gdb)!shell 命令</span></span><br></pre></td></tr></table></figure></div>
<p>例如查看当前目录的文件：</p>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/2.png" style="zoom:50%;"></p>
</blockquote>
<h2 id="3-GDB-查看源码"><a href="#3-GDB-查看源码" class="headerlink" title="3.GDB 查看源码"></a>3.GDB 查看源码</h2><p><strong><em>list</em> 命令用来显示源文件中的代码。</strong></p>
<ul>
<li>list 行号，显示某一行附近的代码：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/3.png" style="zoom:50%;"></p>
<ul>
<li>list 函数名，显示某个函数附近的代码：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/4.png" style="zoom:50%;"></p>
<ul>
<li>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</li>
</ul>
<h2 id="4-GDB-断点"><a href="#4-GDB-断点" class="headerlink" title="4.GDB 断点"></a>4.GDB 断点</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><p><code>break</code> 命令用来设置断点。</p>
<ul>
<li>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行</strong>：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/5.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 行号，适用于有多个源文件的情况。</li>
</ul>
<ul>
<li>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行</strong>：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/6.png" style="zoom:50%;"></p>
<ul>
<li>break 文件名 : 函数名，适用于有多个源文件的情况。</li>
</ul>
<h4 id="2-查看断点信息"><a href="#2-查看断点信息" class="headerlink" title="2.查看断点信息"></a>2.查看断点信息</h4><p><code>info breakpoints</code> 命令用于显示当前断点信息。</p>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/7.png" style="zoom:50%;"></p>
<p>其中每一项的信息：</p>
<blockquote>
<ul>
<li>Num 列代表断点编号，该编号可以作为 delete/enable/disable 等控制断点命令的参数</li>
<li>Type 列代表断点类型，一般为 breakpoint</li>
<li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li>
<li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li>
<li>Address 列代表该断点处虚拟内存的地址</li>
<li>What 列代表该断点在源文件中的信息</li>
</ul>
</blockquote>
<h3 id="3-删除断点"><a href="#3-删除断点" class="headerlink" title="3.删除断点"></a>3.删除断点</h3><p><code>delete</code> 命令用于删除断点。</p>
<ul>
<li>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/8.png" style="zoom:50%;"></p>
<ul>
<li>delete，不带任何参数，默认删除所有断点：</li>
</ul>
<h3 id="4-关闭和启用断点"><a href="#4-关闭和启用断点" class="headerlink" title="4.关闭和启用断点"></a>4.关闭和启用断点</h3><p><code>disable</code> 命令和 <code>enable</code> 命令分别用于关闭和启用断点：</p>
<blockquote>
<p><em>disable</em> 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。</p>
<p><em>enable</em> 命令用于启用断点。</p>
</blockquote>
<ul>
<li>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/9.png" style="zoom:50%;"></p>
<ul>
<li><p>disable，不带任何参数，默认关闭所有断点。</p>
</li>
<li><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。</p>
</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/10.png" style="zoom:50%;"></p>
<ul>
<li>enable，不带任何参数，默认启用所有断点。</li>
</ul>
<p><strong>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</strong></p>
<h3 id="5-断点启用的更多方式"><a href="#5-断点启用的更多方式" class="headerlink" title="5.断点启用的更多方式"></a>5.断点启用的更多方式</h3><p><code>enable</code> 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p>
<ul>
<li>enable once Num，断点 hit 一次之后关闭该断点</li>
<li>enable delete Num，断点 hit 一次之后删除该断点</li>
</ul>
<p><img src="/2020/03/26/gdb%E5%AD%A6%E4%B9%A0/11.png" style="zoom:50%;"></p>
<p><strong>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为。</strong></p>
<h3 id="6-断点调试的一些命令"><a href="#6-断点调试的一些命令" class="headerlink" title="6. 断点调试的一些命令"></a>6. 断点调试的一些命令</h3><ol>
<li><strong>打印变量</strong></li>
</ol>
<p>调试的过程中需要观察变量或者表达式的值，所以先介绍两个基本的显示变量值的命令：</p>
<blockquote>
<ul>
<li><p><code>info locals</code></p>
<p>打印当前断点处所在函数的所有局部变量的值，不包括函数参数。</p>
</li>
<li><p><code>print 变量或表达式</code></p>
<p>打印表达式的值，可显示当前函数的变量的值、全局变量的值等</p>
<p><code>print/FMT</code> 可以控制打印的格式，常见的有x(十六进制)、t(二进制)、c(显示为字符)等。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>启动程序</strong></li>
</ol>
<p><em>run</em> 命令用于启动待调试程序，并运行到断点处停下。</p>
<blockquote>
<ul>
<li><p><code>run</code></p>
<p>不带任何参数，启动待调试程序，不传递参数。</p>
</li>
<li><p><code>run 参数</code></p>
<p>有些程序需要跟参数，直接带上参数列表即可，会传递给 main 函数的 argc、argv 变量。</p>
</li>
</ul>
</blockquote>
<ol>
<li><strong>单步命令</strong></li>
</ol>
<p><em>next, step, finish, continue, until</em> 用于控制整个调试过程中，程序执行的流程。</p>
<blockquote>
<ul>
<li><p><code>next</code></p>
<blockquote>
<p>next 单步执行，函数调用当做一条指令，<font color="red"><strong>不会进入被调用函数内部</strong></font></p>
<p>next N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>step</code></p>
<blockquote>
<p>step 单步执行，<font color="red"><strong>会进入到函数调用内部</strong></font></p>
<p>step N，表示单步执行N次</p>
</blockquote>
</li>
<li><p><code>finish</code></p>
<p>执行程序到当前函数结束</p>
</li>
<li><p><code>continue</code></p>
<p>执行程序到下个断点</p>
</li>
<li><p><code>until</code></p>
<p>until N，执行程序到源代码的某一行</p>
</li>
</ul>
</blockquote>
<h3 id="7-断点小结"><a href="#7-断点小结" class="headerlink" title="7. 断点小结"></a>7. 断点小结</h3><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p>
<blockquote>
<ul>
<li><code>list</code></li>
<li><code>info breakpoints</code></li>
<li><code>break</code></li>
<li><code>delete</code></li>
<li><code>disable</code> 和 <code>enable</code></li>
<li><code>enable once</code> 和 <code>enable delete</code></li>
<li><code>next</code>, <code>step</code>, <code>finish</code>, <code>continue</code>, <code>until</code></li>
<li><code>info locals</code> 和 <code>print</code></li>
</ul>
</blockquote>
<p>不熟悉命令的时候，记得在 gdb 命令行下键入 <code>help info breakpoints</code> 等命令，查询帮助文档。</p>
]]></content>
      <categories>
        <category>Linux C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>东大一个月以来的反思</title>
    <url>/2019/10/04/%E4%B8%9C%E5%A4%A7%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BB%A5%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1 跑步已进入瓶颈期，6km以下已经不怎么出汗。改变有氧运动为跳绳后发现10mins就能汗如雨下，搭配着来很重要。其次，不能间断超过三天，否则要浪费一天时间去重新适应。现在又办理了健身卡，今天晚上也要制定减脂增肌的健身与饮食计划，一定要在元旦之前减到65kg以下。</p>
<hr>
<p>2 以后就算是和老师们聚餐也要控制酒精摄入。更要学会委婉的拒绝。</p>
<hr>
<p>3 事实证明自己之前的胡思乱想归根结底还是闲的，让自己有计划有节奏的忙碌起来。爱情这东西命里有时终须有，命里无时也莫强求，对现在的自己而言没有那么重要。</p>
<hr>
<p>4 至于以后到底读不读博，就业是否留在实验室得等到寒假之后再思考，这个学期主要是找到物理层安全的价值点与兴趣点所在，多读论文。</p>
<hr>
<p>5 不要过于自卑，自己也没有那么弱，运气只会对努力的，有准备的人奏效，它也是实力的一种，不然自己也不会在这进修了!</p>
<hr>
<p>6 体态和肤质只需坚持一个季度就能改变，并不难。细细想来和当初考研异曲同工，只要稳扎稳打一年就能改变所在平台，这是回报率很高的“交易”。等到11月发了奖学金可以试着买一套护肤的保养保养，毕竟自己的皮肤也需要保护，自己的形象也很重要。</p>
<hr>
<p>7 年少时觉得那些大道理似乎很空，所以忘得很快。现在读的书慢慢多了，经历的慢慢丰富了，身边却很少有人那么“苦口婆心”的教导自己，很感谢随机过程老师每节课这么督促我们，仔细琢磨后觉得既兴奋有懊悔，以后要把所以空闲时间都用在学习与思考上。</p>
<hr>
<p>8 老师们都说如果能把高考时的拼劲放到现在，没有什么是解决不了的。不过高三时的自己并没有那么拼命，也让自己刻意忘记了那时的日子。所以自己不妨试着再找回考研时候的拼劲，时刻思考，时刻背诵。我相信自己一定会有所成的。</p>
<hr>
<p>9 如切如磋，如琢如磨，战战兢兢，如履薄冰。希望不负“百载文枢江左，东南辈出英豪。”的期望!</p>
]]></content>
      <categories>
        <category>感悟与反思</category>
      </categories>
      <tags>
        <tag>感悟与反思</tag>
      </tags>
  </entry>
  <entry>
    <title>减脂塑性规划</title>
    <url>/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-健身部位与动作"><a href="#一-健身部位与动作" class="headerlink" title="一.健身部位与动作"></a>一.健身部位与动作</h1><h2 id="1-胸部"><a href="#1-胸部" class="headerlink" title="1.胸部"></a>1.胸部</h2><ul>
<li><p><strong>俯卧撑</strong></p>
<blockquote>
<p>可以练到胸肌、肱三头肌，甚至可以练到我们的肩部，是一个非常经典的自重动作。</p>
</blockquote>
</li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/1.jpg" alt></p>
<ul>
<li><strong>平板杠铃卧推（宽握）：</strong></li>
</ul>
<blockquote>
<p>需要注意三点，一是卧推时杠铃需要自然推起（下放在胸部而顶点在肩关节上方），二是杠铃要尽量下放到贴近胸部的位置再推起，三是卧推时杠铃下放触及的应该是乳头附近的位置。 </p>
<p>很多新手卧推时，推起放下往往不是垂直的，下放往往放到肩部附近，这就是错误的推法，这样卧推是刺激不到胸肌的。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/2.jpg" alt></p>
<ul>
<li><strong>上斜板杠铃卧推（宽握</strong></li>
</ul>
<blockquote>
<p>其实就是将平板的角度向上倾斜45~60度<br>上斜板卧推需要注意的是，下放的位置不是乳头附近，而是下放到锁骨即可。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/3.jpg" alt></p>
<ul>
<li><strong>下斜板哑铃卧推（宽握）</strong></li>
</ul>
<blockquote>
<p>下斜卧推杠铃是下放到乳头往下3cm的位置，但是远没有到腹部。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/4.jpg" alt></p>
<ul>
<li><strong>窄握</strong></li>
</ul>
<blockquote>
<p>下面这是平板杠铃卧推（窄握）。窄握是提高卧推力量的很好的方法，和宽握相比，窄握中肱三头肌受力更大，卧推力量遇到瓶颈时，可以用窄握来突破。上斜和下斜的窄握就不贴了。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/5.jpg" alt></p>
<ul>
<li><strong>绳索飞鸟</strong></li>
</ul>
<blockquote>
<p>这应该是对胸肌中缝刺激最大的动作了。</p>
<p>这个动作需要注意的是，手要尽量打开，肘关节微曲，不要用腰背过分的借力。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/6.jpg" alt></p>
<ul>
<li><strong>哑铃飞鸟</strong></li>
</ul>
<blockquote>
<p>做哑铃飞鸟时你去想象你前面有个人，你要去「拥抱」他，就是用那种拥抱的感觉去练飞鸟就对了。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/7.jpg" alt></p>
<ul>
<li><strong>双臂杆屈伸</strong></li>
</ul>
<blockquote>
<p>这是在飞鸟和卧推之外的动作，根据身体倾向状况，刺激的肌肉部位也不同，身体越前倾，胸大肌的刺激越大，越直立，就越容易刺激肱三头肌。</p>
</blockquote>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/8.jpg" alt></p>
<hr>
<h2 id="2-腹部"><a href="#2-腹部" class="headerlink" title="2.腹部"></a>2.腹部</h2><ul>
<li><strong>上腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/9.jpg" alt></p>
<blockquote>
<p>注意不是做全程,而是双臂托着头向上抬起,感觉上面有个鱼饵要去吃的感觉.(60+)</p>
</blockquote>
<ul>
<li><strong>中腹肌、下腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/10.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/11.jpg" alt></p>
<blockquote>
<p>100+</p>
</blockquote>
<ul>
<li><strong>下腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/12.jpg" alt></p>
<blockquote>
<p>对于下腹肌有非常好的效果,坚持一段时间会出现V字型的线条</p>
<p>注意：腿部不要碰到地面。50+</p>
</blockquote>
<ul>
<li><strong>侧腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/13.jpg" alt></p>
<blockquote>
<p>注意点，全程上胸处于抬起状态，而不是躺下再起来，快速交替触碰.(100+)</p>
</blockquote>
<ul>
<li><strong>中腹肌</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/14.jpg" alt></p>
<blockquote>
<p>注意这个动作要水平的打开,而不是向下去打开,完全可以在地上做以臀部为支点.(60+)</p>
</blockquote>
<ul>
<li>中腹肌</li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/15.jpg" alt></p>
<blockquote>
<p>这个动作完全可以不负重,空手快速进行.(60+)</p>
</blockquote>
<hr>
<h2 id="3-腿"><a href="#3-腿" class="headerlink" title="3.腿"></a>3.腿</h2><ul>
<li><strong>颈后杠铃深蹲</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/16.gif" alt></p>
<blockquote>
<p>一个合格的负重深蹲动作，需要让你有顺畅的感觉，不别扭，可以自由发力的感觉，膝盖不要内扣，快起慢下，感受大腿燃烧的绷感.</p>
<p><strong>站距</strong>：稍微比肩膀宽一点，八字步站开，30度左右.</p>
<p><strong>膝盖的朝向和脚一样，朝外，无论多大重量，绝对不能内扣！！</strong></p>
</blockquote>
<ul>
<li><strong>箭步深蹲</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/17.gif" alt></p>
<blockquote>
<p>十分有效的动作，深蹲的一种，对塑造臀部也十分有帮助。</p>
<p>要领：膝盖要中立，不要出现单侧内扣.</p>
</blockquote>
<hr>
<h2 id="4-背"><a href="#4-背" class="headerlink" title="4.背"></a>4.背</h2><ul>
<li><strong>无敌黄金引体向上</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/18.jpg" alt></p>
<blockquote>
<p>主要可以锻炼到的肌群有：背阔肌，大圆肌，小园肌，肱二头肌。次要肌肉：三角肌后束，胸肌，腹肌，斜方肌等。</p>
</blockquote>
<ul>
<li><p><strong>高位下拉</strong> </p>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/19.jpg" alt></p>
</li>
</ul>
<blockquote>
<p> 需要注意：背要直，可以稍微向后仰一点，调整膝垫至合适位置。膝垫可以避免身体因为阻力而上升。吐气的同时将肩膀和上臂向后下方拉动，拉下把手直至碰到上胸。</p>
<p>提示：完全收紧时集中注意力收缩后背肌肉。动作中上躯应保持固定，只有手臂运动。前臂只需抓握杠杆，没有其他动作，不要用前臂拉动把手。</p>
<p>呼吸：用力下拉时呼气，还原时吸气</p>
</blockquote>
<ul>
<li><strong>宽度动作三直臂下拉</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/20.jpg" alt></p>
<blockquote>
<ol>
<li>正握握住宽把，掌心向下，双臂距离超过肩宽。后退60厘米左右。</li>
<li>上身向前，弯向前倾斜30度，双手在前方伸直,手肘略弯.。手臂无法完全伸直就继续后退，直到手臂完全伸直，弯腰，背阔肌绷紧，准备开始。</li>
<li>保持手臂伸直,收缩背阔肌下拉把手直至大腿,</li>
</ol>
</blockquote>
<ul>
<li><strong>哑铃划船</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/21.jpg" alt></p>
<blockquote>
<p>这个动作会让你的鼠蹊部（就是腹股沟，还是不懂就叫：腚沟子）处于一个容易受伤的状态.</p>
</blockquote>
<ul>
<li><strong>坐姿划船：</strong></li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/22.jpg" alt></p>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/23.gif" alt></p>
<blockquote>
<p>1 两腿踩住前方的踏板，<strong>微屈膝，腿不可伸直</strong>，两手紧握三角形（或其他形状的）手柄，双臂前伸，<strong>腰腹固定</strong>,挺胸抬头。</p>
<p>2.收缩背部肌肉，加紧肩胛骨，用这股力量，将手柄拉至腹部，尽可能地向后牵拉你的双肩和双肘，直到手柄接触到你的身体中部。可以保持顶峰收缩1-2秒，努力挤压你的肩胛骨，得到最大程度的刺激.</p>
<p>3.以背阔肌的力量控制还原，所谓的快拉慢回，控制速度，但是！不需要过慢。</p>
</blockquote>
<ul>
<li>硬拉</li>
</ul>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/24.gif" alt></p>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/25.jpg" alt></p>
<p><img src="/2019/10/18/%E5%87%8F%E8%84%82%E5%A1%91%E6%80%A7%E8%A7%84%E5%88%92/26.jpg" alt></p>
<blockquote>
<p>这是一个垂直运动的轨迹，沉肩，核心收紧。发力的时候，感受力从地起，腘绳肌，大腿，臀部，下背，一气呵成，感受力从地起，屁股夹紧的感觉。</p>
<p>呼吸：硬拉在上了大重量以后（4-6RM甚至更重）用普通的呼吸方法是会出现危险的，为什么？</p>
<p>因为，在大重量的硬拉训练中，脊椎面临很大的压力，普通的呼吸造成的压力很难维持脊椎中立稳定，所以要憋气！就是所谓瓦式呼吸。先在动作进行前吸一口气，将气回压在下腹创造腹内压（往内挤压），努力紧绷你的腰椎周围肌群，想象别人要在你肚子上打一拳。直到完成一次动作后才进行吐气，动作全程是憋气的。再说一遍：准备动作深吸一口气，并且在发力的时候紧闭声门hold住这一口气。</p>
</blockquote>
]]></content>
      <categories>
        <category>减脂塑形</category>
      </categories>
      <tags>
        <tag>减脂塑形</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大学习—内存管理</title>
    <url>/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-内存的使用与分段"><a href="#一-内存的使用与分段" class="headerlink" title="一.内存的使用与分段"></a>一.内存的使用与分段</h1><h2 id="一-内存的使用"><a href="#一-内存的使用" class="headerlink" title="(一).内存的使用"></a>(一).内存的使用</h2><p>让内存使用的方法：把程序放在内存中，然后取址执行。</p>
<p>接下来的问题就是;</p>
<ul>
<li>如何让程序放入内存中</li>
<li>如何让程序执行起来</li>
</ul>
<p>方法：</p>
<ul>
<li>找一段空闲内存，将程序载入到这段内存中</li>
<li>根据逻辑地址进行重定位，设置好PC初始位置</li>
<li>进行取址执行</li>
</ul>
<blockquote>
<p>进行重定位的时间可以是编译时，也可以是载入时。编译时重定位的程序只能放在内存固定位置，载入时重定位的程序一旦载入内存就不能动了，这样也有缺点，<strong>当阻塞时会进行交换，物理地址就会发生变换。</strong>所以重定位最合适的时机是<strong>运行时重定位。</strong></p>
</blockquote>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png" style="zoom:50%;"></p>
<ul>
<li>运行时把base地址与逻辑地址相加，成为物理地址。</li>
<li>然后根据物理地址找到对应地方的代码</li>
</ul>
<blockquote>
<p>基地址放在进程的PCB中</p>
</blockquote>
<h2 id="二-内存的分段"><a href="#二-内存的分段" class="headerlink" title="(二).内存的分段"></a>(二).内存的分段</h2><p>程序由若干部分<strong>(</strong>段<strong>)</strong>组成，每个段有各自的特点、用途：代码段只读，代码<strong>/</strong>数据段不会动态增长</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png" style="zoom:50%;"></p>
<p>这样符合用户观点<strong>:</strong> 用户可独立考虑每个段(分治)。</p>
<p>定位具体指令(数据)：<font color="red"><strong>&lt;</strong>段号<strong>,</strong> 段内偏移<strong>&gt;</strong></font></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png" style="zoom:50%;"></p>
<p>操作系统的段表是GDT表，其余进程中的段表是LDT表。</p>
<hr>
<p><br></p>
<h1 id="二-内存分区与分页"><a href="#二-内存分区与分页" class="headerlink" title="二.内存分区与分页"></a>二.内存分区与分页</h1><h2 id="一-内存分区"><a href="#一-内存分区" class="headerlink" title="(一).内存分区"></a>(一).内存分区</h2><p>操作系统初始化时进行内存分区作，主要有固定分区和可变分区两种操作，操作系统基本都是使用可变分区的操作。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png" style="zoom:50%;"></p>
<p>可变分区的操作管理是通过核心数据结构来进行分配操作的。主要的管理方式有三种：</p>
<ul>
<li><strong>首先适配：</strong>根据空闲分区表的初试地址开始找</li>
<li><strong>最佳适配：</strong>和申请内存大小最接近的</li>
<li><strong>最差适配：</strong>直接找空闲内存最大的</li>
</ul>
<h2 id="二-内存分页"><a href="#二-内存分页" class="headerlink" title="(二).内存分页"></a>(二).内存分页</h2><blockquote>
<p>为了解决内存分区导致的内存效率问题，引入了内存分页</p>
</blockquote>
<h3 id="可变分区造成的问题"><a href="#可变分区造成的问题" class="headerlink" title="可变分区造成的问题"></a>可变分区造成的问题</h3><p>比如当总空闲空间<strong>&gt;160</strong>，但没有一个空闲分区<strong>&gt;160</strong>，就会出现大片内存无法利用的情况，而这些内存都是以内存碎片的形式出现的。</p>
<p>解决思路1：</p>
<p>将空闲分区合并，需要移动 <strong>1</strong>个段<strong>(</strong>复制内容<strong>)</strong>:内存紧缩。</p>
<p>但是内存紧缩需要花费大量时间，如 果复制速度<strong>1M/1</strong>秒，则<strong>1G</strong>内存 的紧缩时间为<strong>1000</strong>秒»<strong>17</strong>分钟</p>
<p>所以这个思路不行。</p>
<h3 id="提出分页的思路"><a href="#提出分页的思路" class="headerlink" title="提出分页的思路"></a>提出分页的思路</h3><p>将内存分成页，针对每个段内存请求，系统一页一页的分配给这个段，这样就能更合理化的利用内存。</p>
<p>但是页中的地址仍然是逻辑地址，需要进行计算转换成物理地址。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png" style="zoom:50%;"></p>
<p>以逻辑地址为0x2240为例计算物理地址，具体转换过程如下：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png" style="zoom:50%;"></p>
<hr>
<p><br></p>
<h1 id="三-多级页表与快表"><a href="#三-多级页表与快表" class="headerlink" title="三.多级页表与快表"></a>三.多级页表与快表</h1><blockquote>
<p> 对于上一章所提出的内存分页，为了提高内存空间利用率，页应该小，但是页小了页表就大了。页面尺寸通常为<strong>4K</strong>，而地址是<strong>32</strong>位的，有<strong>$2^{20}$</strong>个页面。<strong><em>$2^{20}$</em></strong>个页表项都得放在内存中，需要<strong>4M</strong>内存；系统中并发<strong>10</strong>个进程，就需要<strong>40M</strong>内存。这样就会造成内存的浪费。</p>
</blockquote>
<h2 id="一-解决思路一：只存放用到的页"><a href="#一-解决思路一：只存放用到的页" class="headerlink" title="(一).解决思路一：只存放用到的页"></a>(一).解决思路一：只存放用到的页</h2><ul>
<li><strong>用到的逻辑页才有页表项。</strong></li>
</ul>
<p>但页表中的页号不连续，就需要比较、查找，折半等查找操作，但是这样访问内存的次数就会增加，而处理器相比于计算，访问内存相对会花很长的时间，这样很不理想。</p>
<h2 id="二-解决思路二：多级页表"><a href="#二-解决思路二：多级页表" class="headerlink" title="(二).解决思路二：多级页表"></a>(二).解决思路二：多级页表</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png" style="zoom:40%;"></p>
<p>多级页表既保证了页表的连续性，也保证了在内存中存放的内存少了。</p>
<p>虽然提高了空间效率，但是在时间效率上仍然不能达到理想。</p>
<h2 id="三-解决思路三：引入快表"><a href="#三-解决思路三：引入快表" class="headerlink" title="(三).解决思路三：引入快表"></a>(三).解决思路三：引入快表</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/8.png" style="zoom:50%;"></p>
<p><strong>TLB</strong>是一组相联快速存储，是寄存器。</p>
<p>访问内存时，先访问快表，如果在快表内，就可直接知道页框号。如果不在快表内，则老老实实去多级页表查看。但是快表也会实时更新。</p>
<p>当TLB的命中率很高时，时间和空间效率都很理想。</p>
<hr>
<p><br></p>
<h1 id="四-段页结合的实际内存管理"><a href="#四-段页结合的实际内存管理" class="headerlink" title="四.段页结合的实际内存管理"></a>四.段页结合的实际内存管理</h1><h2 id="一-段页式存储方式"><a href="#一-段页式存储方式" class="headerlink" title="(一).段页式存储方式"></a>(一).段页式存储方式</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/9.png" style="zoom:50%;"></p>
<p>逻辑地址先转化成虚拟地址，然后虚拟地址转换成物理地址，具体转换方式如下图：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png" style="zoom:50%;"></p>
<p>这就是段,页同时存在的重定位。</p>
<hr>
<h1 id="五-内存换入——请求调页"><a href="#五-内存换入——请求调页" class="headerlink" title="五.内存换入——请求调页"></a>五.内存换入——请求调页</h1>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大学习—操作系统基础</title>
    <url>/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-从通用图灵机到计算机"><a href="#一-从通用图灵机到计算机" class="headerlink" title="一.从通用图灵机到计算机"></a>一.从通用图灵机到计算机</h1><p>1946年，冯诺依曼提出<strong><font color="red">存储程序思想</font></strong>。存储程序的主要思想是<strong>将程序和数据存放到计算机内部的存储器中，计算机在程序的控制下一步一步进行处理</strong>。</p>
<p>计算机由五大部件组成：输入设备、输出设备、存储器、运算器、控制器。</p>
<center class="half"> 
    <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/1.png" style="zoom:50%;">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图1：简单的例子</div>
</center>


<p>基本流程：</p>
<ul>
<li>程序载入到存储器中</li>
<li>用指令指针IP来指向当前需要处理的指令</li>
<li>载入指令，形成控制逻辑，进行解释执行：把地址[100]的值赋给ax。</li>
<li>接着IP指向下一条指令</li>
</ul>
<p>总结就是四个字：<strong><font color="red">取址执行。</font></strong></p>
<h1 id="二-操作系统的开启流程"><a href="#二-操作系统的开启流程" class="headerlink" title="二.操作系统的开启流程"></a>二.操作系统的开启流程</h1><blockquote>
<p>从打开电源开始，这神秘的黑色背后发生着什么?</p>
<p>即打开电源后计算机要开始工作了计算机怎么工作<strong>?</strong> 这是最最基本， 也最最重要的常识。</p>
</blockquote>
<h2 id="1-最开始的执行"><a href="#1-最开始的执行" class="headerlink" title="1.最开始的执行"></a>1.最开始的执行</h2><p>以X86结构为例子：</p>
<p><strong>(1) x86 PC</strong>刚开机时<strong>CPU</strong>处于实模式</p>
<p><strong>(2)</strong>开机时，<strong>CS=0xFFFF; IP=0x0000</strong></p>
<blockquote>
<p>CS为段寄存器，IP为偏移</p>
<p>和保护模式对应，实模式的寻址<strong>CS:IP(CS</strong>左移<strong>4</strong>位<strong>+IP)</strong>， 和保护模式不一样<strong>!</strong></p>
<p>所以是先左移四位，然后加上IP，结果为0xFFFF0</p>
</blockquote>
<p><strong>(3)</strong>寻址<strong>0xFFFF0(ROM BIOS</strong>映射区<strong>)</strong>[Basic input output system] </p>
<blockquote>
<p> 这段程序固化在内存中 </p>
</blockquote>
<p><strong>(4)</strong> 检查<strong>RAM</strong>，键盘，显示器，软硬磁盘 </p>
<blockquote>
<p>先检查硬件设备</p>
</blockquote>
<p><strong>(5)</strong> 将磁盘<strong>0</strong>磁道<strong>0</strong>扇区读入<strong>0x7c00</strong>处</p>
<blockquote>
<p>读入一个扇区，即512字节，读到<strong>0x7c00</strong>处</p>
<p><strong>0</strong>磁道<strong>0</strong>扇区是操作系统中的<strong>引导扇区。</strong></p>
</blockquote>
<p><strong>(6)</strong> 设置<strong>cs=0x07c0</strong>，<strong>ip=0x0000</strong></p>
<h2 id="2-0x7c00处存放的代码"><a href="#2-0x7c00处存放的代码" class="headerlink" title="2. 0x7c00处存放的代码"></a>2. <strong>0x7c00</strong>处存放的代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight"><table><tr><td class="code"><pre><span class="line">BOOTSEG = 0x07c0</span><br><span class="line">INITSEG = 0x9000</span><br><span class="line">SETUPSEG = 0x9020</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.globl</span> begtext,begdata,begbss,endtext,enddata,endbss</span><br><span class="line"><span class="selector-class">.text</span> <span class="comment">//文本段</span></span><br><span class="line">begtext:</span><br><span class="line">.data //数据段</span><br><span class="line">begdata:</span><br><span class="line">.bss //未初始化数据段</span><br><span class="line">begbss:</span><br><span class="line">entry start //关键字entry告诉链接器“程序入口”</span><br><span class="line">start:</span><br><span class="line">	mov ax, <span class="number">#B</span>OOTSEG	mov ds, ax //ds = <span class="number">#B</span>OOTSEG[<span class="number">0</span>x07c0]</span><br><span class="line">  mov ax, #INITSEG	mov es, ax //es = <span class="number">0</span>x9000</span><br><span class="line">  mov cx, <span class="number">#256</span></span><br><span class="line"></span><br><span class="line">  sub si, si				sub di, di //形成段内偏移：si-si = <span class="number">0</span> , di-di = <span class="number">0</span></span><br><span class="line">	//ds 和 es 是段寄存器，加上上面的段内偏移形成地址</span><br><span class="line">	//ds 与 si 接成地址：左移四位加上<span class="number">0</span>为：<span class="number">0</span>x7c000</span><br><span class="line">	//es 与 di 接成地址：左移四位加上<span class="number">0</span>为：<span class="number">0</span>x90000</span><br><span class="line"></span><br><span class="line">  rep   movw//重复移动<span class="number">256</span>个字,即<span class="number">512</span>个字节</span><br><span class="line">	//将<span class="number">0</span>x07c0:<span class="number">0</span>x0000处的<span class="number">256</span>个字移动到<span class="number">0</span>x9000:<span class="number">0</span>x0000处，腾出空间来操作</span><br><span class="line"></span><br><span class="line">  jmpi  go, INITSEG//jmp直接跳转，jmpi间接跳转</span><br><span class="line">	//go赋给ip,INITSEG赋给cs</span><br><span class="line">	//此时INITSEG = <span class="number">90000</span>,go就是偏移的位置，距离为<span class="number">300</span></span><br><span class="line">	//跳转到<span class="number">90300</span>,也就是下面的go:</span><br><span class="line"></span><br><span class="line">go: mov ax,cs //cs=<span class="number">0</span>x9000	</span><br><span class="line">	mov ds,ax mov es,ax mov ss,ax mov sp,<span class="number">#0</span>xff00</span><br><span class="line">load_setup: //载入setup模块</span><br><span class="line">	mov dx,<span class="number">#0</span>x0000 mov cx,<span class="number">#0</span>x0002 mov bx,<span class="number">#0</span>x0200</span><br><span class="line">	mov ax,<span class="number">#0</span>x0200+SETUPLEN int <span class="number">0</span>x13 //BIOS中断</span><br><span class="line">	//<span class="number">0</span>x13是BIOS读磁盘扇区的中断:</span><br><span class="line">	//ah=<span class="number">0</span>x02-读磁盘，al= 扇区数量(SETUPLEN=<span class="number">4</span>)， ch=柱面号，cl=开始扇区， dh=磁头号，dl=驱动器号， es:bx=内存地址</span><br><span class="line">	//cl开始扇区，为cx的开始八位：<span class="number">02</span>，所以从第二个扇区开始读</span><br><span class="line">	//al= 扇区数量(SETUPLEN=<span class="number">4</span>),读入扇区的个数，低八位，也就是<span class="number">4</span>个扇区</span><br><span class="line">	jnc ok_load_setup</span><br><span class="line">	mov dx,<span class="number">#0</span>x0000</span><br><span class="line">	mov ax,<span class="number">#0</span>x0000 //复位</span><br><span class="line">	int <span class="number">0</span>x13</span><br><span class="line">	j load_setup //重读</span><br></pre></td></tr></table></figure></div>
<center class="half"> 
    <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/2.png" style="zoom:50%;">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图2：启动盘读入的扇区</div>
</center>




<h2 id="3-读入setup模块之后的操作"><a href="#3-读入setup模块之后的操作" class="headerlink" title="3.读入setup模块之后的操作"></a>3.读入setup模块之后的操作</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">Ok_load_setup: //载入setup模块</span><br><span class="line">	mov dl,<span class="number">#0</span>x00  mov ax,<span class="number">#0</span>x0800	//ah=<span class="number">8</span>获得磁盘参数</span><br><span class="line">	int <span class="number">0</span>x13      mov ch,<span class="number">#0</span>x00    mov sectors,cx</span><br><span class="line">	mov ah,<span class="number">#0</span>x03  xor bh,bh       int <span class="number">0</span>x10 //读光标</span><br><span class="line">	mov cx,<span class="number">#24</span>    mov bx,<span class="number">#0</span>x0007</span><br><span class="line">	//<span class="number">24</span>是需要输出的字符个数</span><br><span class="line"></span><br><span class="line">	mov bp,#msg1	mov ax,<span class="number">#1301</span>    int <span class="number">0</span>x10 //BIOS中断：显示字符</span><br><span class="line">	//bp需要显示的字符所在的地址</span><br><span class="line"></span><br><span class="line">	mov ax,#SYSSEG //SYSSEG=<span class="number">0</span>x1000</span><br><span class="line">	mov es,ax</span><br><span class="line">	call read_it //读入system模块</span><br><span class="line">	jmpi <span class="number">0</span>,SETUPSEG</span><br><span class="line"></span><br><span class="line">//##############<span class="number">#b</span>ootsect.s中的数据//在文件末尾###############//</span><br><span class="line">sectors: .word <span class="number">0</span> //磁道扇区数</span><br><span class="line">msg1:.byte <span class="number">13</span>,<span class="number">10</span></span><br><span class="line">		.ascii “Loading system...”</span><br><span class="line">		.byte <span class="number">13</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure></div>
<h2 id="4-读入read-it"><a href="#4-读入read-it" class="headerlink" title="4.读入read_it"></a>4.读入read_it</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read_it调用13号中断，把操作系统后面的内容读入，读入之后bootset就结束了。</span></span><br><span class="line">read_it: 	mov ax,es cmp ax,<span class="number">#E</span>NDSEG jb ok1_read</span><br><span class="line">					ret</span><br><span class="line">ok1_read:</span><br><span class="line">	mov ax,sectors</span><br><span class="line">	sub ax,sread //sread是当前磁道已读扇区数,ax未读扇区数</span><br><span class="line">	call read_track //读磁道...</span><br></pre></td></tr></table></figure></div>
<p>bootsect操作内容就是读入操作系统然后打出开机logo。</p>
<p>bootset退出后，需要把控制权交给下一个程序——setup</p>
<p>交接控制权的方式就是跳转。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.org</span> 510</span><br><span class="line">	<span class="selector-class">.word</span> 0xAA55 <span class="comment">//扇区的最后两个字节</span></span><br></pre></td></tr></table></figure></div>
<p>可以转入<strong>setup</strong>执行了，<strong>jmpi 0, SETUPSEG</strong></p>
<blockquote>
<p> ip = 0, cs = <strong>SETUPSEG</strong></p>
<p> 地址为cs左移四位加上ip，然后取值执行。</p>
<p> SETUPSEG = 9020，ip=0，所以地址为90200</p>
</blockquote>
<h2 id="5-setup模块"><a href="#5-setup模块" class="headerlink" title="5.setup模块"></a>5.setup模块</h2><blockquote>
<p>setup将完成OS启动前的设置</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">start: mov ax,#INITSEG mov ds,ax mov ah,<span class="number">#0</span>x03</span><br><span class="line">	xor bh,bh int <span class="number">0</span>x10//取光标位置dx mov [<span class="number">0</span>],dx</span><br><span class="line"></span><br><span class="line">	//<span class="number">15</span>号中断来获取内存的大小，获取的值在ax中，然后赋给<span class="number">2</span>的间接寻址，<span class="number">9000</span>+<span class="number">2</span>——&gt;<span class="number">9002</span>存扩展内存大小</span><br><span class="line">	//知道内存大小后才能更好的管理内存 </span><br><span class="line">	mov ah,<span class="number">#0</span>x88 int <span class="number">0</span>x15 mov [<span class="number">2</span>],ax ...</span><br><span class="line"></span><br><span class="line">	cli ///不允许中断</span><br><span class="line">	mov ax,<span class="number">#0</span>x0000 cld</span><br><span class="line">do_move: mov es,ax add ax,<span class="number">#0</span>x1000</span><br><span class="line">	cmp ax,<span class="number">#0</span>x9000 jz end_move</span><br><span class="line">	mov ds,ax sub di,di</span><br><span class="line">	sub si,si</span><br><span class="line">	mov cx,<span class="number">#0</span>x8000</span><br><span class="line">	rep</span><br><span class="line">	movsw</span><br><span class="line">	jmp do_move</span><br></pre></td></tr></table></figure></div>
<p>将操作系统的代码移动到0地址处，然后应用程序的地址就一直处于操作系统往上的地址处。</p>
<h2 id="6-保护模式下的地址翻译与中断处理"><a href="#6-保护模式下的地址翻译与中断处理" class="headerlink" title="6.保护模式下的地址翻译与中断处理"></a>6.保护模式下的地址翻译与中断处理</h2><h3 id="1-保护模式下的地址翻译"><a href="#1-保护模式下的地址翻译" class="headerlink" title="(1).保护模式下的地址翻译"></a>(1).保护模式下的地址翻译</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/4.png" style="zoom:50%;"></p>
<p>cs是选择子，而不是之前的左移操作，用来作为查表索引，选择表中的表项产生基址，再和IP偏移，加上一起产生32位地址。而这个表就是gdt表。</p>
<h3 id="2-保护模式下中断处理函数入口"><a href="#2-保护模式下中断处理函数入口" class="headerlink" title="(2).保护模式下中断处理函数入口"></a>(2).保护模式下中断处理函数入口</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/5.png" style="zoom:50%;"></p>
<p>在保护模式下，中断也是通过寻找表项来进入中断函数的入口。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">end_move: mov ax,#SETUPSEG mov ds,ax</span><br><span class="line">	lidt idt_48 lgdt gdt_48//设置保护模式下的中断和寻址</span><br><span class="line">idt_48:.word <span class="number">0</span> .word <span class="number">0</span>,<span class="number">0</span> //保护模式中断函数表	</span><br><span class="line">gdt_48:.word <span class="number">0</span>x800 .word <span class="number">512</span>+gdt,<span class="number">0</span>x9</span><br><span class="line"></span><br><span class="line">//初始化gdt表</span><br><span class="line">gdt: .word <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	.word <span class="number">0</span>x07FF, <span class="number">0</span>x0000, <span class="number">0</span>x9A00, <span class="number">0</span>x00C0</span><br><span class="line">	.word <span class="number">0</span>x07FF, <span class="number">0</span>x0000, <span class="number">0</span>x9200, <span class="number">0</span>x00C0</span><br><span class="line">//有了这个表再配合 lgdt gdt_48 这个指令就启动了三十二位模式。</span><br></pre></td></tr></table></figure></div>
<center class="half"> 
    <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/3.png" style="zoom:40%;">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图3：cr0寄存器</div>
</center>




<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">call empty_8042 mov al,<span class="selector-id">#0xD1</span> out <span class="selector-id">#0x64</span>,al<span class="comment">//8042是键盘控制器，其输出端口P2用来控制A20地址线</span></span><br><span class="line">call empty_8042 mov al,<span class="selector-id">#0xDF</span> out <span class="selector-id">#0x60</span>,al<span class="comment">//选通A20地址线 </span></span><br><span class="line">call empty_8042 <span class="comment">//初始化8259(中断控制) 一段非常机械化的程序</span></span><br><span class="line">mov ax,<span class="selector-id">#0x0001</span> mov cr0,ax</span><br><span class="line"><span class="comment">//把1赋给ax,然后把ax赋给cr0，进入保护模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个指令就不是之前的左移相加操作，而是32位操作。</span></span><br><span class="line">jmpi 0,8</span><br></pre></td></tr></table></figure></div>
<center class="half"> 
    <img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/6.png" style="zoom:40%;">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图5：gdt计算</div>
</center>


<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.word</span> 0x07FF, 0x0000, 0x9A00, 0x00C0</span><br></pre></td></tr></table></figure></div>
<p>从左往右分别放入段限长，段基址15，段基址23，段基址31，结果是0x0000，加上ip也等于0，所以加上为0地址,然后跳到0地址处去执行，也就是移动后的操作系统地址去执行。</p>
<p>而system中的第一个被执行的文件就是head.s。</p>
<h2 id="7-head-s"><a href="#7-head-s" class="headerlink" title="7.head.s"></a>7.head.s</h2><blockquote>
<p> <strong>setup</strong>是进入保护模式，<strong>head</strong>是进入之后的初始化</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入保护模式，就是32位汇编</span></span><br><span class="line">stratup_32: movl $<span class="number">0</span>x10,%eax mov %ax,%ds mov %ax,%es</span><br><span class="line">	mov %as,%fs mov %as,%gs //指向gdt的<span class="number">0</span>x10项(数据段)</span><br><span class="line">	lss _stack_start,%esp //设置栈(系统栈)</span><br><span class="line"></span><br><span class="line">	call setup_idt//初试化idt表</span><br><span class="line">	call setup_gdt//初始化gdt表</span><br><span class="line">	xorl %eax,%eax</span><br><span class="line"><span class="number">1</span>:incl %eax</span><br><span class="line">	movl %eax,<span class="number">0</span>x000000 cmpl %eax,<span class="number">0</span>x100000</span><br><span class="line">	je <span class="number">1</span>b //<span class="number">0</span>地址处和<span class="number">1</span>M地址处相同(A20没开启)，就死循环 jmp after_page_tables //页表，什么东东?</span><br><span class="line">setup_idt: lea ignore_int,%edx</span><br><span class="line">  movl $<span class="number">0</span>x00080000,%eax  movw %dx,%ax</span><br><span class="line">	lea _idt,%edi movl %eax,(%edi)</span><br></pre></td></tr></table></figure></div>
<h2 id="8-设置页表之后"><a href="#8-设置页表之后" class="headerlink" title="8.设置页表之后"></a>8.设置页表之后</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">	pushl $<span class="number">0</span>  pushl $<span class="number">0</span>  pushl $<span class="number">0</span>   pushl <span class="variable">$L6</span> </span><br><span class="line">	pushl $_main 	jmp set_paging</span><br><span class="line">L6: jmp L6</span><br><span class="line">setup_paging: 设置页表 ret</span><br></pre></td></tr></table></figure></div>
<p>流程：</p>
<ul>
<li><strong>setup_paging</strong>执行<strong>ret</strong>后<strong>?</strong> 会执行函数<strong>main()</strong></li>
<li>进入<strong>main()</strong>后的栈为<strong>0</strong>，<strong>0</strong>，<strong>0</strong>，<strong>L6</strong></li>
<li><strong>main()</strong>函数的三个参数是<strong>0</strong>，<strong>0</strong>，<strong>0</strong></li>
<li><strong>main()</strong>函数返回时进入<strong>L6</strong>，死循环</li>
<li>但是main()函数在操作系统开启后是永远执行下去，不会返回进入L6的，不然就会进入死循环——死机。</li>
</ul>
<h2 id="9-进入main函数"><a href="#9-进入main函数" class="headerlink" title="9.进入main函数"></a>9.进入main函数</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在init/main.c中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  mem_init();</span><br><span class="line">	trap_init(); </span><br><span class="line">  blk_dev_init(); </span><br><span class="line">  chr_dev_init(); </span><br><span class="line">  tty_init(); </span><br><span class="line">  time_init(); </span><br><span class="line">  sched_init(); </span><br><span class="line">  buffer_init(); </span><br><span class="line">  hd_init(); </span><br><span class="line">  floppy_init(); </span><br><span class="line">  sti(); </span><br><span class="line">  move_to_user_mode(); </span><br><span class="line">  <span class="keyword">if</span>(!fork())&#123;init();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>main</strong>的工作就是<strong>xx_init:</strong> 内存、中断、设备、 时钟、<strong>CPU</strong>等内容的初始化<strong>…</strong></p>
<p>看一看<strong>mem_init…</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在linux/mm/memory.c中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem,<span class="keyword">long</span> end_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;PAGING_PAGES; i++) </span><br><span class="line">    mem_map[i] = USED;</span><br><span class="line">	i = MAP_NR(start_mem); </span><br><span class="line">  end_mem -= start_mem; </span><br><span class="line">  end_mem &gt;&gt;= <span class="number">12</span>; </span><br><span class="line">  <span class="keyword">while</span>(end_mem -- &gt; <span class="number">0</span>)</span><br><span class="line">		mem_map[i++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>就是初始化了一个称为 <strong>mem_map</strong>的数组<strong>…</strong></p>
<p><strong>总结开机流程就是：</strong></p>
<ul>
<li><p><strong>bootsect读入操作系统</strong></p>
<ul>
<li><p>将操作系统从磁盘上读入内存</p>
</li>
<li><p>固化取值读入</p>
</li>
<li>把set up模块读入内存</li>
<li>打印出开机logo</li>
<li>调用13号中断，把操作系统后面的部分读入执行</li>
</ul>
</li>
<li><p><strong>进入setup模块</strong></p>
<ul>
<li>完成OS启动前的设置</li>
<li>进入保护模式，进行32位汇编</li>
</ul>
</li>
<li><strong>进入head.s汇编</strong><ul>
<li>传参进入main.c</li>
</ul>
</li>
<li><strong>进入main函数</strong><ul>
<li><strong>main</strong>的工作就是<strong>xx_init:</strong> 内存、中断、设备、 时钟、<strong>CPU</strong>等内容的初始化<strong>…</strong></li>
</ul>
</li>
</ul>
<h1 id="三-操作系统的接口"><a href="#三-操作系统的接口" class="headerlink" title="三.操作系统的接口"></a>三.操作系统的接口</h1><p>接口：连接上层应用与操作系统，完成信号转换和屏蔽细节的功能。</p>
<p>用户使用计算机的方式：命令行，图形按钮，应用程序。</p>
<h2 id="分析命令行"><a href="#分析命令行" class="headerlink" title="分析命令行"></a>分析命令行</h2><p>命令是什么：只是一段程序。</p>
<p>具体工作流程，以一个c语言文件编译运行为例。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="built_in">printf</span>(“ECHO:%s\n”, argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后编译运行，以下就是一段shell程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc –o output output.c</span><br><span class="line"> ./output “hello”</span><br></pre></td></tr></table></figure></div>
<p>具体工作原理：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cmd[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">//不断的等待用户敲入命令</span></span><br><span class="line">    <span class="built_in">scanf</span>(“%s”, cmd);<span class="comment">//敲入之后</span></span><br><span class="line">		<span class="keyword">if</span>(!fork()) &#123;<span class="comment">//——&gt;进程管理的内容</span></span><br><span class="line">    	exec(cmd);<span class="comment">//执行敲入的命令</span></span><br><span class="line">  	&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">    	wait();<span class="comment">//等待</span></span><br><span class="line">  	&#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后申请CPU，让CPU去执行<code>printf(“ECHO:%s\n”, argv[1]);</code>这一段代码，在终端中打印出最后的结果。</p>
<p><strong>所以可以看出，命令行就是程序，只是在程序执行的过程中增加了一些函数，通过这些函数来对计算机硬件进行使用。</strong></p>
<h2 id="分析图形按钮"><a href="#分析图形按钮" class="headerlink" title="分析图形按钮"></a>分析图形按钮</h2><p>图形按钮是基于<strong>消息处理机制。</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/12.png" style="zoom:30%;"></p>
<ul>
<li>点击鼠标时，通过中断进入系统内部的消息队列</li>
<li>应用程序完成系统调用，进行GetMessage，从内核中把消息提取出来</li>
<li>根据拿出来的是什么消息，就执行对应的函数，来完成对应的功能</li>
<li>应用程序就是一个不断从消息队列中取消息的一个循环</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以上层应用使用硬件就是普通的c语言数加上一些关键性的重要函数。而这些<strong>重要的函数就是操作系统接口</strong>， <font color="red">接口表现为函数调用，又由系统􏰀供，所以称为系统调用。</font></p>
<h1 id="四-系统调用的实现"><a href="#四-系统调用的实现" class="headerlink" title="四.系统调用的实现"></a>四.系统调用的实现</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>为了保护用户隐私与操作系统的安全，把程序进行了隔离，分为内核程序与用户程序。进而又分了用户态/内核态，内核/用户段这些概念。</p>
<p>区分内核态和用户态是通过一种处理器“硬件设计”完成的。其中设计了内核寄存器和用户寄存器CS，DS。CPL用来描述当前的内存段的特权级 ，DPL用来描述目标内存段的特权级。其中，0是内存态，3是用户态。</p>
<p>当用户程序需要进入内核态执行时，硬件也提供了主动进入内核的方法。对于Intel x86，就是终端指令int。</p>
<p><strong>系统调用的核心：</strong></p>
<ul>
<li>用户程序中包含一段包含<strong>int</strong>指令的代码</li>
<li>操作系统写中断处理，获取想调程序的编号</li>
<li>操作系统根据编号执行相应代码</li>
</ul>
<h2 id="2-系统调用的实现"><a href="#2-系统调用的实现" class="headerlink" title="2.系统调用的实现"></a>2.系统调用的实现</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/7.png" style="zoom:30%;"></p>
<p><strong>以<code>printf</code>为例讲解系统调用的实现：</strong></p>
<ul>
<li><p>首先应用程序中的<code>printf</code>先调用库函数中的<code>printf</code> </p>
</li>
<li><p>然后库函数中的<code>printf</code>调用<code>wirte</code></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/8.png" style="zoom:30%;"></p>
</li>
<li><p>然后变成一段包含<code>int 0x80</code>的中断代码</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/9.png" style="zoom:30%;"></p>
</li>
<li><p>然后中断代码通过系统调用进入 操作系统</p>
</li>
</ul>
<h2 id="3-Linux系统调用的实现细节"><a href="#3-Linux系统调用的实现细节" class="headerlink" title="3.Linux系统调用的实现细节"></a>3.Linux系统调用的实现细节</h2><p>对于上面的库函数<code>write</code>函数而言，它的实现方式是通过宏来展开成汇编代码。所以系统调用的细节就可以从宏开始说起。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在linux/include/unistd.h中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3的含义是具有3个参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(type,name,atype,a,btype,b,ctype,c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//展开内容为int write(int fd, const char *buf, off_t count)</span></span><br><span class="line"><span class="function">type <span class="title">name</span><span class="params">(atype a, btype b, ctype c)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">long</span> __res;</span><br><span class="line">  <span class="comment">//汇编指令，核心代码只有一句：“int 0x80”</span></span><br><span class="line">  <span class="comment">//其中：  ”=a”(__res)为输出  “”(__NR_##name)为输入 ，即把_NR_write赋给eax</span></span><br><span class="line">	__asm__ volatile(“int 0x80”:”=a”(__res):””(__NR_##name), ”b”((long)(a)),”c”((long)(b)),“d”((long)(c)))); </span><br><span class="line">  <span class="keyword">if</span>(__res&gt;=<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> (type)__res; </span><br><span class="line">  errno=-__res; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br></pre></td></tr></table></figure></div>
<p>显然，<strong>__NR_write</strong>是系统调用号，放在<strong>eax</strong>中</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/10.png" style="zoom:30%;"></p>
<p>通过<strong>eax</strong>的值来说明进行中断调用<code>int 0x80</code>的原因。</p>
<h3 id="int-0x80中断的处理"><a href="#int-0x80中断的处理" class="headerlink" title="int 0x80中断的处理"></a><strong>int 0x80</strong>中断的处理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//设置中断处理门——每一个表项，初始化gdt表，之后遇到0x80中断，就从表中取出相应的中断处理函数。</span></span><br><span class="line">  set_system_gate(<span class="number">0x80</span>, &amp;system_call);</span><br><span class="line">  <span class="comment">//system_call为中断处理函数的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在linux/include/asm/system.h中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//n：中断号,addr：中断地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n, addr) _set_gate(&amp;idt[n],15,3,addr); <span class="comment">//idt是全局变量，中断向量表基址 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的三赋给dpl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr, type, dpl, addr) __asm__(“movw %%dx,%%ax\n\t” “movw %0,%%dx\n\t”\ “movl %%eax,%1\n\t” “movl %%edx,%2”:\ :”i”((short)(0x8000+(dpl&lt;&lt;13)+type&lt;&lt;8))),“o”(*(( \ char*)(gate_addr))),”o”(*(4+(char*)(gate_addr))),\ “d”((char*)(addr),”a”(0x00080000))</span></span><br></pre></td></tr></table></figure></div>
<p>通过int 0x80中断将80号中断的dpl设置为3，让cpl等于3的程序能进入内核，然后通过int 0x80中断设置cpl成0，这样才能进行内核处理。</p>
<h3 id="中断处理程序：system-call"><a href="#中断处理程序：system-call" class="headerlink" title="中断处理程序：system_call"></a>中断处理程序：system_call</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">nr_system_calls=72</span><br><span class="line"><span class="selector-class">.globl</span> _system_call</span><br><span class="line">_system_call: cmpl <span class="variable">$nr_system_calls-1</span>,%eax</span><br><span class="line">	ja bad_sys_call</span><br><span class="line">	push %ds push %es push %fs</span><br><span class="line">	pushl %edx pushl %ecx pushl %ebx //调用的参数</span><br><span class="line">	movl $<span class="number">0</span>x10,%edx mov %dx,%ds mov %dx,%es //内核数据 </span><br><span class="line">	movl $<span class="number">0</span>x17,%edx mov %dx,%fs //fs可以找到用户数据 </span><br><span class="line">	call _sys_call_table(,%eax,<span class="number">4</span>) //a(,%eax,<span class="number">4</span>)=a+<span class="number">4</span>*eax </span><br><span class="line">	pushl %eax //返回值压栈，留着ret_from_sys_call时用</span><br><span class="line">	... //其他代码</span><br><span class="line">ret_from_sys_call: popl %eax, 其他pop, iret</span><br></pre></td></tr></table></figure></div>
<h3 id="sys-call-table"><a href="#sys-call-table" class="headerlink" title="_sys_call_table"></a>_sys_call_table</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在include/linux/sys.h中</span></span><br><span class="line">fn_ptr sys_call_table[] = &#123;sys_setup, sys_exit, sys_fork, sys_read, sys_write,...&#125;;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在include&#x2F;linux&#x2F;sched.h中</span><br><span class="line">typedef int(fn_ptr*) ();</span><br></pre></td></tr></table></figure></div>
<p><strong>整个过程：</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/11.png" style="zoom:50%;"></p>
<ul>
<li>用户调用printf函数，首先通过库函数变成一段int 0x80代码</li>
<li>调用int 0x80代码时，cpl和dpl都是3，这样才能从用户态转变为内核态</li>
<li>int 0x80代码在初始化时做成了system_cal</li>
<li>进入中断处理之后cpl变成0</li>
<li>system_cal调用system_cal_table进行查表</li>
<li>根据传入的系统调用号_NR_write，即ax值</li>
<li>根据ax的值与system_call_table表确定调用内容</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统基础</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大学习—设备驱动与文件系统</title>
    <url>/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>设备驱动与文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>哈工大学习—进程与线程</title>
    <url>/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-CPU管理的直观想法"><a href="#一-CPU管理的直观想法" class="headerlink" title="一.CPU管理的直观想法"></a>一.CPU管理的直观想法</h1><h2 id="1-CPU的工作原理"><a href="#1-CPU的工作原理" class="headerlink" title="1.CPU的工作原理"></a>1.CPU的工作原理</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/1.png" style="zoom:40%;"></p>
<ul>
<li>把程序存放在内存中</li>
<li>设置PC指针，比如PC=50</li>
<li>CPU发出取值的命令，把地址=50放在地址总线上</li>
<li>内存会从地址总线上得到这个命令，把地址=50的这条命令从地址总线传到CPU</li>
<li>CPU得到程序指令，解释执行</li>
</ul>
<h2 id="2-管理CPU的最直观方法"><a href="#2-管理CPU的最直观方法" class="headerlink" title="2.管理CPU的最直观方法"></a>2.管理CPU的最直观方法</h2><h3 id="1-最基本"><a href="#1-最基本" class="headerlink" title="(1).最基本"></a>(1).最基本</h3><p><strong>只要设置好PC的初值就行了，</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2.png" style="zoom:40%;"></p>
<p>剩下的CPU会自动的取址执行。</p>
<h3 id="2-问题与解决方案"><a href="#2-问题与解决方案" class="headerlink" title="(2).问题与解决方案"></a>(2).问题与解决方案</h3><p><strong>问题：</strong></p>
<p>如果CPU只能顺序取址执行，那么利用率会很低，因为IO操作相比于CPU的计算操作会很耗时间，这样会导致CPU停顿等待IO操作完成，然后继续工作，利用率大大降低。</p>
<p><strong>解决方案：</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/3.png" style="zoom:30%;"></p>
<p>当CPU遇到IO操作时，直接切换到运行其他程序，等到其他程序也遇到IO或者结束之后再切回来继续执行。这样就提高了CPU的利用率。而这就是<strong>多道程序</strong>的<strong>交替执行</strong>。</p>
<p><strong>一个CPU上交替执行多个程序就是<font color="red">并发</font>。</strong></p>
<h3 id="3-设计并发的注意点"><a href="#3-设计并发的注意点" class="headerlink" title="(3).设计并发的注意点"></a>(3).设计并发的注意点</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/4.png" style="zoom:50%;"></p>
<p>如果只是修改寄存器的话，程序2切换回程序1后，<code>ax</code>与<code>bx</code>会是程序2的记录，这样会导致<code>遗忘</code>程序1的数据记录。<strong>所以不仅要记录返回地址，还需要记录寄存器记录等一系列消息。即程序运行时刻的样子。</strong></p>
<h3 id="4-引入进程的概念"><a href="#4-引入进程的概念" class="headerlink" title="(4).引入进程的概念"></a>(4).引入进程的概念</h3><p>因为运行中的程序与静态的程序不一样，所以需要描述这些不一样。就<strong>定义<font color="red">程序</font>+<font color="red">所有这些不一样</font>的概念为<font color="red">进程</font>。</strong></p>
<blockquote>
<p><strong>进程是进行(执行)中的程序</strong></p>
<ul>
<li><p>进程有开始、有结束，程序没有。</p>
</li>
<li><p>进程会走走停停，走停对程序无意义。</p>
</li>
<li><p>进程需要记录<strong>ax,bx,…,</strong>程序不用。</p>
</li>
</ul>
</blockquote>
<p><br></p>
<h1 id="二-多进程图像"><a href="#二-多进程图像" class="headerlink" title="二.多进程图像"></a>二.多进程图像</h1><h2 id="1-多进程使用CPU的图像"><a href="#1-多进程使用CPU的图像" class="headerlink" title="1.多进程使用CPU的图像"></a>1.多进程使用CPU的图像</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/5.png" style="zoom:30%;"></p>
<p><strong>如何使用CPU?</strong></p>
<ul>
<li>让程序执行起来</li>
</ul>
<p><strong>如何充分利用CPU?</strong></p>
<ul>
<li>启动多个程序，交替执行</li>
</ul>
<p>启动了的程序就是进程，所以是多个进程推进</p>
<ul>
<li><p>操作系统只需要把这些进程记录好、要按照合理的次序推进<strong>(</strong>分配资源、进行调度<strong>)</strong>。这就是多进程图像</p>
<p>。</p>
</li>
</ul>
<h2 id="2-多进程图像从启动开始到关机结束"><a href="#2-多进程图像从启动开始到关机结束" class="headerlink" title="2.多进程图像从启动开始到关机结束"></a>2.多进程图像从启动开始到关机结束</h2><p>开机后会在main函数中的fork()函数中创建第一个进程，即init执行了shell。</p>
<p>然后shell再启动其他进程。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="built_in">scanf</span>(“%s”, cmd); </span><br><span class="line">    <span class="keyword">if</span>(!fork()) </span><br><span class="line">    &#123;</span><br><span class="line">      exec(cmd);</span><br><span class="line">    &#125; </span><br><span class="line">    wait(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>一命令启动一个进 程，返回<strong>shell</strong>再启 动其他进程<strong>…</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/6.png" style="zoom:40%;"></p>
<p>每遇到一个任务时，计算机都是启动一个进程来进行解决。</p>
<h2 id="3-问题1：多进程组织如何组织"><a href="#3-问题1：多进程组织如何组织" class="headerlink" title="3.问题1：多进程组织如何组织"></a>3.问题1：多进程组织如何组织</h2><blockquote>
<p> 计算机只有组织好多个进程，才能合理得推进多进程。</p>
</blockquote>
<p><strong>如何组织进程：</strong>多个进程所对应的 PCB分别放在不同的地方。为了更好的管理，可以根据进程的状态把多个进程进行分类。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/7.png" style="zoom:40%;"></p>
<blockquote>
<ul>
<li>状态图也是推进图</li>
<li>给出进程生存期的清晰􏰀述 </li>
<li>认识操作系统进程管理的一个窗口</li>
</ul>
</blockquote>
<p>操作系统根据这个状态图，让进程实现状态的转换来推进进程。</p>
<h2 id="4-问题2：多进程如何交替"><a href="#4-问题2：多进程如何交替" class="headerlink" title="4.问题2：多进程如何交替"></a>4.问题2：多进程如何交替</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">一个进程 启动磁盘读写;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己的状态变成阻塞态</span></span><br><span class="line">pCur.state = ‘W’; </span><br><span class="line"></span><br><span class="line">将pCur放到阻塞磁盘等待队列DiskWaitQueue; </span><br><span class="line"></span><br><span class="line"><span class="comment">//进行切换</span></span><br><span class="line">schedule();</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">schedule() </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//从就绪队列中找到下一个进程，这边就涉及到了调度，即选哪一个进程</span></span><br><span class="line">	pNew = getNext(ReadyQueue);</span><br><span class="line">  <span class="comment">//把这俩个PCB执行现场的切换</span></span><br><span class="line">	switch_to(pCur,pNew); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>交替主要分为三个部分：<strong>队列操作</strong>，<strong>调度</strong>，<strong>切换</strong>。</p>
<p><strong>调度</strong>：</p>
<ul>
<li>会涉及到很多算法，后面会具体学习。</li>
</ul>
<p><strong>切换：</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/8.png" style="zoom:33%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">switch_to(pCur,pNew) &#123; </span><br><span class="line">  pCur.ax = CPU.ax; </span><br><span class="line">  pCur.bx = CPU.bx;</span><br><span class="line">				...</span><br><span class="line">	pCur.cs = CPU.cs; </span><br><span class="line">  pCur.retpc = CPU.pc;</span><br><span class="line">	</span><br><span class="line">  CPU.ax = pNew.ax; </span><br><span class="line">  CPU.bx = pNew.bx;</span><br><span class="line">				...</span><br><span class="line">	CPU.cs = pNew.cs; </span><br><span class="line">  CPU.retpc = pNew.pc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>进程进行切换时需要把它的上下文——现场信息保存起来，而这个保存工具就是PCB。即把CPU的物理信息保存在PCB这个结构体中。</p>
<p>而这些需要精细的控制，所以需要汇编代码来完成。</p>
<h2 id="5-问题3：多进程如何影响"><a href="#5-问题3：多进程如何影响" class="headerlink" title="5.问题3：多进程如何影响"></a>5.问题3：多进程如何影响</h2><p>多个进程同时存在于内存会出现下面的问题：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/9.png" style="zoom:40%;"></p>
<p>如果地址100是进程2代码内容，则会修改进程2的内容，会导致进程2出错。</p>
<p><strong>解决方案：</strong><font color="red">限制对地址<strong>100</strong>的读写.</font>通过映射表来完成多进程的地址空间分离—内存管理的主要内容。具体如下图所示：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/10.png" style="zoom:40%;"></p>
<p>感觉是逻辑地址的概念。</p>
<h2 id="6-问题4：多进程如何合作"><a href="#6-问题4：多进程如何合作" class="headerlink" title="6.问题4：多进程如何合作"></a>6.问题4：多进程如何合作</h2><p>比如打印工作过程：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/11.png" style="zoom:40%;"></p>
<p>有进程往打印队列中放需要打印的内容，打印进程复制从队列中去内容打印，这就是多进程合作的一个例子，但是这种合作不做处理，同时向前推进就会乱套。比如进程1，2同时向地址7这个空空间放入内容，如果是交替执行就会乱套。</p>
<hr>
<p><br></p>
<h1 id="三-用户级线程"><a href="#三-用户级线程" class="headerlink" title="三.用户级线程"></a>三.用户级线程</h1><p>多进程是操作系统的基本图像，如下图所示：</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/12.png" style="zoom:35%;"></p>
<p> 进程1运行就是执行一堆指令，在执行指令有时是需要访问地址的，而地址是通过映射表获得的。当进程1进行IO操作时会进行切换。如果能够做到切换时之切换指令而不切换表，这就大大节省了时间。</p>
<h2 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1.进程与线程的概念"></a>1.进程与线程的概念</h2><p>可以将<strong>进程</strong>看作是 <strong>指令执行序列</strong> + <strong>资源</strong></p>
<p>将资源和指令执行分开，设置成一个资源 <strong>+</strong> 多个指令执行序列，这样切换起来就会更快，效率更高。而这些指令序列就是线程。<strong><font color="red">线程保留了并发的优点，同时避免了进程切换代价。</font></strong></p>
<h2 id="2-线程的实用性"><a href="#2-线程的实用性" class="headerlink" title="2.线程的实用性"></a>2.线程的实用性</h2><p>对于一个网页浏览器，可以用一个线程用来从服务器接收数据，一个线程用来显示文本，一个线程用来处理图片<strong>(</strong>如解压缩<strong>)</strong>， 一个线程用来显示图片。然后交替执行，再加上线程间可以共享资源，通用一个资源区，所以效率更高。</p>
<p><strong>代码实现：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebExplorer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">char</span> URL[] = “http:<span class="comment">//cms.hit.edu.cn”;</span></span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">  <span class="comment">//创建线程</span></span><br><span class="line">  pthread_create(..., GetData, URL, buffer); </span><br><span class="line">  pthread_create(..., Show, buffer); &#125;</span><br><span class="line">	<span class="comment">//操作</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetData</span><span class="params">(<span class="keyword">char</span> *URL, <span class="keyword">char</span> *p)</span></span>&#123;...&#125;; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>具体流程：</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/13.png" style="zoom:40%;"></p>
<p>两个线程之间通过<code>create</code>函数实现同时出发， <code>Yield</code>函数来进行切换来完成交替执行。</p>
<h2 id="3-Create函数与Yield函数"><a href="#3-Create函数与Yield函数" class="headerlink" title="3.Create函数与Yield函数"></a>3.Create函数与Yield函数</h2><h3 id="1-Yield函数的应用"><a href="#1-Yield函数的应用" class="headerlink" title="(1).Yield函数的应用"></a>(1).Yield函数的应用</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/14.png" style="zoom:40%;"></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/15.png" style="zoom:40%;"></p>
<p><strong>具体运行流程：</strong></p>
<ul>
<li>首先从A函数还是执行，然后遇到B函数执行(线程内部的函数调用)，在这时会把104压栈</li>
<li>进入B执行后，遇到yield函数执行，把返回地址204压栈</li>
<li>运行Yield函数进行切换到下一个指定序列(切换PC指针)，跳到300执行C函数</li>
<li>进入C执行后，遇到D函数执行，把返回地址304压栈</li>
<li>进入D执行后，遇到yield函数执行，把返回地址404压栈</li>
<li>运行Yield函数进行切换到下一个指定序列(切换PC指针)，跳到204执行C函数</li>
<li><font color="red">执行204后遇到`}`，`}`会变成一条汇编指令`ret`进行弹栈，弹出404进行执行</font></li>
<li>执行404就出现问题了</li>
</ul>
<p><strong>问题所在：</strong></p>
<ul>
<li>理论上一个线程之间的函数调用是不能切换到其他线程的，只能在同一个线程中使用，不同线程切换只能通过<code>Yield</code>函数来实现。</li>
</ul>
<p><strong>问题原因：</strong></p>
<ul>
<li><strong>两个线程公用了一个栈。</strong></li>
</ul>
<p><strong>问题解决方案</strong>：</p>
<ul>
<li>两个线程分配两个栈，不能共用一个栈。一个函数调用是在同一个指令序列中实现的，所以一个指令序列中的函数调用需要使用自己的栈。</li>
</ul>
<p><strong>改进方案：</strong></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/16.png" style="zoom:40%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Yield</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//首先把栈切回去。</span></span><br><span class="line">  <span class="comment">//TCB是全局的数据结构，可以存储栈信息</span></span><br><span class="line">  TCB1.esp=esp; </span><br><span class="line">  esp=TCB2.esp; </span><br><span class="line">  <span class="comment">//此条需要删除</span></span><br><span class="line">  jmp <span class="number">204</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>又会出现问题：</strong></p>
<ul>
<li>当B函数执行Yield函数时，会把204压入栈中</li>
<li>然后跳转执行300—&gt;D函数—&gt;Yield函数</li>
<li>D中的Yield函数执行，然后jmp到204执行</li>
<li>执行完后<code>&#125;</code>进行弹栈，弹出204执行</li>
</ul>
<p><strong>这就会出现执行两次204的问题了。</strong></p>
<p><strong>解决方案：</strong></p>
<font color="red">删除Yield中的`jmp 204`指令</font>

<ul>
<li>这样Yield函数执行到最后是<code>&#125;</code>进行弹栈(<strong>之前的Yield函数只能运行的jmp指令就跳，执行不到<code>&#125;</code></strong>)，弹出204</li>
<li>然后运行完204后再通过<code>&#125;</code>进行弹栈，弹出104</li>
<li>这样就能顺利执行了</li>
</ul>
<h3 id="2-Create函数的应用"><a href="#2-Create函数的应用" class="headerlink" title="(2).Create函数的应用"></a>(2).Create函数的应用</h3><p><strong>ThreadCreate</strong>的核心就是用程序做出这三样东西：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadCreate</span><span class="params">(A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//申请内存</span></span><br><span class="line">  TCB *tcb=<span class="built_in">malloc</span>(); </span><br><span class="line">  *<span class="built_in">stack</span>=<span class="built_in">malloc</span>(); </span><br><span class="line">  <span class="comment">//栈中填入线程初始地址</span></span><br><span class="line">  *<span class="built_in">stack</span> = A;<span class="comment">//100 </span></span><br><span class="line">  <span class="comment">//栈和TCB进行关联</span></span><br><span class="line">  tcb.esp=<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p> 实用性举例的浏览器例子是<strong>用户级线程</strong>，当进行IO操作的时候需要进入内核进行硬件的调用，进而产生进程阻塞，此时内核会切换到别的进程，这样浏览器进程中的其他线程就无法执行。所以虽然启动了多个任务序列，但一旦在内核中阻塞，这多个序列的并发性就没有任何的效果。这就需要<strong>核心级线程。</strong></p>
<hr>
<p><br></p>
<h1 id="五-内核级线程"><a href="#五-内核级线程" class="headerlink" title="五.内核级线程"></a>五.内核级线程</h1><blockquote>
<p>进程必须是在内核中，没有用户级进程这一说法(进程要访问资源，设计到硬件操作，所以必须是进入内核操作)。所以切换进程是切换内核级线程</p>
</blockquote>
<h2 id="1-多处理器与多核"><a href="#1-多处理器与多核" class="headerlink" title="1.多处理器与多核"></a>1.多处理器与多核</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/17.png" style="zoom:50%;"></p>
<ul>
<li>多处理器中的每个CPU有自己的缓存和内存映射。而多核中多个CPU共用一个缓存与内存映射，类似于线程的功能。</li>
<li>多个线程分配到多个核上，而且共享一套缓存与映射。这就是多线程。</li>
<li>多进程的话需要切换MMU，无法并行。</li>
<li>多进程和多用户级线程都无法发挥多核的价值。</li>
</ul>
<blockquote>
<p>并发：同时出发，交替执行</p>
<p>并行：一起执行</p>
<p>注意：如果是用户级线程，并没有进入内核，所以操作系统是看不到的，自然无法给它们分配硬件。</p>
</blockquote>
<h2 id="2-核心级线程与用户级线程的不同"><a href="#2-核心级线程与用户级线程的不同" class="headerlink" title="2.核心级线程与用户级线程的不同"></a>2.核心级线程与用户级线程的不同</h2><p>主要区别就是每个用户级线程都有自己的<strong>一个栈</strong>，二每个核心级线程都有自己的<strong>一套栈</strong>。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/18.png" style="zoom:30%;"></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/19.png" style="zoom:50%;"></p>
<p>用户级线程：</p>
<ul>
<li>一个用户栈关联一个TCB， TCB切换引起用户栈切换。</li>
</ul>
<p>核心级线程：</p>
<ul>
<li>一个TCB关联一套栈。TCB在内核中， TCB切换时会切换一套栈，内核栈要切换，核心栈也要切。</li>
</ul>
<h2 id="3-用户栈和核心栈的关联"><a href="#3-用户栈和核心栈的关联" class="headerlink" title="3.用户栈和核心栈的关联"></a>3.用户栈和核心栈的关联</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/20.png" style="zoom:40%;"></p>
<p>出现中断后，进入内核运行时就会出现内核栈。</p>
<ul>
<li>源SS和源SP：用户态执行的栈</li>
<li>源PC和源CS：用户态指令，存储在用户态的上下文环境</li>
<li><p>内核栈通过指针把用户栈拉成一套栈</p>
</li>
<li><p>最后通过IRET进行弹栈，找回用户栈执行的地方</p>
</li>
</ul>
<h4 id="具体例子分析"><a href="#具体例子分析" class="headerlink" title="具体例子分析"></a>具体例子分析</h4><h5 id="用户态切入内核态执行"><a href="#用户态切入内核态执行" class="headerlink" title="用户态切入内核态执行"></a>用户态切入内核态执行</h5><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/21.png" style="zoom:40%;"></p>
<ul>
<li>首先进入A函数，A函数调用B函数，104压入用户栈</li>
<li>进入B函数后，调用read函数，204压入用户栈</li>
<li><strong>read函数是库函数，会展开一段int指令，产生中断，进入内核态</strong></li>
<li>同时内核栈进行<code>备份</code>用户栈信息<ul>
<li>SS:SP为用户栈信息</li>
<li>304为中断执行完之后需要执行的指令</li>
<li>CS是段基址</li>
</ul>
</li>
<li>弹栈执行1000，进入内核执行</li>
<li>内核态执行完成之后就会弹栈</li>
<li>弹出304，回到中断之后的指令</li>
<li>弹出SS:SP，回到用户栈执行状态</li>
</ul>
<h5 id="开始内核态的切换"><a href="#开始内核态的切换" class="headerlink" title="开始内核态的切换"></a>开始内核态的切换</h5><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/22.png" style="zoom:24%;"></p>
<p>在内核进行执行</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sys_read()&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//启动磁盘读;将自己变成阻塞;引发调度</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//找到next线程;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//切换内核栈TCB</span></span><br><span class="line">  switch_to(cur, next);&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>switch_to:</strong>仍然是通过 <strong>TCB</strong>找到内核栈指针<strong>；</strong> 然后通过<strong>ret</strong>切到某个内核程序<strong>；</strong>最后再用 <strong>CS:PC</strong>切到用户程序。</p>
<blockquote>
<p><strong>????：</strong>一段能完成第二级返 回的代码，一段包含 <strong>iret</strong>的代码</p>
</blockquote>
<h2 id="4-内核线程switch-to的五段论"><a href="#4-内核线程switch-to的五段论" class="headerlink" title="4.内核线程switch_to的五段论"></a>4.内核线程switch_to的五段论</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/23.png" style="zoom:50%;"></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/24.png" style="zoom:50%;"></p>
<ul>
<li>首先进行中断，只有中断之后才能实现核心级栈关联用户级栈</li>
<li>在运行过程中可能启动磁盘读或者中断从而利用schedule()产生切换，找到TCB</li>
<li>根据TCB进行内核栈的切换</li>
<li>利用switch_to完成内核栈的切换</li>
<li>内核栈切换完成之后利用iret进行中断返回</li>
</ul>
<h2 id="5-核心线程ThreadCreate"><a href="#5-核心线程ThreadCreate" class="headerlink" title="5.核心线程ThreadCreate"></a>5.核心线程ThreadCreate</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadCreate</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//申请一段内存作为TCB</span></span><br><span class="line">  TCB tcb=get_free_page(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//申请一段内存作为内核栈，内核栈结构体进行初始化</span></span><br><span class="line">  *krlstack = ...; </span><br><span class="line">  *userstack传入; </span><br><span class="line">  填写两个<span class="built_in">stack</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//TCB关联内核栈</span></span><br><span class="line">  tcb.esp=krlstack; </span><br><span class="line">  tcb.状态=就绪;</span><br><span class="line">  tcb入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/25.png" style="zoom:40%;"></p>
<hr>
<blockquote>
 <font color="red">这部分很难，要多看几遍，多思考。</font>

</blockquote>
<hr>
<p><br></p>
<h1 id="六-内核级线程实现"><a href="#六-内核级线程实现" class="headerlink" title="六.内核级线程实现"></a>六.内核级线程实现</h1><blockquote>
<p>进程由资源和执行序列组成，其中执行就是线程，而进程必须要进入内核，所以进程中的执行序列就是内核级线程。学会内核级线程的代码实现，进程的代码实现就学会了一半了。再加上后面学习的内存管理，就可以代码实现进程管理了。</p>
</blockquote>
<h2 id="1-核心级线程切换"><a href="#1-核心级线程切换" class="headerlink" title="1.核心级线程切换"></a>1.核心级线程切换</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/26.png" style="zoom:50%;"></p>
<p>核心级线程的实现主要是两套栈之间的切换。</p>
<ul>
<li>一旦进入内核就是用内核栈。而内核栈和用户栈是通过<code>int</code>这个指令的CPU解释自动拉在一起形成一套。</li>
<li>在内核中执行时，可能会导致在内核中进行切换，调度到另一个线程中。<ul>
<li>首先TCB进行切换，线程控制块中有内核栈的指针，所以TCB切换完成的话，内核栈也就切换完成了。</li>
<li>切换之后在内核段处理一段，完成收尾工作之后，然后通过<code>iret</code>指令，用户栈就跟着切换过来了。</li>
</ul>
</li>
<li>在用户的眼中，就只是用户栈之间的切换，因为查看不到内核操作的细节。</li>
</ul>
<h2 id="2-产生中断，进入内核-第一段"><a href="#2-产生中断，进入内核-第一段" class="headerlink" title="2.产生中断，进入内核(第一段)"></a>2.产生中断，进入内核(第一段)</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  A();</span><br><span class="line">  B();</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//系统调用，引起中断。</span></span><br><span class="line">  fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/27.png" style="zoom:40%;"></p>
<ul>
<li>首先A函数执行，跳A执行，栈中压入B函数。A函数的返回地址就是B函数的初始地址。</li>
<li>进入A函数执行，<code>fork</code>变成<code>0x80</code>的中断指令。</li>
<li>一旦执行int指令，CPU立刻找到当前的内核栈。在内核栈中压入<code>SS</code>和<code>SP</code>。<ul>
<li>int指令执行时没有进入内核，执行完成之后才进入内核。执行时<code>SS</code>和<code>SP</code>指向用户栈。压入当前的<code>CS</code>和<code>IP</code>。由于int指令还在执行，所以现在的<code>CS</code>和<code>IP</code>就是<code>mov res,%eax</code>。执行完之后就进入内核态执行。</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/28.png" style="zoom:40%;"></p>
<ul>
<li>继续执行中断指令，处理中断处理函数——<code>system_call</code>。<ul>
<li>System_call的操作也还是压栈，而寄存器也还是用户态。所以还是记录用户态的信息。</li>
</ul>
</li>
<li><strong><font color="red">以上就是保存 用户态的执行现场，上下文环境 在内核栈中。</font></strong></li>
<li>调用表进入内核具体处理<code>sys_fork</code>，在内核中执行中断产生的真正效果。但是在执行<code>sys_fork</code>的时候有可能会引起切换。<ul>
<li>继续执行时，会把当前线程赋给<code>eax</code>，判断PCB中的state是否为0，如果不是，则进行重新调度(Linux 0.11中非零即为阻塞)。</li>
<li>调度执行完成之后会通过<code>ret_from_sys_call</code>进行中断返回。在中断返回的时候会执行从内核栈到用户栈的切换。</li>
</ul>
</li>
</ul>
<h2 id="3-schedule和中断出口-最后一段"><a href="#3-schedule和中断出口-最后一段" class="headerlink" title="3.schedule和中断出口(最后一段)"></a>3.<strong>schedule</strong>和中断出口(最后一段)</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/29.png" style="zoom:40%;"></p>
<ul>
<li><code>ret_from_sys_call</code>函数中就是进行pop操作，与第一段之间的push相对应。</li>
<li>pop结束之后就进行iret,把<code>SS:SP</code>一些列一起pop出去，切换出来的就是下一个核心级线程执行起来的用户栈。</li>
</ul>
<h2 id="4-switch-to-中间段"><a href="#4-switch-to-中间段" class="headerlink" title="4.switch_to(中间段)"></a>4.switch_to(中间段)</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/30.png" style="zoom:30%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> switch_to(n) </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">long</span> a,b;</span><br><span class="line">  &#125;</span><br><span class="line">	__asm__(<span class="string">&quot;movw %%dx,%1\n\t&quot;</span> <span class="string">&quot;ljmp %0\n\t&quot;</span>::<span class="string">&quot;m&quot;</span>(*&amp;__tmp.a), <span class="string">&quot;m&quot;</span>(*&amp;__tmp.b),<span class="string">&quot;d(_TSS(n))</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p> Linux0.11是利用TSS(任务结构段)进行切换，把基于TSS切换变到基于内核栈切换。</p>
</blockquote>
<p><strong>switch过程：</strong></p>
<ul>
<li><strong><font color="red">跳转准备工作：</font></strong>把当前CPU的所以寄存器放在当前TR所指向的TSS描述符中的的TSS中，构成原TSS。即上一个进程的所有运行场景全保存下来了。</li>
<li><p><strong><font color="red">跳转过程：</font></strong><code>_TSS(n)</code>就是下一个线程的tss，把tss赋给TR，找到TR所指向的TSS描述符中的的TSS，然后将TSS复制到CPU寄存器中。</p>
</li>
<li><p><strong>缺陷：</strong>不能进行指令流水，不能充分利用现代CPU的硬件加速，所以效率不高。</p>
</li>
</ul>
<h2 id="5-ThreadCreate讲解"><a href="#5-ThreadCreate讲解" class="headerlink" title="5.ThreadCreate讲解"></a>5.ThreadCreate讲解</h2><p>从<strong>sys_fork</strong>开始<strong>CreateThread</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCSS"><figure class="iseeu highlight scss"><table><tr><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">	push %gs; pushl %esi </span><br><span class="line">	...</span><br><span class="line">	pushl %eax</span><br><span class="line">	<span class="comment">//父进程创建子进程。</span></span><br><span class="line">	call _copy_process</span><br><span class="line">	addl $20,%esp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp, <span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx, <span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br></pre></td></tr></table></figure></div>
<p><code>copy_process</code>函数传递了很多参数，而这些参数都在内核栈中，这些参数就是父进程在用户态执行的样子，即上下文环境。这些东西都需要传递给<code>_copy_process</code>，这样才能进行创建和父进程一样的子进程。</p>
<p><strong>copy_process</strong>的细节：<strong>创建栈。</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请内存空间获得页内存，malloc是用户态的代码。</span></span><br><span class="line"><span class="comment">//用来作为TCB</span></span><br><span class="line">p=(struct task_struct *)get_free_page(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建内核栈</span></span><br><span class="line"><span class="comment">//设置TSS</span></span><br><span class="line">p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p; </span><br><span class="line">p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建用户栈(和父进程共用栈)</span></span><br><span class="line"><span class="comment">//ss和esp是父进程所传递的参数</span></span><br><span class="line">p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>; </span><br><span class="line">p-&gt;tss.esp = esp;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><strong>copy_process</strong>的细节:执行前准备</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;tss.eip = eip; </span><br><span class="line">p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>; </span><br><span class="line"><span class="comment">//将执行地址cs:eip放在tss中</span></span><br><span class="line">p-&gt;tss.eax = <span class="number">0</span>;</span><br><span class="line">p-&gt;tss.ecx = ecx; </span><br><span class="line"><span class="comment">//执行时的寄存器也放进去了 </span></span><br><span class="line">p-&gt;tss.ldt = _LDT(nr); </span><br><span class="line">set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>) + FIRST_TSS_ENTRY, &amp;(p-&gt;tss));</span><br><span class="line">set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>) + FIRST_LDT_ENTRY, &amp;(p-&gt;ldt));</span><br><span class="line"><span class="comment">//内存跟着切换</span></span><br><span class="line">p-&gt;state = TASK_RUNNING;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<hr>
<p><br></p>
<h1 id="七-CPU调度"><a href="#七-CPU调度" class="headerlink" title="七.CPU调度"></a>七.CPU调度</h1><h2 id="1-CPU调度的直观想法"><a href="#1-CPU调度的直观想法" class="headerlink" title="1.CPU调度的直观想法"></a>1.CPU调度的直观想法</h2><p>就绪队列中有一堆进程，应该选择哪一个来执行。这其中就涉及到调度算法。</p>
<ul>
<li><strong>FIFO先入先出</strong><ul>
<li>谁先进入，先调度谁<strong>：</strong>简单有效，比如银行和食堂</li>
<li>但是如果只是一个简单询问业务的人该怎么办<strong>?</strong>，这就涉及到优先级。</li>
</ul>
</li>
<li><p><strong>Priority优先级</strong></p>
<ul>
<li>任务短可以适当优先</li>
<li>当询问时间越来越长时需要降低优先级</li>
</ul>
</li>
<li><p><strong>如何设计调度算法？</strong></p>
<ul>
<li>面对进程，<strong>CPU</strong>调度的目标应该是让进程满意，即时间更短。<ul>
<li><strong>尽快结束任务:</strong> 周转时间<strong>(</strong>从任务进入到任务结束<strong>)</strong>短 </li>
<li><strong>用户操作尽快响应:</strong> 响应时间<strong>(</strong>从操作发生到响应<strong>)</strong>短 </li>
<li><strong>系统内耗时间少:</strong> 吞吐量<strong>(</strong>完成的任务量<strong>)</strong></li>
</ul>
</li>
<li>总原则<strong>:</strong> 系统专注于任务执行，又能合理调配任务。</li>
</ul>
</li>
<li><p><strong>如何做到合理？</strong></p>
<blockquote>
<p>需要折中和综合。</p>
</blockquote>
<ul>
<li><p><strong>吞吐量和响应时间之间有矛盾</strong></p>
<ul>
<li>响应时间小—&gt;切换次数多—&gt;系统内耗大—&gt;吞吐量小</li>
<li>所以调度需要折中和平衡</li>
</ul>
</li>
<li><p><strong>前台任务和后台任务的关注点不同</strong></p>
<ul>
<li>前台任务关注响应时间，后台任务关注周转时间</li>
</ul>
</li>
<li><p><strong>IO约束型任务</strong>和<strong>CPU约束型任务</strong>有各自的特点</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/31.png" style="zoom:50%;"></p>
</li>
</ul>
<p>折中和综合让操作系统变得复杂， 但有效的系统又要求尽量简单。</p>
</li>
</ul>
<p><br></p>
<h2 id="2-CPU调度算法"><a href="#2-CPU调度算法" class="headerlink" title="2.CPU调度算法"></a>2.CPU调度算法</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/32.png" style="zoom:50%;"></p>
<h3 id="1-First-Come，First-Served-FCFS"><a href="#1-First-Come，First-Served-FCFS" class="headerlink" title="(1).First Come，First Served (FCFS)"></a>(1).First Come，First Served (FCFS)</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/33.png" style="zoom:50%;"></p>
<p> 平均周转时间：</p>
<p>(10+39+42+49+61)/5 = 40.2</p>
<h3 id="2-短作业优先"><a href="#2-短作业优先" class="headerlink" title="(2).短作业优先"></a>(2).短作业优先</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/34.png" style="zoom:50%;"></p>
<p>平均周转时间：</p>
<p>$p_1+p_1+p_2+p_1+p_2+p_3+…=\sum(n+1-i)p_i$，此时平均周转时间最少。</p>
<p>但是<strong>周转时间会打折扣。</strong></p>
<p>解决办法：利用时间片进行轮转。</p>
<h3 id="3-时间片轮转算法"><a href="#3-时间片轮转算法" class="headerlink" title="(3).时间片轮转算法"></a>(3).时间片轮转算法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/35.png" style="zoom:50%;"></p>
<p>但是问题<strong>：时间片大: 响应时间太长; 时间片小: 吞吐量小</strong></p>
<p>进行折衷<strong>:</strong> 时间片<strong>10-100ms</strong>，切换时间<strong>0.1-1ms(1%)</strong></p>
<h3 id="4-设置优先级调度算法"><a href="#4-设置优先级调度算法" class="headerlink" title="(4).设置优先级调度算法"></a>(4).设置优先级调度算法</h3><blockquote>
<p><strong>Word</strong>很关心响应时间，而<strong>gcc</strong>更关心周转时间，两类任务同时存在怎么办<strong>?</strong></p>
</blockquote>
<p>让一个调度算法让多种类型的任务同时都满意的直观想法是：定义前台任务和后台任务两队列，前台<strong>RR</strong>，后台<strong>SJF</strong>，只有前台任务没有时才调度后台任务。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/36.png" style="zoom:50%;"></p>
<p>但是这样又会出现问题：如果一直出现前台任务，则后台任务一直得不到执行。</p>
<p>解决方法：<strong>后台任务优先级动态升高，</strong>但后台任务<strong>(</strong>用<strong>SJF</strong>调度<strong>)</strong>一旦执行，前台的响应时间就会变短。</p>
<p>所以需要折中和平衡。</p>
<p><br></p>
<hr>
<h1 id="八-一个实际的schedule函数"><a href="#八-一个实际的schedule函数" class="headerlink" title="八.一个实际的schedule函数"></a>八.一个实际的schedule函数</h1><h2 id="1-Linux-0-11的调度函数schedule"><a href="#1-Linux-0-11的调度函数schedule" class="headerlink" title="1.Linux 0.11的调度函数schedule()"></a>1.Linux 0.11的调度函数schedule()</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Schedule</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//在kernel/sched.c中 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    c=<span class="number">-1</span>; </span><br><span class="line">    next=<span class="number">0</span>; </span><br><span class="line">    i=NR_TASKS;</span><br><span class="line"> 		<span class="comment">//p指针指向数组的末尾</span></span><br><span class="line">    p=&amp;task[NR_TASKS];</span><br><span class="line">    <span class="comment">//从后往前移动</span></span><br><span class="line">    <span class="keyword">while</span>(--i)</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="comment">//如果是就绪状态，找到了最大的counter，可以进行优先级，也可以作为时间片</span></span><br><span class="line">      <span class="keyword">if</span>((*p-&gt;state == TASK_RUNNING&amp;&amp;(*p)-&gt;counter&gt;c)</span><br><span class="line">         c=(*p)-&gt;counter, next=i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c) </span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">         </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果就绪态的count全用完了，所有进程重置count/2，然后加上优先级，所有阻塞之后会变大</span></span><br><span class="line">    <span class="keyword">for</span>(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)</span><br><span class="line">       (*p)-&gt;counter=((*p)-&gt;counter&gt;&gt;<span class="number">1</span>) +(*p)-&gt;priority; </span><br><span class="line">  &#125;</span><br><span class="line">  switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="2-count的作用"><a href="#2-count的作用" class="headerlink" title="2.count的作用"></a>2.count的作用</h2><ul>
<li><p><strong>时间片</strong></p>
<ul>
<li>可以作为轮转调度的时间片，保证响应</li>
</ul>
</li>
<li><p><strong>优先级</strong></p>
<ul>
<li>可以代表优先级进行动态调整</li>
</ul>
</li>
<li><p><strong>counter</strong>保证了响应时间的界，因为是除2操作，所以最后会收敛到原来的两倍。</p>
</li>
<li>经过<strong>IO</strong>以后，<strong>counter</strong>就会变大；<strong>IO</strong>时间越长，<strong>counter</strong>越大，照顾了<strong>IO</strong>进程，变相的照顾了前台进程。</li>
<li>每个进程只用维护一个<strong>counter</strong>变量，简单、高效。</li>
</ul>
<hr>
<p><br></p>
<h1 id="九-进程同步和信号量"><a href="#九-进程同步和信号量" class="headerlink" title="九.进程同步和信号量"></a>九.进程同步和信号量</h1><h2 id="一-进程同步"><a href="#一-进程同步" class="headerlink" title="(一).进程同步"></a>(一).进程同步</h2><p>用不那么学术的解释：需要让“进程走走停停”来保证多进程合作的合理有序就是进程同步。</p>
<p>先分析在哪里需要进程阻塞，然后再分析在哪里需要发信号，这样就实现了多个进程之间的同步。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/37.png" style="zoom:50%;"></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/38.png" style="zoom:30%;"></p>
<p><strong>(1)</strong> 缓冲区满以后生产者<strong>P1</strong>生产一个<strong>item</strong>放入，会<strong>sleep </strong></p>
<p><strong>(2)</strong> 又一个生产者<strong>P2</strong>生产一个<strong>item</strong>放入，会<strong>sleep</strong></p>
<p><strong>(3)</strong> 消费者<strong>C</strong>执行<strong>1</strong>次循环，<strong>counter==BUFFER_SIZE-1</strong>， 发信号给<strong>P1</strong>，<strong>P1</strong> <strong>wakeup</strong></p>
<p><strong>(4)</strong> 消费者<strong>C</strong>再执行<strong>1</strong>次循环，<strong>counter==BUFFER_SIZE-2</strong>，<strong>P2</strong>不能被唤醒。</p>
<p>所以只靠信号不能够解决全部问题，因为还需要知道有多少个进程在睡眠。</p>
<h2 id="2-从信号到信号量"><a href="#2-从信号到信号量" class="headerlink" title="(2).从信号到信号量"></a>(2).从信号到信号量</h2><p>还是上面的例子，所以还需要记录一些信息。</p>
<p>能记录有“<strong>2</strong>个进程等待”就可以了</p>
<p><strong>(1)</strong> 缓冲区满，<strong>P1</strong>执行，<strong>P1</strong> <strong>sleep</strong>，记录下<strong>1</strong>个进程等待，信号量<strong>sem</strong>设置为-1</p>
<p><strong>(2) P2</strong>执行， <strong>P2</strong> <strong>sleep</strong>，记录下<strong>2</strong>个进程等待，信号量<strong>sem</strong>设置为<strong>-2</strong></p>
<p><strong>(3) C</strong>执行<strong>1</strong>次循环，发现<strong>2</strong>个进程等待，<strong>wakeup 1</strong>个，信号量<strong>sem</strong>设置为<strong>-1</strong></p>
<p><strong>(4) C</strong>再执行<strong>1</strong>次循环，发现还有一个进程等待，<strong>wakeup</strong> 1个，信号量<strong>sem</strong>设置为0</p>
<p><strong>(5) C</strong>再执行<strong>1</strong>次循环，信号量sem设置为<strong>1</strong>。</p>
<p><strong>(6) P3</strong>执行，信号量sem设置为<strong>0</strong>。</p>
<p><strong>所以可以根据信号量的值，来决定什么时候等，什么时候走。</strong></p>
<h2 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="(3).基本概念"></a>(3).基本概念</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/39.png" style="zoom:40%;"></p>
<p>信号量<strong>: 1965</strong>年，由荷兰学者<strong>Dijkstra</strong>提出的一种特殊整型变量，量用来记录，信号用来<strong>sleep</strong>和<strong>wakeup</strong>。</p>
<p>所以当消费资源时，会调用<code>P</code>函数，来查看是否还剩余资源个数，然后进行对应的操作。</p>
<h2 id="4-用信号量来解决生产者—消费者问题"><a href="#4-用信号量来解决生产者—消费者问题" class="headerlink" title="(4).用信号量来解决生产者—消费者问题"></a>(4).用信号量来解决生产者—消费者问题</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/40.png" style="zoom:50%;"></p>
<p><strong>从生产者角度：</strong></p>
<ul>
<li>首先测试资源空闲区是否为0 </li>
<li>在操作之前加锁，保证一次只能有一个用户操作</li>
<li>然后进行操作</li>
<li>操作结束释放锁</li>
<li>生产者进行信号量+1操作</li>
</ul>
<p><strong>从消费者角度：</strong></p>
<ul>
<li>首先测试资源空闲区是否满</li>
<li>在操作之前加锁，保证一次只能有一个用户操作</li>
<li>然后进行操作</li>
<li>操作结束释放锁</li>
<li>消费者进行信号量-1操作</li>
</ul>
<hr>
<p><br></p>
<h1 id="十-信号量临界区保护"><a href="#十-信号量临界区保护" class="headerlink" title="十.信号量临界区保护"></a>十.信号量临界区保护</h1><h2 id="一-为什么需要保护信号量"><a href="#一-为什么需要保护信号量" class="headerlink" title="(一).为什么需要保护信号量"></a>(一).为什么需要保护信号量</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/41.png" style="zoom:50%;"></p>
<p>P1进程在没有把register写入empty的时候发生调度，这样会导致信号量的值与信号量所表达的含义不同，这样肯定会发生错误。这就是需要保护信号量的原因。是因为共享数据没有进行保护而产生的<strong>竞争错误。</strong></p>
<h3 id="1-解决竞争条件的直观想法"><a href="#1-解决竞争条件的直观想法" class="headerlink" title="1.解决竞争条件的直观想法"></a>1.解决竞争条件的直观想法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/42.png" style="zoom:50%;"></p>
<p>P2进程会检查empty的锁，如果P1还在执行，则会空转来进行等待P1执行，知道empty完成赋值后才会执行。</p>
<p>也就是一段代码一次只允许一个进程进入，这就是<strong>原子操作</strong>。</p>
<h3 id="2-临界区-Critial-Section"><a href="#2-临界区-Critial-Section" class="headerlink" title="2.临界区(Critial Section)"></a>2.临界区(Critial Section)</h3><p><strong>临界区:</strong> 一次只允许一个进程进入的该进程的那一段代码。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/43.png" style="zoom:40%;"></p>
<p>在P1进程进入empty操作的代码时，P2不能进入它相应的empty操作代码。</p>
<h2 id="二-如何保护临界区"><a href="#二-如何保护临界区" class="headerlink" title="(二).如何保护临界区"></a>(二).如何保护临界区</h2><h3 id="1-临界区代码的保护原则"><a href="#1-临界区代码的保护原则" class="headerlink" title="1.临界区代码的保护原则"></a>1.临界区代码的保护原则</h3><p><strong>互斥进入:</strong> 如果一个进程在临界区中执行，则其他进程 不允许进入。这些进程间的约束关系称为互斥<strong>(mutual exclusion)</strong>。</p>
<p><strong>好的临界区保护原则：</strong></p>
<ul>
<li><strong>有空让进:</strong> 若干进程要求进入空闲临界区时，应尽快使一进程进入临界区</li>
<li><strong>有限等待:</strong> 从进程发出进入请求到允许进入， 不能无限等待</li>
</ul>
<h3 id="2-轮换法"><a href="#2-轮换法" class="headerlink" title="2.轮换法"></a>2.轮换法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/44.png" style="zoom:50%;"></p>
<p>但是不满足<strong>有空让进</strong>。</p>
<h3 id="3-标记法"><a href="#3-标记法" class="headerlink" title="3.标记法"></a>3.标记法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/45.png" style="zoom:40%;"></p>
<p>flag[0]和flag[1]都为true的时候会导致<strong>无限等待</strong>。</p>
<h3 id="4-Peterson算法"><a href="#4-Peterson算法" class="headerlink" title="4.Peterson算法"></a>4.Peterson算法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/46.png" style="zoom:50%;"></p>
<p>满足 <strong>互斥进入，有空让进 和 有限等待</strong>。</p>
<h3 id="5-多进程—面包店算法"><a href="#5-多进程—面包店算法" class="headerlink" title="5.多进程—面包店算法"></a>5.多进程—面包店算法</h3><blockquote>
<p>仍然是标记和轮转的结合。</p>
</blockquote>
<p><strong>如何轮转:</strong> 每个进程都获得一个序号，序号最小的进入。</p>
<p><strong>如何标记:</strong> 进程离开时序号为<strong>0</strong>，不为<strong>0</strong>的序号即标记。</p>
<p>面包店<strong>:</strong> 每个进入商店的客户都获得一个号码，号码最小的先得到服务；号码相同时，名字靠前的先服务。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/47.png" style="zoom:50%;"></p>
<p><strong>互斥进入: Pi</strong>在临界区内，<strong>Pk</strong>试图进入，一定有<strong>(num[i], i)&lt;(num[k],k)</strong>，<strong>Pk</strong>循环等待。</p>
<p><strong>有空让进:</strong> 如果没有进程在临界区中，最小序号的进程一定能够进入。</p>
<p><strong>有限等待:</strong> 离开临界区的进程再次进入一定排在最后<strong>(FIFO)</strong>，所以任一个想进入进程至多等<strong>n</strong>个进程。</p>
<h3 id="三-硬件方法"><a href="#三-硬件方法" class="headerlink" title="(三).硬件方法"></a>(三).硬件方法</h3><h3 id="1-关中断"><a href="#1-关中断" class="headerlink" title="1.关中断"></a>1.关中断</h3><p>只允许一个进程进入，进入另一个进程意味着被调度。另一个进程只有被调度才能执行，才可能进入临界区，如何阻止调度？<strong>直接关掉中断。</strong>但是在多CPU(多核)的情况下不好使。</p>
<h3 id="2-原子指令法"><a href="#2-原子指令法" class="headerlink" title="2.原子指令法"></a>2.原子指令法</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/48.png" style="zoom:50%;"></p>
<p>原子指令一次执行完毕。</p>
<hr>
<p><br></p>
<h1 id="十一-死锁处理"><a href="#十一-死锁处理" class="headerlink" title="十一.死锁处理"></a>十一.死锁处理</h1><h2 id="一-信号量使用不当出现的问题"><a href="#一-信号量使用不当出现的问题" class="headerlink" title="(一).信号量使用不当出现的问题"></a>(一).信号量使用不当出现的问题</h2><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/49.png" style="zoom:50%;"></p>
<ul>
<li>假设mutex=1，empty=0，则经过两个p操作之后各减1，此时empty=-1，会阻塞。</li>
<li>消费者工作时，mutex进行p操作，mutex=-1，也会阻塞。</li>
<li>这样会造成一种环路等待，谁也无法执行下去。</li>
</ul>
<h2 id="二-死锁的成因"><a href="#二-死锁的成因" class="headerlink" title="(二).死锁的成因"></a>(二).死锁的成因</h2><ul>
<li>资源互斥使用，一旦占有别人无法使用</li>
<li>进程占有了一 些资源，又不释放，再去申请其他资源</li>
<li>各自占有的资源和互相申请的资源形成了<strong>环路等待</strong></li>
</ul>
<p><strong>死锁的4个必要条件：</strong></p>
<ul>
<li><strong>互斥使用(Mutual exclusion)：</strong>资源的固有特性，如道口 </li>
<li><strong>不可抢占(No preemption)：</strong>资源只能自愿放弃，如车开走以后 </li>
<li><strong>请求和保持(Hold and wait)：</strong>进程必须占有资源，再去申请</li>
<li><strong>循环等待(Circular wait)：</strong> 在资源分配图中存在一个环路</li>
</ul>
<h2 id="三-死锁处理的方法"><a href="#三-死锁处理的方法" class="headerlink" title="(三).死锁处理的方法"></a>(三).死锁处理的方法</h2><ul>
<li><p><strong>死锁预防</strong> </p>
<blockquote>
<p>破坏死锁出现的条件</p>
</blockquote>
</li>
<li><p><strong>死锁避免</strong></p>
<blockquote>
<p>检测每个资源请求，如果造成死锁就拒绝</p>
</blockquote>
</li>
<li><p><strong>死锁检测+恢复</strong></p>
<blockquote>
<p>检测到死锁出现时，让一些进程回滚，让出资源</p>
</blockquote>
</li>
<li><p><strong>死锁忽略</strong></p>
<blockquote>
<p>就好像没有出现死锁一样</p>
</blockquote>
</li>
</ul>
<h3 id="死锁避免—银行家算法"><a href="#死锁避免—银行家算法" class="headerlink" title="死锁避免—银行家算法"></a>死锁避免—银行家算法</h3><p>如果系统中的所有进程存在一个可完成的执行序列<strong>P1, P2, …, Pn</strong>，则称系统处于安全状态。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/50.png" style="zoom:60%;"></p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/51.png" style="zoom:40%;"></p>
<p>存在安全序列：<strong>P1, P3, P2, P4, P0</strong>。所以不会死锁。</p>
<p>请求出现时<strong>:</strong> 首先假装分配，然后调用银行家算法。</p>
<p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/52.png" style="zoom:50%;"></p>
<p>进程<strong>P0, P1, P2, P3, P4</strong>一个也没法执行，为死锁进程组。所以<strong>此次申请会被拒绝。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/11/10/%E5%93%88%E5%B7%A5%E5%A4%A7%E5%AD%A6%E4%B9%A0%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/53.png" style="zoom:40%;"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅰ绪论</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一.绪论"></a>一.绪论</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="(一).概念"></a>(一).概念</h2><p><strong>1.数据：</strong>是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<blockquote>
<p>这里说的数据，其实就是符号，而且这些符号必须具备两个前提：</p>
<ul>
<li>可以输入到计算机中。</li>
<li>能被计算机程序处理。</li>
</ul>
</blockquote>
<p><strong>2.数据元素：</strong>是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p>
<p><strong>3.数据项：</strong>一个数据元素可以由若干个数据项组成。</p>
<blockquote>
<p>数据项是数据不可分割的最小单位。在数据结构中，把数据项定义为最小单位，是有助于我们更好地解决问题。</p>
</blockquote>
<p><strong>4.数据对象：</strong>是性质相同的数据元素的集合，是数据的子集，<strong>简称数据</strong>。</p>
<blockquote>
<p>性质相同，是指数据元素具有相同数量和类型的数据项。</p>
</blockquote>
<p><strong>5.数据结构：</strong>是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<blockquote>
<p> 在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。</p>
</blockquote>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/1.png" style="zoom:50%;"></p>
<h2 id="二-逻辑与物理结构"><a href="#二-逻辑与物理结构" class="headerlink" title="(二).逻辑与物理结构"></a>(二).逻辑与物理结构</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><blockquote>
<p>逻辑结构：是指数据对象中数据元素之间的相互关系。其实这也是我们今后最需要关注的问题。逻辑结构分为以下四种。</p>
</blockquote>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/2.png" style="zoom:50%;"></p>
<h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2.物理结构"></a>2.物理结构</h3><p><strong>物理结构：</strong>是指数据的逻辑结构在计算机中的<strong>存储形式</strong>。</p>
<blockquote>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</p>
</blockquote>
<p>数据元素的存储结构形式有两种：<strong>顺序存储</strong>和<strong>链式存储</strong>。</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p><strong>顺序存储结构：</strong>是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。如下图所示。</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/3.png" style="zoom:50%;"></p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>链式存储结构：</strong>是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此<strong>需要用一个指针存放数据元素的地址</strong>，这样通过地址就可以找到相关联数据元素的位置。如下图所示。</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A0%E7%BB%AA%E8%AE%BA/4.png" style="zoom:40%;"></p>
<h2 id="三-抽象数据类型"><a href="#三-抽象数据类型" class="headerlink" title="(三).抽象数据类型"></a>(三).抽象数据类型</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p><strong>数据类型：</strong>是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。</p>
<blockquote>
<p>数据类型是按照值的不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
</blockquote>
<p>抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</p>
<h3 id="2-抽象数据类型"><a href="#2-抽象数据类型" class="headerlink" title="2.抽象数据类型"></a>2.抽象数据类型</h3><p><strong>抽象数据类型(Abstract Data Type，ADT)：</strong>是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<hr>
<p>&lt;/br&gt;</p>
<h1 id="二-算法"><a href="#二-算法" class="headerlink" title="二.算法"></a>二.算法</h1>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>数据结构绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅱ线性表</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-线性表"><a href="#一-线性表" class="headerlink" title="一.线性表"></a>一.线性表</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>线性表（List）：</strong>零个或有限个数据类型相同的数据元素的有限序列。</p>
<blockquote>
<p><strong>性质：</strong></p>
<ul>
<li>线性表中的数据元素之间是有顺序的。</li>
<li>线性表中的数据元素个数是有限的。</li>
<li>线性表中的数据元素的类型必须相同。</li>
</ul>
</blockquote>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/1.png" style="zoom:50%;"></p>
<p>&lt;/br&gt;</p>
<h2 id="2-线性表的抽象数据类型"><a href="#2-线性表的抽象数据类型" class="headerlink" title="2.线性表的抽象数据类型"></a>2.线性表的抽象数据类型</h2><p><strong>线性表的抽象数据类型定义如下：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a1, a2, ......, an&#125;，每个元素的类型均为DataType。</span><br><span class="line">    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，</span><br><span class="line">    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。</span><br><span class="line">    数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line"><span class="comment">/*该方法用于创建并且返回一个空的线性表*/</span></span><br><span class="line"><span class="function">List* <span class="title">List_Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于销毁一个线性表list*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Destroy</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于将一个线性表list中的所有元素清空,使得线性表回到创建时的初始状态*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Clear</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于返回一个线性表list中的所有元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Length</span><span class="params">(List* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于向一个线性表list的pos位置处插入新元素node,返回值为1表示插入成功，0表示插入失败*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">List_Insert</span><span class="params">(List* <span class="built_in">list</span>, ListNode* node, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于获取一个线性表list的pos位置处的元素,返回值为pos位置处的元素，NULL表示获取失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Get</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*该方法用于删除一个线性表list的pos位置处的元素,返回值为被删除的元素，NULL表示删除失败*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">List_Delete</span><span class="params">(List* <span class="built_in">list</span>, <span class="keyword">int</span> pos)</span></span>;</span><br></pre></td></tr></table></figure></div>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="3-线性表的顺序存储结构"><a href="#3-线性表的顺序存储结构" class="headerlink" title="3.线性表的顺序存储结构"></a>3.线性表的顺序存储结构</h2><h3 id="1-结构分析"><a href="#1-结构分析" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>线性表的顺序存储结构</strong>，指的是用一段地址连续的存储单元依次存储线性表的数据元素。线性表（a1,a2,……,an）的顺序存储示意图如下：</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/2.png" style="zoom:45%;">. </p>
<p><strong>在C中用一维数组来实现顺序存储结构：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">存储空间的起始位置:数组node</span></span><br><span class="line"><span class="comment">线性表的最大容量:数组长度MAXSIZE</span></span><br><span class="line"><span class="comment">线性表的当前长度:length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20             </span></span><br><span class="line"><span class="comment">/* ElemType类型根据实际情况而定，这里假设为int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;          </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* 数组存储数据元素，最大值为MAXSIZE */</span></span><br><span class="line">    ElemType data[MAXSIZE];    </span><br><span class="line">    <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">    <span class="keyword">int</span> length;                </span><br><span class="line">&#125; SeqList;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作"><a href="#2-重点操作" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建线性表"><a href="#创建线性表" class="headerlink" title="创建线性表"></a>创建线性表</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>创建</li>
<li>分配内存</li>
<li>检验分配情况并把新建完的链表的指针指向结构体地址后的node处</li>
<li>返回表的地址</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/6.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建</span></span><br><span class="line">TSeqList* ret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(capacity &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//2.分配内存（结构体+数据表）</span></span><br><span class="line">    ret = (TSeqList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TSeqList) + <span class="keyword">sizeof</span>(TSeqListNode) * capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.检验分配是否成功</span></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret-&gt;capacity = capacity;</span><br><span class="line">    ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新建完的链表的指针指向结构图后的node处</span></span><br><span class="line">    ret-&gt;node = (TSeqListNode*)(ret + <span class="keyword">sizeof</span>(TSeqList));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回新建成功的链表</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>直接通过数组下标的方式获取元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (List != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; List-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//3.获取元素</span></span><br><span class="line">   ret = List-&gt;node[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素操作"><a href="#插入元素操作" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>把最后一个元素到插入位置的元素后移一个位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/3.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (List != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line">ret = ret &amp;&amp; (List-&gt;length + <span class="number">1</span> &lt;= List-&gt;capacity);</span><br><span class="line">ret = ret &amp;&amp; (<span class="number">0</span> &lt;= pos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( pos &gt;= List-&gt;length )</span><br><span class="line">&#123;</span><br><span class="line">		pos = List-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.把最后一个元素到插入位置的元素后移一个位置</span></span><br><span class="line"><span class="keyword">for</span>(i=List-&gt;length; i&gt;pos; i--)</span><br><span class="line">&#123;</span><br><span class="line">		List-&gt;node[i] = List-&gt;node[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.将新元素插入</span></span><br><span class="line">List-&gt;node[i] = (<span class="keyword">int</span>)node;</span><br><span class="line"><span class="comment">//5.线性表长度加1</span></span><br><span class="line">List-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除元素操作"><a href="#删除元素操作" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断删除位置是否合法</li>
<li>将元素取出</li>
<li>将删除位置后的元素分别向前移动一个位置</li>
<li>线性表长度减1</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/4.png" style="zoom:50%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断删除位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">list</span> != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos&lt;= <span class="built_in">list</span>-&gt;length))</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">//3.将元素取出</span></span><br><span class="line">		ret = <span class="built_in">list</span>-&gt;node[pos];</span><br><span class="line">      </span><br><span class="line">		<span class="comment">//4.将删除位置后的元素分别向前移动一个位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = pos+<span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="built_in">list</span>-&gt;node[i<span class="number">-1</span>] = <span class="built_in">list</span>-&gt;node[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//5.线性表长度减1</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-顺序存储的优缺点"><a href="#3-顺序存储的优缺点" class="headerlink" title="(3).顺序存储的优缺点"></a>(3).顺序存储的优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/7.png" style="zoom:40%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="4-线性表的链式存储结构"><a href="#4-线性表的链式存储结构" class="headerlink" title="4.线性表的链式存储结构"></a>4.线性表的链式存储结构</h2><h3 id="1-结构分析-1"><a href="#1-结构分析-1" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>链式存储定义：</strong>为了表示每个数据元素与其直接后继的元素之间的逻辑关系，每个元素除了存储本身的信息之外，还需要存储指示其直接后继的消息。</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/8.png" style="zoom:50%;"></p>
<p><strong>链式存储逻辑结构：</strong>n个结点链接成一个链式线性表的结构叫做<strong>链表</strong>，当每个结点中只包含一个指针域时，叫做<strong>单链表</strong>。</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/9.png" style="zoom:30%;"></p>
<p><strong>链表的基本概念:</strong></p>
<ul>
<li><strong>表头结点：</strong>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息。(<font color="red">本身不是数据元素</font>)</li>
<li><strong>数据结点：</strong>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息。</li>
<li><strong>尾结点：</strong>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/10.png" style="zoom:40%;"></p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/11.png" style="zoom:60%;"></p>
<p><strong>C语言用结构体来定义链表中的结点：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _tag_LinkListNode LinkListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点指针域定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">&#125;TLinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据元素定义示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  LinkListNode header;</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-1"><a href="#2-重点操作-1" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="获取第pos个元素操作"><a href="#获取第pos个元素操作" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//由表头开始通过next指针移动pos次后，当前元素的next指针即指向要获取的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = current-&gt;next;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素操作-1"><a href="#插入元素操作-1" class="headerlink" title="插入元素操作"></a>插入元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/13.png" style="zoom:45%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">int</span> ret = (sList != <span class="literal">NULL</span>) &amp;&amp; (pos &gt;= <span class="number">0</span>) &amp;&amp; (node != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>( ret )</span><br><span class="line">&#123;</span><br><span class="line">    LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">    <span class="comment">//3.由表头开始通过next指针移动pos次后，当前元素的next指针即指向要插入的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; (i&lt;pos) &amp;&amp; (current-&gt;next != <span class="literal">NULL</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.将新元素插入</span></span><br><span class="line">    node-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = node;</span><br><span class="line">    <span class="comment">//5.线性表长度加1</span></span><br><span class="line">    sList-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除元素操作-1"><a href="#删除元素操作-1" class="headerlink" title="删除元素操作"></a>删除元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li><p>判断线性表是否合法</p>
</li>
<li><p>判断插入位置是否合法</p>
</li>
<li>获取第pos个元素</li>
<li>将第pos个元素从链表中删除</li>
<li>线性表长度减1</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/12.png" style="zoom:45%;"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">LinkListNode* ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断插入位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">		LinkListNode* current = (LinkListNode*)sList;</span><br><span class="line">		<span class="comment">//3.获取第pos个元素</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pos; i++)</span><br><span class="line">		&#123;</span><br><span class="line">				current = current-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.将第pos个元素从链表中删除</span></span><br><span class="line">		ret = current-&gt;next;</span><br><span class="line">		current-&gt;next = ret-&gt;next;</span><br><span class="line">		<span class="comment">//5.线性表长度减1</span></span><br><span class="line">		sList-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-单链表结构与顺序存储结构优缺点"><a href="#3-单链表结构与顺序存储结构优缺点" class="headerlink" title="(3).单链表结构与顺序存储结构优缺点"></a>(3).单链表结构与顺序存储结构优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/15.png" style="zoom:50%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5.静态链表"></a>5.静态链表</h2><h3 id="1-结构分析-2"><a href="#1-结构分析-2" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>静态链表：</strong>让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每个下标都对应一个data和一个cur。数据域data，用来存放数据元素，也就是通常我们要处理的数据；而cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把cur叫做游标。</p>
<ul>
<li>顺序表数组中的元素由两个数据域组成:data和cur</li>
<li>data域用于存储数据</li>
<li>cur域用于存储下一个元素在数组中的下标</li>
</ul>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/17.png" style="zoom:60%;"></p>
<p>把未被使用的数组元素称为<strong>备用链表。</strong>而数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；</p>
<p><strong>数组的最后一个元素的cur则存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0。</p>
<p><strong>在C中用一维数组来实现顺序存储结构：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElementType Data;</span><br><span class="line">    <span class="comment">//Cursor,为0时表示无指向 </span></span><br><span class="line">	<span class="keyword">int</span> Cur; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-2"><a href="#2-重点操作-2" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>申请MAXSIZE大小的空间</li>
<li>给游标赋值，最后一个游标赋为0</li>
<li>返回链表指针</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="built_in">list</span> = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List)*MAXSIZE);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="built_in">list</span>[i].Cur = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="built_in">list</span>[MAXSIZE - <span class="number">1</span>].Cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="获取第pos个元素操作-1"><a href="#获取第pos个元素操作-1" class="headerlink" title="获取第pos个元素操作"></a>获取第pos个元素操作</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.判断线性表是否合法</span></span><br><span class="line"><span class="comment">//2.判断位置是否合法</span></span><br><span class="line"><span class="keyword">if</span>( (sList != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">0</span> &lt;= pos) &amp;&amp; (pos &lt; sList-&gt;length) )</span><br><span class="line">&#123;</span><br><span class="line">	sList-&gt;node[<span class="number">0</span>] = sList-&gt;header;</span><br><span class="line">  <span class="comment">//由表头开始通过next域移动pos次后，当前元素的next域即要获取元素在数组中的下标</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    current = sList-&gt;node[current].next;</span><br><span class="line">  &#125;</span><br><span class="line">  object = sList-&gt;node[current].next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="插入元素到位置pos的算法"><a href="#插入元素到位置pos的算法" class="headerlink" title="插入元素到位置pos的算法"></a>插入元素到位置pos的算法</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li><font color="red">在数组中查找空闲位置index</font></li>
<li>由表头开始通过next域移动pos次后，当前元素的next域为要插入的位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h4 id="删除第pos个元素的算法"><a href="#删除第pos个元素的算法" class="headerlink" title="删除第pos个元素的算法"></a>删除第pos个元素的算法</h4><p><strong>操作步骤：</strong></p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>获取第pos个元素</li>
<li>将第pos个元素从链表中删除</li>
<li>线性表长度减1</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>&lt;/br&gt;</p>
<h3 id="3-静态链表优缺点"><a href="#3-静态链表优缺点" class="headerlink" title="(3).静态链表优缺点"></a>(3).静态链表优缺点</h3><p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/18.png" style="zoom:50%;"></p>
<hr>
<p>&lt;/br&gt;</p>
<h2 id="6-循环链表"><a href="#6-循环链表" class="headerlink" title="6.循环链表"></a>6.循环链表</h2><h3 id="1-结构分析-3"><a href="#1-结构分析-3" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3><p><strong>循环链表的定义：</strong>将单链表中最后一个数据元素的next指针指向第一个元素.</p>
<p><img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A1%E7%BA%BF%E6%80%A7%E8%A1%A8/19.png" style="zoom:50%;"></p>
<p>&lt;/br&gt;</p>
<h3 id="2-重点操作-3"><a href="#2-重点操作-3" class="headerlink" title="(2).重点操作"></a>(2).重点操作</h3><p><strong>循环链表拥有单链表的所有操作。</strong></p>
<ul>
<li>创建链表</li>
<li>销毁链表</li>
<li>获取链表长度</li>
<li>清空链表</li>
<li>获取第pos个元素操作</li>
<li>插入元素到位置pos</li>
<li>删除位置pos处的元素</li>
</ul>
<p>&lt;/br&gt;</p>
<h2 id="7-双向链表"><a href="#7-双向链表" class="headerlink" title="7.双向链表"></a>7.双向链表</h2><h3 id="1-结构分析-4"><a href="#1-结构分析-4" class="headerlink" title="(1).结构分析"></a>(1).结构分析</h3>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅲ栈和队列</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅳ串</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A3%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅴ树</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-树的定义"><a href="#一-树的定义" class="headerlink" title="一.树的定义"></a>一.树的定义</h2><h3 id="1-需要掌握的定义："><a href="#1-需要掌握的定义：" class="headerlink" title="1.需要掌握的定义："></a>1.需要掌握的定义：</h3><ul>
<li>结点(根结点，双亲结点，子节点，兄弟结点)</li>
<li>子树和空树</li>
<li>结点的深度和高</li>
<li>有序树和无序树</li>
<li>森林</li>
<li>树的表示方法</li>
</ul>
<blockquote>
<p>对于结点ni，ni的深度是指<strong>从根到ni</strong>的唯一路径的长；ni的高是指<strong>从ni到一片树叶</strong>的最长路径的长。</p>
</blockquote>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/1.png" style="zoom:25%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图1：线性结构与树结构对比</div>
</center>

<p><br></p>
<h2 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二.二叉树"></a>二.二叉树</h2><h3 id="1-二叉树需要掌握的概念"><a href="#1-二叉树需要掌握的概念" class="headerlink" title="1.二叉树需要掌握的概念"></a>1.二叉树需要掌握的概念</h3><h4 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="(1).二叉树的定义"></a>(1).二叉树的定义</h4><ul>
<li>有序树</li>
<li>节点的度只能为0，1，2</li>
</ul>
<h4 id="2-二叉树的性质"><a href="#2-二叉树的性质" class="headerlink" title="(2).二叉树的性质"></a>(2).二叉树的性质</h4><ul>
<li>第$i$层最多有 $2^{i-1}$ 个结点。</li>
<li>若深度为$K$，则最多有$2^K-1$个结点。</li>
<li>终端结点数(叶子结点数)为$n_0$，度为2的结点数为$n_2$，则$n_0$=$n_2$+1。</li>
</ul>
<blockquote>
<p>性质3的计算方法为：对于一个二叉树来说，除了度为0的叶子结点和度为2的结点，剩下的就是度为1的结点(设为$n_1$)，那么总结点$n=n_0+n_1+n_2$。同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为B，那么总结点数$n=B+1$。而分枝数是可以通过$n_1$和$n_2$表示的，即$B$=$n_1$+2<em>$n_2$。所以，n用另外一种方式表示为n=$n_1$+2</em>$n_2$+1。两种方式得到的n值组成一个方程组，就可以得出$n_0$=$n_2$+1。</p>
</blockquote>
<h4 id="3-满二叉树"><a href="#3-满二叉树" class="headerlink" title="(3).满二叉树"></a>(3).满二叉树</h4><ul>
<li><p>概念定义</p>
<ul>
<li>除了叶子结点外其余结点的度都为2，则为满二叉树。</li>
</ul>
</li>
<li><p>性质</p>
<ul>
<li>满二叉树中第i层的节点数为$2^n-1$个。</li>
<li>深度为k的满二叉树必有$2^k-1$个节点，叶子数为$2^k-1$。</li>
<li>满二叉树中不存在度为1的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有n个节点的满二叉树的深度为 $log_2(n+1)$。</li>
</ul>
</li>
</ul>
<h4 id="4-完全二叉树"><a href="#4-完全二叉树" class="headerlink" title="(4).完全二叉树"></a>(4).完全二叉树</h4><ul>
<li>概念定义<ul>
<li>如果二叉树中<strong>除去最后一层节点为满二叉树</strong>，且<font color="red"><strong>最后一层的结点依次从左到右分布</strong></font>，则此二叉树被称为完全二叉树。</li>
</ul>
</li>
</ul>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/2.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图2：完全二叉树与非完全二叉树</div>
</center>


<ul>
<li>性质<ul>
<li>n 个结点的完全二叉树的深度为$⌊log_2n⌋+1$。</li>
<li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号,对于任意一个结点 i,完全二叉树还有以下几个结论成立:<ul>
<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>
<li>如果2*i&gt;n(总结点的个数)，则结点i肯定没有左孩子(为叶子结点)；否则其左孩子是结点2*i 。</li>
<li>如果2*i+1&gt;n，则结点i肯定没有右孩子；否则右孩子是结点2*i+1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="2-二叉树的存储结构"><a href="#2-二叉树的存储结构" class="headerlink" title="2.二叉树的存储结构"></a>2.二叉树的存储结构</h3><h4 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="(1).顺序存储结构"></a>(1).顺序存储结构</h4><p>二叉树的顺序存储，指的是使用顺序表(数组)存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，<font color="red">如果想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树，然后从根节点开始，按照层次依次将树中节点存储到数组即可。</font></p>
<p>如下图所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/3.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图3：普通二叉树的转换</div>
</center>

<p> <br></p>
<p>普通二叉树的数组存储状态如下图所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/4.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图4：普通二叉树的存储状态</div>
</center>

<p><br></p>
<h4 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="(2).链式存储结构"></a>(2).链式存储结构</h4><center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/5.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图5：普通二叉树示意图</div>
</center>

<p>如图5所示，此为一棵普通的二叉树，若将其采用链式存储，则只需从树的根节点开始，将各个节点及其左右孩子使用链表存储即可。因此，图5对应的链式存储结构如图6所示：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/6.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图6：二叉树链式存储结构示意图</div>
</center>

<p>由图可知采用链式存储二叉树时，其节点结构由 3 部分构成：</p>
<ul>
<li>指向左孩子节点的指针（Left）；</li>
<li>节点存储的数据（Element）；</li>
<li>指向右孩子节点的指针（Right）；</li>
</ul>
<p>表示该节点结构的 C 语言代码为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Tree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p><br></p>
<h3 id="3-二叉树遍历介绍"><a href="#3-二叉树遍历介绍" class="headerlink" title="3.二叉树遍历介绍"></a>3.二叉树遍历介绍</h3><h4 id="1-层序遍历"><a href="#1-层序遍历" class="headerlink" title="(1).层序遍历"></a>(1).层序遍历</h4><p>通过对树中各层的节点从左到右依次遍历，即可实现对正棵二叉树的遍历，此种方式称为层次遍历。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/7.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图7：层次遍历二叉树示意图</div>
</center>

<h4 id="2-普通遍历"><a href="#2-普通遍历" class="headerlink" title="(2).普通遍历"></a>(2).普通遍历</h4><p>按照 “从上到下，从左到右” 的顺序遍历整棵二叉树，此种方式称为普通遍历。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/8.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图8：普通遍历二叉树示意图</div>
</center>

<p>在层次遍历中，整个遍历过程只经过各个节点一次，因此在层次遍历过程，每经过一个节点，都必须立刻访问该节点，否则错失良机，后续无法再对其访问。</p>
<p>而普通遍历方式则不同，通过观察图 7 可以看到，整个遍历二叉树的过程中，每个节点都被经过了 3 次（虽然叶子节点看似只经过了 2 次，但实际上可以看做是 3 次）。以图 7 中的节点 2 为例，如图 8 所示，它被经过了 3 次。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/9.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图9：遍历节点2的过程示意图</div>
</center>

<p>因此，在编程实现时可以设定真正访问各个节点的时机，换句话说，既可以在第一次经过各节点时就执行访问程序，也可以在第二次经过各节点时访问，甚至可以在最后一次经过各节点时访问。这也就引出了以下 3 种遍历二叉树的算法：</p>
<ol>
<li><strong><font color="red">先序遍历</font>：每遇到一个节点，先访问，然后再遍历其左右子树（对应图 9 中的 ①）；</strong></li>
<li><strong><font color="red">中序遍历</font>：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树（对应图 9 中的 ②）；</strong></li>
<li><strong><font color="red">后序遍历</font>：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点（对应图 9 中的 ③）；</strong></li>
</ol>
<h2 id="三-遍历二叉树代码实现"><a href="#三-遍历二叉树代码实现" class="headerlink" title="三.遍历二叉树代码实现"></a>三.遍历二叉树代码实现</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>二叉树先序遍历的实现思想是：</p>
<ol>
<li>访问根节点；</li>
<li>访问当前节点的左子树；</li>
<li>若当前节点无左子树，则访问当前节点的右子树；</li>
</ol>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/10.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图10：二叉树</div>
</center>

<p>因此，图 10 中二叉树采用先序遍历得到的序列为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></div>
<h4 id="1-递归先序遍历"><a href="#1-递归先序遍历" class="headerlink" title="(1).递归先序遍历"></a>(1).递归先序遍历</h4><p>前序的规则就是<code>根结点 ---&gt; 左子树 ---&gt; 右子树</code>.在调用递归前进行节点操作。对于先序，就是先访问(输出)该节点。而递归左，递归右侧，会优先递归左侧。<code>直到没有左节点</code>。才会停止。访问次序大致为：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/11.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图11：递归先序遍历过程</div>
</center>

<h4 id="2-非递归优先遍历"><a href="#2-非递归优先遍历" class="headerlink" title="(2).非递归优先遍历"></a>(2).非递归优先遍历</h4><p>非递归的先序利用栈的性质替代递归，因为<code>递归有时候在效率</code>方面不是令人满意的。<br>因为栈的顺序为后进先出。递归是左递归，右递归。<strong>所以利用栈要相反。</strong>利用递归的思路，需要先把右节点进栈，再遍历(输出)左节点。然后循环一直到最后，达到和递归顺序相仿效果。</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/12.jpg" style="zoom:70%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图12：非递归先序遍历过程</div>
</center>

<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h4><p><strong>递归优先遍历：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecursionPreOrderTraverse</span><span class="params">( Tree T )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        DisplayElement( T );<span class="comment">//调用操作结点数据的函数方法</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Left );<span class="comment">//访问该结点的左孩子</span></span><br><span class="line">        RecursionPreOrderTraverse( T-&gt;Right );<span class="comment">//访问该结点的右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果结点为空，返回上一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>非递归优先遍历：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(Tree T)</span></span>&#123;</span><br><span class="line">    Stack <span class="built_in">stack</span> = CreateStack( <span class="number">20</span> );<span class="comment">//定义一个顺序栈</span></span><br><span class="line">    Tree p;<span class="comment">//临时指针</span></span><br><span class="line">    Push( T ,<span class="built_in">stack</span> );<span class="comment">//根结点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">stack</span>-&gt;TopOfStack != <span class="number">-1</span>) &#123;</span><br><span class="line">        p = Top( <span class="built_in">stack</span> );<span class="comment">//取栈顶元素</span></span><br><span class="line">        Pop( <span class="built_in">stack</span> );<span class="comment">//弹栈</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            DisplayElement( p );<span class="comment">//调用结点的操作函数</span></span><br><span class="line">            <span class="comment">//如果该结点有右孩子，右孩子进栈</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;Right) &#123;</span><br><span class="line">                Push(  p-&gt;Right ,<span class="built_in">stack</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;Left;<span class="comment">//一直指向根结点最后一个左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><h2 id="四-二叉树查找树"><a href="#四-二叉树查找树" class="headerlink" title="四.二叉树查找树"></a>四.二叉树查找树</h2><h2 id="五-平衡树-AVL"><a href="#五-平衡树-AVL" class="headerlink" title="五.平衡树(AVL)"></a>五.平衡树(AVL)</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>AVL树本质上是<strong>一棵二叉查找树</strong>，但是它又具有以下特点：<strong><font color="red">它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font></strong>在AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为平衡二叉树。</p>
<p>平衡二叉树和非平衡二叉树对比的例图：</p>
<center class="half"> 
    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/13.png" style="zoom:40%">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图13：左边为一般二叉树，右边为二叉查找树</div>
</center>

<p><strong>平衡因子(bf)：</strong>结点的左子树的深度减去右子树的深度，那么显然-1&lt;=bf&lt;=1;</p>
<h3 id="2-AVL的作用"><a href="#2-AVL的作用" class="headerlink" title="2.AVL的作用"></a>2.AVL的作用</h3><p>对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为$log_2n$，其各操作的时间复杂度 $ O(log_2n)$ 同时也由此而决定。<strong>但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即 $O(n)$  </strong>。</p>
<p>所以可以通过随机化建立二叉搜索树来尽量的避免这种情况，<strong><font color="red">但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。</font></strong></p>
<p>例如：按顺序将一组数据1,2,3,4,5,6分别插入到一棵空二叉查找树和AVL树中，插入的结果如下图：</p>
<p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/14.png" style="zoom:30%"><br>  <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/15.png" style="zoom:40%"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图14：左边为二叉搜索树，右边为二叉平衡树</div></center></p>
<p>由上图可知，同样的结点，由于插入方式不同导致树的高度也有所不同。<strong>特别是在带插入结点个数很多且正序的情况下，会导致二叉树的高度是 $O(N)$ ，而AVL树就不会出现这种情况，树的高度始终是 $O(lgN)$ .高度越小，对树的一些基本操作的时间复杂度就会越小。这也就是引入AVL树的原因。</strong></p>
<h3 id="3-AVL的操作"><a href="#3-AVL的操作" class="headerlink" title="3.AVL的操作"></a>3.AVL的操作</h3><p>AVL树的操作基本和二叉查找树一样，这里关注的是两个变化很大的操作：<strong>插入</strong>和<strong>删除！</strong></p>
<p>AVL树不仅是一颗二叉查找树，它还有其他的性质。<strong>如果按照一般的二叉查找树的插入方式可能会破坏AVL树的平衡性。同理，在删除的时候也有可能会破坏树的平衡性，所以要做一些特殊的处理，包括：单旋转和双旋转！</strong></p>
<h4 id="1-单选转"><a href="#1-单选转" class="headerlink" title="(1).单选转"></a>(1).单选转</h4><p><center class="half"><br>    <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/16.png" style="zoom:90%"><br> <img src="/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A4%E6%A0%91/17.png" style="zoom:100%;"><br>    &lt;/br&gt;<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
display: inline-block;color: #999;padding: 2px;">
图15：单选转</div></center></p>
<p>显示单选转</p>
]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅵ图</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A5%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅶ查找</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A6%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构Ⅷ排序</title>
    <url>/2020/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%85%A7-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一.冒泡排序"></a>一.冒泡排序</h1>]]></content>
      <categories>
        <category>数据结构与算法设计</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
